<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Buffer Pool</title>
    <url>/2021/05/13/Buffer%20Pool/</url>
    <content><![CDATA[<h1 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h1><img src="Buffer Pool/tmp2A21.png" alt="tmp2A21"  />

<blockquote>
<p><strong>内存的数据页</strong>是在 Buffer Pool (BP) 中管理的，在 <strong>WAL 里 Buffer Pool 起到了加速更新的作用</strong>。而实际上，Buffer Pool 还有一个更重要的作用，就是<strong>加速查询。</strong></p>
</blockquote>
<p>当<strong>内存数据页跟磁盘数据页内容不一致</strong>的时候，我们称这个内存页为“<strong>脏页</strong>”。<strong>内存数据写入到磁盘后</strong>，<strong>内存和磁盘上的数据页的内容就一致</strong>了，称为“<strong>干净页</strong>”。</p>
<h2 id="InnoDB-刷脏页的控制策略"><a href="#InnoDB-刷脏页的控制策略" class="headerlink" title="InnoDB 刷脏页的控制策略"></a>InnoDB 刷脏页的控制策略</h2><p>InnoDB 的刷盘速度就是要参考这两个因素：一个是<strong>脏页比例</strong>，一个是 <strong>redo log 写盘速度。</strong></p>
<blockquote>
<p>InnoDB 每次写入的日志都有一个<strong>序号</strong>，当前写入的序号跟 <strong>checkpoint</strong> 对应的序号之间的差值，我们假设为 N。InnoDB 会根据这个 N <strong>算出一个范围在 0 到 100 之间的数字</strong>，这个计算公式可以记为 F2(N)。F2(N) 算法比较复杂，你只要知道 N 越大，算出来的值越大就好了。然后，根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R，之后引擎就可以按照 <strong>innodb_io_capacity</strong> 定义的能力乘以 <strong>R%</strong> 来控制刷脏页的速度。</p>
</blockquote>
<img src="https://static001.geekbang.org/resource/image/cc/74/cc44c1d080141aa50df6a91067475374.png" alt="img" style="zoom: 50%;" />



<h2 id="管理算法LRU-改良版"><a href="#管理算法LRU-改良版" class="headerlink" title="管理算法LRU(改良版)"></a>管理算法LRU(改良版)</h2><p><strong>InnoDB 内存管理用的是最近最少使用 (Least Recently Used, LRU) 算法,但是并没有直接使用，因为如果是全表扫描，Buffer pool里面的数据全被替换成历史数据，内存命中率大大下降</strong></p>
<p>InnoDB 对 <code>LRU 算法做了改进</code></p>
<p><strong>Young区</strong>:经常访问的</p>
<p><strong>Old区</strong>:不怎么访问的</p>
<p>![tmp828E](Buffer Pool&#x2F;tmp828E.png)</p>
<p>在InnoDB实现上，按照**<code>5:3</code><strong>的比例把整个LRU链表分成了</strong>young区域<strong>和</strong>old区域<strong>。图中</strong><code>LRU_old</code><strong>指向的就是old区域的第一个位置，</strong><code>是整个链表的5/8处</code><strong>。也就是说，</strong>靠近链表头部的5&#x2F;8是young区域，靠近链表尾部的3&#x2F;8是old区域**。</p>
<p><strong>Young</strong>区跟之前一样</p>
<ul>
<li>访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉数据页最尾部最久未使用的页(Pm)，但是新插入的数据页(Px)，是放在 <strong><code>LRU_old</code></strong> 处。</li>
<li>处于 old 区域的数据页，每次<strong>被访问</strong>的时候都要做下面这个判断：<ul>
<li><strong>若这个数据页在 LRU 链表中存在的时间超过了 1 秒，就把它移动到链表头部,进入young区</strong>；</li>
<li>如果这个数据页<strong>在 LRU 链表中存在的时间短于 1 秒</strong>，<strong>位置保持不变</strong>。1 秒这个时间，是由参数 <strong><code>innodb_old_blocks_time</code></strong> 控制的。其默认值是 1000，单位毫秒。</li>
</ul>
</li>
</ul>
<p><strong><mark>具体执行步骤</mark></strong></p>
<ol>
<li>扫描过程中，需要新插入的数据页，都被放到 old 区域 ;</li>
<li>一个数据页里面有多条记录，这个数据页会被多次访问到，但由于是顺序扫描，这个数据页第一次被访问和最后一次被访问的时间间隔不会超过 1 秒，因此还是会被保留在 old 区域；</li>
<li>再继续扫描后续的数据**，之前的这个数据页之后也不会再被访问到(也就没有机会存在超过1秒)**，于是始终没有机会移到链表头部（也就是 young 区域），很快就会被淘汰出去。</li>
</ol>
<p>这个策略最大的收益，就是在扫描这个大表的过程中，虽然也用到了 Buffer Pool，但是对 young 区域完全没有影响，从而保证了 Buffer Pool 响应正常业务的<strong>查询命中率。</strong></p>
<blockquote>
<p>如果用旧LRU，扫一个大表Buffer Pool数据就全被置换出去了，内存命中率大大降低</p>
</blockquote>
<h2 id="page"><a href="#page" class="headerlink" title="page"></a>page</h2><p>已经在内存中的表信息</p>
<h2 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h2><blockquote>
<p>普通索引，更新过程中使用**<code>change buffer</code><strong>，一次update，如果是</strong>普通索引**，直接将更新记录在change buffer中，结束</p>
<p>虽然名字叫作 change buffer，实际上它是可以<strong>持久化的数据</strong>。也就是说，change buffer <strong>在内存中有拷贝，也会被写入到磁盘上。</strong>不持久话就会面临数据丢失的一致性问题</p>
<p>写入change buffer 的同时也会写入 redo log，但是作用不同，redo log 主要节省的是随机<strong>写磁盘的IO消耗</strong>（转成顺序写），而change buffer主要节省的则是<strong>随机读磁盘的IO消耗，change buffer 只有被读到的时候才会写入内存</strong>。</p>
</blockquote>
<p><strong>Update:</strong></p>
<p>第一种情况是，这个记录要<strong>更新的目标页在内存中</strong>。这时，InnoDB 的处理流程如下：</p>
<ul>
<li>对于<strong>唯一索引</strong>来说，找到 3 和 5 之间的位置，<strong>判断</strong>到没有冲突，插入这个值，语句执行结束；</li>
<li>对于<strong>普通索引</strong>来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。</li>
</ul>
<p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。</p>
<p>第二种情况是，这个记录要更新的目标页<strong>不在内存中</strong>。这时，InnoDB 的处理流程如下：</p>
<ul>
<li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li>
<li>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</li>
</ul>
<p><strong>merge阶段：</strong></p>
<p>当从磁盘读change buffer中存在的数据页的时候，就会将change buffer中的操作写入这个数据页    </p>
<p>为什么只能普通索引，其他索引不可以呢？</p>
<p>因为如果是其他索引，<strong>比如主键索引，一开始就要查找是否有主键冲突，直接就把表读到内存中来了，</strong>这样不需要<code>change buffer</code>直接在内存中改就可以了</p>
<p><strong><mark>使用建议</mark></strong></p>
<p>如果是写多读少的话，很适合中change buffer，如果写完马上读的话不适合使用change buffer，因为merge会在写完马上进行，这样并没有减少读IO的次数，反而需要给change buffer的维护付出代价</p>
<p><strong><mark>Change buffer 工作流程</mark></strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t(id,k) <span class="keyword">values</span>(id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure>

<p><strong>这边是针对k的索引树的更新，主键是唯一索引，需要进行唯一性判断。</strong></p>
<p><strong>主键索引用不上，都是对于那些二级索引的才有效。 一个insert语句要操作所有索引的嘛，收益在二级索引</strong></p>
<blockquote>
<p>一个insert语句执行，<strong>既要修改主键索引，又要修改普通索引</strong>，但是普通索引可以直接写入change buffer中就结束，下次用到再merge<strong>修正</strong>，<strong>而主键索引需要判断唯一性，读进来判断再修改</strong></p>
</blockquote>
<img src="Buffer Pool/tmpFDC.png" alt="tmpFDC" style="zoom:67%;" />

<blockquote>
<p><strong>数据表空间</strong>：就是一个个的表数据文件，对应的磁盘文件就是“表名.ibd”； </p>
<p><strong>系统表空间</strong>：用来放系统信息，如数据字典等，对应的磁盘文件是“ibdata1”</p>
</blockquote>
<p>这条更新语句做了如下的操作（按照图中的数字顺序）：</p>
<ol>
<li>Page 1 在内存中，直接更新内存；</li>
<li>Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息</li>
<li>将上述两个动作记入 redo log 中（图中 3 和 4）。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> k <span class="keyword">in</span> (k1, k2)</span><br></pre></td></tr></table></figure>

<ol>
<li>读 Page 1 的时候，直接从内存返回</li>
<li><strong>读入内存修正：</strong>要读 Page 2 的时候，需要把 Page 2 从磁盘读入内存中，然后应用 change buffer 里面的操作日志，生成一个正确的版本并返回结果。</li>
</ol>
<h2 id="join-buffer"><a href="#join-buffer" class="headerlink" title="join buffer"></a>join buffer</h2><p><strong>Block Nested-Loop Join</strong></p>
<blockquote>
<p>join <strong>没有利用索引情况下的算法BNL</strong></p>
</blockquote>
<p>将驱动表<code>SELECT *</code>入内存<strong>join_buffer</strong>,因为<strong>驱动表在内存</strong>中，所以处理速度会比Simple快</p>
<p>但是驱动表很大，<strong>join_buffer</strong>不够大怎么办捏？这个时候采用分段法</p>
<p><strong>执行过程</strong>就变成了：</p>
<ol>
<li>扫描表 t1，顺序读取数据行放入 join_buffer 中，放完第 88 行 join_buffer 满了，继续第 2 步；</li>
<li>扫描表 t2，把 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回；</li>
<li><strong>清空</strong> join_buffer；</li>
<li>继续扫描表 t1，顺序读取最后的 12 行数据放入 join_buffer 中，继续执行第 2 步。</li>
</ol>
<blockquote>
<p>join_buffer越大，采用这种算法扫描的行数就会越少</p>
</blockquote>
<p><strong>缺点：</strong></p>
<p>因为驱动表要读进join buffer，驱动表如果很大，那么因为<strong>读取的时间长，很可能存在的时间过了门槛，能进young区</strong>，这样一来本来热点数据又被置换出去</p>
<p>业务正常访问的数据，第一次访问进入<strong>old</strong>，假设2s之后第二次访问，发现old里面没有，因为old被那个正在做join的大的被驱动表被置换出去了，导致原本应该进入young区域的业务数据只好再次读磁盘，再放入old。 </p>
<p><strong>young区域</strong>的情况则是，应该进入young的数据没有进入，则原本要被淘汰的就会留在young里，young的头部还会进入那张冷数据表的数据。</p>
<p><strong>对 Buffer Pool 的影响就是持续性的</strong></p>
<p>也就是说，<strong>BNL</strong> 算法对系统的影响主要包括<code>三个方面</code>：</p>
<ol>
<li>可能会多次扫描被驱动表，占用磁盘 IO </li>
<li>资源；判断 join 条件需要执行 M*N 次对比（M、N 分别是两张表的行数），如果是大表就会占用非常多的 CPU 资源；</li>
<li>可能会导致 Buffer Pool 的热数据被淘汰，影响内存命中率。</li>
</ol>
<h2 id="Soft-Buffer"><a href="#Soft-Buffer" class="headerlink" title="Soft Buffer"></a>Soft Buffer</h2><p>将找出来的行放入sort buffer然后在sort buffer中排序，如果有limit N在排序完之后还会取前N行返回</p>
<p>如果sort buffer放不下还会利用磁盘临时文件来辅助排序，<strong>外部排序：<code>归并排序</code>，MySQL将需要排序的数据分成12份，每一份单独排序后存在这些临时文件中。然后把这12个有序文件再合并成一个有序的大文件。</strong></p>
<p>还有可能采用堆排序优先队列法**:point_right:<a href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E6%B3%95"><code>优先队列—堆排序法</code></a>**</p>
<p><strong><mark>row id排序</mark></strong>:</p>
<p>如果单行数据太大，Mysql还会采用<strong>rowid排序</strong></p>
<p>放入sort_buffer的字段，只有要<strong>排序的列</strong>和<strong>主键id</strong>。排序之后回表找出select的数据返回。</p>
<blockquote>
<p>优先选择全字段排序，如果内存够，就要多利用内存，尽量减少磁盘访问。</p>
</blockquote>
<p><strong><mark>调优参考</mark></strong>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> city <span class="operator">=</span> <span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure>

<p>像这个sql语句可以考虑创建<code>(city,name)</code>利用联合索引，先按city排序然后按name排序，这样相同city的name是有序的</p>
<p><strong><mark>参数</mark></strong>:</p>
<p><strong><code>sort_buffer_size</code></strong>:<strong>就是MySQL为排序开辟的内存（sort_buffer）的大小</strong></p>
<p><strong><code>max_length_for_sort_data</code></strong>:<strong>是MySQL中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果<code>单行的长度超过这个值</code>，MySQL就认为单行太大，要换一个算法。</strong></p>
<h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a><strong>全字段排序</strong></h3><p>![image-20220320162528985](Buffer Pool&#x2F;image-20220320162528985.png)</p>
<h3 id="Row-id排序"><a href="#Row-id排序" class="headerlink" title="Row id排序"></a><strong>Row id排序</strong></h3><p>![image-20220320164000369](Buffer Pool&#x2F;image-20220320164000369.png)</p>
<h3 id="特殊情况-Order-by-rand"><a href="#特殊情况-Order-by-rand" class="headerlink" title="特殊情况:Order by rand()"></a>特殊情况:Order by rand()<a name="orderbyrand"></a></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>![image-20220320163813269](Buffer Pool&#x2F;image-20220320163813269.png)</p>
<blockquote>
<p>Extra字段显示Using temporary，表示的是需要使用**<code>临时表</code><strong>；</strong>Using filesort<strong>，表示的是</strong>需要执行排序操作<strong>。因此这个Extra的意思就是，需要</strong><code>临时表</code><strong>，并且</strong><code>需要在临时表上排序</code><strong>。使用是</strong><mark>Memory</mark><strong>引擎创建的临时表。</strong><a href="#%E4%B8%B4%E6%97%B6%E8%A1%A8">:point_right:临时表种类</a>**</p>
</blockquote>
<ul>
<li>将select的字段和rand()生成的随机0-1之间值组合起来入临时内存表中(**<mark>Memory</mark>**引擎)</li>
<li>将内存表中rand()值和数组下标放入sort buffer中(不是组织索引表row id不是主键,<strong><code>内存表row id是数组下标，数组下标唯一标识一行元素，用于回表</code></strong>)</li>
<li>sort buffer(只管排序)按rand()排序起到随机效果，然后 limit 3 取前三个回表查询，这个**~<strong>，拿着内存表的</strong><code>row id 数组下标</code>**回内存表找数据加入结果集中</li>
</ul>
<p>![image-20220320165820727](Buffer Pool&#x2F;image-20220320165820727.png)</p>
<h3 id="Order-by-limit的优先队列法"><a href="#Order-by-limit的优先队列法" class="headerlink" title="Order by limit的优先队列法"></a>Order by limit的优先队列法<a name="优先队列法"></a></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>在Mysql5.6版本之后采用堆排序，**<code>limit 3</code><strong>前三个数构成大根堆，遍历剩下的值，比根元素小则替换，然后heapify在构成大根堆，以此循环，最后得到的就是最小的三个数，这种情况不需要用到内存表，直接在sort buffer中就可以完成，但是如果</strong>sort buffer太小<strong>，</strong><code>limit 1000</code><strong>要取的数太大，不可能维护一个1000个元素的堆，就会</strong><code>采用磁盘临时表，变成Innodb，采用归并算法</code>**</p>
<h1 id="Mysql的索引"><a href="#Mysql的索引" class="headerlink" title="Mysql的索引"></a>Mysql的索引</h1><blockquote>
<p>MYSQL做<strong>词法分析语法</strong>分析的时候是通过建立<strong>最左子树</strong>来建立<strong>语法树</strong>的，解析的过程也是<strong>从左到右所以遵循最左前缀的原则</strong>。</p>
<p><strong>对索引字段做函数操作</strong>，可能会<strong>破坏索引值的有序性</strong>，因此优化器就决定放弃走树搜索功能。</p>
<ul>
<li>索引字段是varchar，但是where查找字段是数字，会用函数把varchar转换成数字</li>
</ul>
</blockquote>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Docker使用</title>
    <url>/2022/04/19/Docker_Master/</url>
    <content><![CDATA[<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Cent Os 7</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、yum 包更新到最新</span> </span><br><span class="line">yum update</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</span> </span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3、 设置yum源</span></span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.1、阿里云yum源</span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4、 安装docker，出现输入的界面都按 y</span> </span><br><span class="line">yum install -y docker-ce</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5、 查看docker版本，验证是否验证成功</span></span><br><span class="line">docker -v</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><code>Cent Os8</code></strong></p>
<p><a href="https://blog.csdn.net/qq_38883889/article/details/123062993">centos8 阿里源 Errors during downloading metadata for repository ‘BaseOS‘</a></p>
<p><strong><code>Cent Os8安装👇</code></strong></p>
<p><a href="https://blog.csdn.net/weixin_41725792/article/details/109679971">centos8 安装docker报错Error: Unable to find a match: docker</a></p>
<blockquote>
<p><strong>centos8默认使用代替docker，所以需要containerd.io，那我们就安装一下就好了</strong>……….</p>
</blockquote>
<h2 id="Docker-应用部署"><a href="#Docker-应用部署" class="headerlink" title="Docker 应用部署"></a>Docker 应用部署</h2><h3 id="一、部署MySQL"><a href="#一、部署MySQL" class="headerlink" title="一、部署MySQL"></a>一、部署MySQL</h3><ol>
<li>搜索mysql镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拉取mysql镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.6</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建容器，设置端口映射、目录映射</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/root目录下创建mysql目录用于存储mysql数据信息</span></span><br><span class="line">mkdir ~/mysql</span><br><span class="line">cd ~/mysql</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">-p 3307:3306 \</span><br><span class="line">--name=c_mysql \</span><br><span class="line">-v $PWD/conf:/etc/mysql/conf.d \</span><br><span class="line">-v $PWD/logs:/logs \</span><br><span class="line">-v $PWD/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">mysql:5.6</span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明：<ul>
<li><strong>-p 3307:3306</strong>：将容器的 3306 端口映射到宿主机的 3307 端口。</li>
<li><strong>-v $PWD&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d</strong>：将主机当前目录下的 conf&#x2F;my.cnf 挂载到容器的 &#x2F;etc&#x2F;mysql&#x2F;my.cnf。配置目录</li>
<li><strong>-v $PWD&#x2F;logs:&#x2F;logs</strong>：将主机当前目录下的 logs 目录挂载到容器的 &#x2F;logs。日志目录</li>
<li><strong>-v $PWD&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql</strong> ：将主机当前目录下的data目录挂载到容器的 &#x2F;var&#x2F;lib&#x2F;mysql 。数据目录</li>
<li><strong>-e MYSQL_ROOT_PASSWORD&#x3D;123456：</strong>初始化 root 用户的密码。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>进入容器，操作mysql</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec –it c_mysql /bin/bash</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用外部机器连接容器中的mysql</li>
</ol>
<p><img src="/.%5Cimgs%5C1573636765632.png" alt="1573636765632"></p>
<h3 id="二、部署Tomcat"><a href="#二、部署Tomcat" class="headerlink" title="二、部署Tomcat"></a>二、部署Tomcat</h3><ol>
<li>搜索tomcat镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search tomcat</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拉取tomcat镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建容器，设置端口映射、目录映射</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/root目录下创建tomcat目录用于存储tomcat数据信息</span></span><br><span class="line">mkdir ~/tomcat</span><br><span class="line">cd ~/tomcat</span><br></pre></td></tr></table></figure>

<blockquote>
<p>宿主机器**<code>pwd=~/tomcat/</code>**</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -id --name=c_tomcat \</span><br><span class="line">-p 8080:8080 \</span><br><span class="line">-v $PWD:/usr/local/tomcat/webapps \</span><br><span class="line">tomcat </span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明：<ul>
<li><p><strong>-p 8080:8080：</strong>将容器的8080端口映射到主机的8080端口</p>
<p><strong>-v $PWD:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps：</strong>将主机中当前目录挂载到容器的webapps</p>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li>使用外部机器访问tomcat</li>
</ol>
<p><img src="/./imgs%5C1573649804623.png" alt="1573649804623"></p>
<h3 id="三、部署Nginx"><a href="#三、部署Nginx" class="headerlink" title="三、部署Nginx"></a>三、部署Nginx</h3><ol>
<li>搜索nginx镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search nginx</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拉取nginx镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建容器，设置端口映射、目录映射</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/root目录下创建nginx目录用于存储nginx数据信息</span></span><br><span class="line">mkdir ~/nginx</span><br><span class="line">cd ~/nginx</span><br><span class="line">mkdir conf</span><br><span class="line">cd conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在~/nginx/conf/下创建nginx.conf文件,粘贴下面内容</span></span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -id --name=c_nginx \</span><br><span class="line">-p 80:80 \</span><br><span class="line">-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v $PWD/logs:/var/log/nginx \</span><br><span class="line">-v $PWD/html:/usr/share/nginx/html \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明：<ul>
<li><strong>-p 80:80</strong>：将容器的 80端口映射到宿主机的 80 端口。</li>
<li><strong>-v $PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</strong>：将主机当前目录下的 &#x2F;conf&#x2F;nginx.conf 挂载到容器的 :&#x2F;etc&#x2F;nginx&#x2F;nginx.conf。配置目录</li>
<li><strong>-v $PWD&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx</strong>：将主机当前目录下的 logs 目录挂载到容器的&#x2F;var&#x2F;log&#x2F;nginx。日志目录</li>
</ul>
</li>
</ul>
<ol start="4">
<li>使用外部机器访问nginx</li>
</ol>
<p><img src="/.%5Cimgs%5C1573652396669.png" alt="1573652396669"></p>
<h3 id="四、部署Redis"><a href="#四、部署Redis" class="headerlink" title="四、部署Redis"></a>四、部署Redis</h3><ol>
<li>搜索redis镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拉取redis镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull redis:5.0</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建容器，设置端口映射</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -id --name=c_redis -p 6379:6379 redis:5.0</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用外部机器连接redis</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./redis-cli.exe -h 192.168.149.135 -p 6379</span><br></pre></td></tr></table></figure>


<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><table>
<thead>
<tr>
<th>关键字</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>指定父镜像</td>
<td>指定dockerfile基于那个image构建</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>作者信息</td>
<td>用来标明这个dockerfile谁写的</td>
</tr>
<tr>
<td>LABEL</td>
<td>标签</td>
<td>用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看</td>
</tr>
<tr>
<td>RUN</td>
<td>执行命令</td>
<td>执行一段命令 默认是&#x2F;bin&#x2F;sh 格式: RUN command 或者 RUN [“command” , “param1”,”param2”]</td>
</tr>
<tr>
<td>CMD</td>
<td>容器启动命令</td>
<td>提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”]</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>入口</td>
<td>一般在制作一些执行就关闭的容器中会使用</td>
</tr>
<tr>
<td>COPY</td>
<td>复制文件</td>
<td>build的时候复制文件到image中</td>
</tr>
<tr>
<td>ADD</td>
<td>添加文件</td>
<td>build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务</td>
</tr>
<tr>
<td>ENV</td>
<td>环境变量</td>
<td>指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name&#x3D;value</td>
</tr>
<tr>
<td>ARG</td>
<td>构建参数</td>
<td>构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数</td>
</tr>
<tr>
<td>VOLUME</td>
<td>定义外部可以挂载的数据卷</td>
<td>指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”]</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>暴露端口</td>
<td>定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080&#x2F;udp</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>工作目录</td>
<td>指定容器内部的工作目录 如果没有创建则自动创建 如果指定&#x2F; 使用的是绝对地址 如果不是&#x2F;开头那么是在上一条workdir的路径的相对路径</td>
</tr>
<tr>
<td>USER</td>
<td>指定执行用户</td>
<td>指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户</td>
</tr>
<tr>
<td>HEALTHCHECK</td>
<td>健康检查</td>
<td>指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>触发器</td>
<td>当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大</td>
</tr>
<tr>
<td>STOPSIGNAL</td>
<td>发送信号量到宿主机</td>
<td>该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。</td>
</tr>
<tr>
<td>SHELL</td>
<td>指定执行脚本的shell</td>
<td>指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell</td>
</tr>
</tbody></table>
<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><h3 id="一、安装Docker-Compose"><a href="#一、安装Docker-Compose" class="headerlink" title="一、安装Docker Compose"></a>一、安装Docker Compose</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Compose目前已经完全支持Linux、Mac OS和Windows，在我们安装Compose之前，需要先安装Docker。下面我 们以编译好的二进制包方式安装在Linux系统中。</span> </span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置文件可执行权限</span> </span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看版本信息</span> </span><br><span class="line">docker-compose -version</span><br></pre></td></tr></table></figure>

<h3 id="二、卸载Docker-Compose"><a href="#二、卸载Docker-Compose" class="headerlink" title="二、卸载Docker Compose"></a>二、卸载Docker Compose</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">二进制包方式安装的，删除二进制文件即可</span></span><br><span class="line">rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>



<h3 id="三、-使用docker-compose编排nginx-springboot项目"><a href="#三、-使用docker-compose编排nginx-springboot项目" class="headerlink" title="三、 使用docker compose编排nginx+springboot项目"></a>三、 使用docker compose编排nginx+springboot项目</h3><ol>
<li>创建docker-compose目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir ~/docker-compose</span><br><span class="line">cd ~/docker-compose</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写 docker-compose.yml 文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">   image: nginx</span><br><span class="line">   ports:</span><br><span class="line">    - 80:80</span><br><span class="line">   links:</span><br><span class="line">    - app</span><br><span class="line">   volumes:</span><br><span class="line">    - ./nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">  app:</span><br><span class="line">    image: app</span><br><span class="line">    expose:</span><br><span class="line">      - &quot;8080&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建.&#x2F;nginx&#x2F;conf.d目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ./nginx/conf.d</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>在.&#x2F;nginx&#x2F;conf.d目录下 编写itheima.conf文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    access_log off;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://app:8080;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在~&#x2F;docker-compose 目录下 使用docker-compose 启动容器</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>测试访问</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://192.168.149.135/hello</span><br></pre></td></tr></table></figure>



<h2 id="Docker-私有仓库"><a href="#Docker-私有仓库" class="headerlink" title="Docker 私有仓库"></a>Docker 私有仓库</h2><h3 id="一、私有仓库搭建"><a href="#一、私有仓库搭建" class="headerlink" title="一、私有仓库搭建"></a>一、私有仓库搭建</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、拉取私有仓库镜像</span> </span><br><span class="line">docker pull registry</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、启动私有仓库容器</span> </span><br><span class="line">docker run -id --name=registry -p 5000:5000 registry</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到&#123;<span class="string">&quot;repositories&quot;</span>:[]&#125; 表示私有仓库 搭建成功</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4、修改daemon.json</span>   </span><br><span class="line">vim /etc/docker/daemon.json    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器ip修改为自己私有仓库服务器真实ip</span> </span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;私有仓库服务器ip:5000&quot;]&#125; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5、重启docker 服务</span> </span><br><span class="line">systemctl restart docker</span><br><span class="line">docker start registry</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二、将镜像上传至私有仓库"><a href="#二、将镜像上传至私有仓库" class="headerlink" title="二、将镜像上传至私有仓库"></a>二、将镜像上传至私有仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、标记镜像为私有仓库的镜像</span>     </span><br><span class="line">docker tag centos:7 私有仓库服务器IP:5000/centos:7</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、上传标记的镜像</span>     </span><br><span class="line">docker push 私有仓库服务器IP:5000/centos:7</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="三、-从私有仓库拉取镜像"><a href="#三、-从私有仓库拉取镜像" class="headerlink" title="三、 从私有仓库拉取镜像"></a>三、 从私有仓库拉取镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拉取镜像</span> </span><br><span class="line">docker pull 私有仓库服务器ip:5000/centos:7</span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>垃圾回收概述与算法</title>
    <url>/2021/12/05/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC10%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0%E5%92%8C%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0001.png">

<ol>
<li><p>Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C++语言没有垃圾收集技术，需要程序员手动的收集。</p>
</li>
<li><p>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</p>
</li>
<li><p>关于垃圾收集有三个经典问题：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
</li>
<li><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p>
</li>
</ol>
<h2 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h2><h3 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h3><ol>
<li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1？</li>
<li>JVM GC算法有哪些，目前的JDK版本采用什么回收算法？</li>
<li>G1回收器讲下回收过程GC是什么？为什么要有GC？</li>
<li>GC的两种判定方法？CMS收集器与G1收集器的特点</li>
</ol>
<h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><ol>
<li>说一下GC算法，分代回收说下</li>
<li>垃圾收集策略和算法</li>
</ol>
<h3 id="天猫"><a href="#天猫" class="headerlink" title="天猫"></a>天猫</h3><ol>
<li>JVM GC原理，JVM怎么回收内存</li>
<li>CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li>
</ol>
<h3 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h3><ol>
<li>Java的垃圾回收器都有哪些，说下G1的应用场景，平时你是如何搭配使用垃圾回收器的</li>
</ol>
<h3 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h3><ol>
<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下CMS和G1，</li>
<li>包括原理，流程，优缺点。垃圾回收算法的实现原理</li>
</ol>
<h3 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h3><ol>
<li>讲一讲垃圾回收算法。</li>
<li>什么情况下触发垃圾回收？</li>
<li>如何选择合适的垃圾收集算法？</li>
<li>JVM有哪三种垃圾回收器？</li>
</ol>
<h3 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h3><ol>
<li>常见的垃圾回收器算法有哪些，各有什么优劣？</li>
<li>System.gc()和Runtime.gc()会做什么事情？</li>
<li>Java GC机制？GC Roots有哪些？</li>
<li>Java对象的回收方式，回收算法。</li>
<li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li>
<li>CMS回收停顿了几次，为什么要停顿两次?</li>
</ol>
<h2 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h2><ol>
<li>垃圾是指<strong>在运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</li>
<li>外文：An object is considered garbage when it can no longer be reached from any pointer in the running program.</li>
<li><strong>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</strong></li>
</ol>
<p><strong>十几年前磁盘碎片整理的日子</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0002.jpg">



<h2 id="为什么需要GC？"><a href="#为什么需要GC？" class="headerlink" title="为什么需要GC？"></a>为什么需要GC？</h2><p><strong>想要学习GC，首先需要理解为什么需要GC？</strong></p>
<ol>
<li><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p>
</li>
<li><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便JVM将整理出的内存分配给新的对象</strong>。</p>
</li>
<li><p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p>
</li>
</ol>
<h2 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h2><ol>
<li>在早期的C&#x2F;C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</li>
</ol>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MibBridge *pBridge= <span class="keyword">new</span> cmBaseGroupBridge（）；</span><br><span class="line"><span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span>（pBridge-&gt;Register（kDestroy）！=NO ERROR）</span><br><span class="line">	<span class="keyword">delete</span> pBridge；</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</p>
</li>
<li><p>有了垃圾回收机制后，上述代码极有可能变成这样</p>
</li>
</ol>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MibBridge *pBridge=<span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>(); </span><br><span class="line">pBridge-&gt;<span class="built_in">Register</span>(kDestroy);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准。</li>
</ol>
<h2 id="Java-垃圾回收机制"><a href="#Java-垃圾回收机制" class="headerlink" title="Java 垃圾回收机制"></a>Java 垃圾回收机制</h2><h3 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h3><blockquote>
<p><strong>官网介绍</strong>：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p>
</blockquote>
<p><strong>自动内存管理的优点</strong></p>
<ol>
<li><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</p>
</li>
<li><p>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</p>
</li>
<li><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</p>
</li>
</ol>
<p><strong>关于自动内存管理的担忧</strong></p>
<ol>
<li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力</strong>。</li>
<li>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</li>
<li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong>。</li>
</ol>
<h3 id="应该关心哪些区域的回收？"><a href="#应该关心哪些区域的回收？" class="headerlink" title="应该关心哪些区域的回收？"></a>应该关心哪些区域的回收？</h3><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0003.png">

<ol>
<li><p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收，</p>
</li>
<li><p>其中，<strong>Java堆是垃圾收集器的工作重点</strong></p>
</li>
<li><p>从次数上讲：</p>
<ol>
<li>频繁收集Young区</li>
<li>较少收集Old区</li>
<li>基本不收集Perm区（元空间）</li>
</ol>
</li>
</ol>
<h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><h2 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h2><h3 id="标记阶段的目的"><a href="#标记阶段的目的" class="headerlink" title="标记阶段的目的"></a>标记阶段的目的</h3><p><strong>垃圾标记阶段：主要是为了判断对象是否存活</strong></p>
<ol>
<li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。</strong>只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong>。</li>
<li>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</li>
<li>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</li>
</ol>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><ol>
<li>引用计数算法（Reference Counting）比较简单，<strong>对每个对象保存一个整型的引用计数器属性</strong>。用于记录对象被引用的情况。</li>
<li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</li>
<li>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li>
<li>缺点：<ol>
<li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li>
<li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li>
</ol>
</li>
</ol>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0004.png">

<p>当p的指针断开的时候，内部的引用形成一个循环，计数器都还算1，无法被回收，这就是循环引用，从而造成内存泄漏</p>
<h3 id="证明：java使用的不是引用计数算法"><a href="#证明：java使用的不是引用计数算法" class="headerlink" title="证明：java使用的不是引用计数算法"></a>证明：java使用的不是引用计数算法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * 证明：java使用的不是引用计数算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefCountGC</span> &#123;</span><br><span class="line">    <span class="comment">//这个成员属性唯一的作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//5MB</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line"></span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line"></span><br><span class="line">        obj1 = <span class="literal">null</span>;</span><br><span class="line">        obj2 = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//显式的执行垃圾回收行为</span></span><br><span class="line">        <span class="comment">//这里发生GC，obj1和obj2能否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0005.png">

<ul>
<li>如果不小心直接把<code>obj1.reference</code>和<code>obj2.reference</code>置为null。则在Java堆中的两块内存依然保持着互相引用，无法被回收</li>
</ul>
<p><strong>没有进行GC时</strong></p>
<p>把下面的几行代码注释掉，让它来不及</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.gc();<span class="comment">//把这行代码注释掉</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 38400K, used 14234K [0x00000000d5f80000, 0x00000000d8a00000, 0x0000000100000000)</span><br><span class="line">  eden space 33280K, 42% used [0x00000000d5f80000,0x00000000d6d66be8,0x00000000d8000000)</span><br><span class="line">  from space 5120K, 0% used [0x00000000d8500000,0x00000000d8500000,0x00000000d8a00000)</span><br><span class="line">  to   space 5120K, 0% used [0x00000000d8000000,0x00000000d8000000,0x00000000d8500000)</span><br><span class="line"> ParOldGen       total 87552K, used 0K [0x0000000081e00000, 0x0000000087380000, 0x00000000d5f80000)</span><br><span class="line">  object space 87552K, 0% used [0x0000000081e00000,0x0000000081e00000,0x0000000087380000)</span><br><span class="line"> Metaspace       used 3496K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 387K, capacity 390K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p><strong>进行GC</strong></p>
<p>打开那行代码的注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 13569K-&gt;808K(38400K)] 13569K-&gt;816K(125952K), <span class="number">0.0012717</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 808K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;670K(87552K)] 816K-&gt;670K(125952K), [Metaspace: 3491K-&gt;3491K(1056768K)], <span class="number">0.0051769</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 38400K, used 333K [<span class="number">0x00000000d5f80000</span>, <span class="number">0x00000000d8a00000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 33280K, <span class="number">1</span>% used [<span class="number">0x00000000d5f80000</span>,<span class="number">0x00000000d5fd34a8</span>,<span class="number">0x00000000d8000000</span>)</span><br><span class="line">  from space 5120K, <span class="number">0</span>% used [<span class="number">0x00000000d8000000</span>,<span class="number">0x00000000d8000000</span>,<span class="number">0x00000000d8500000</span>)</span><br><span class="line">  to   space 5120K, <span class="number">0</span>% used [<span class="number">0x00000000d8500000</span>,<span class="number">0x00000000d8500000</span>,<span class="number">0x00000000d8a00000</span>)</span><br><span class="line"> ParOldGen       total 87552K, used 670K [<span class="number">0x0000000081e00000</span>, <span class="number">0x0000000087380000</span>, <span class="number">0x00000000d5f80000</span>)</span><br><span class="line">  object space 87552K, <span class="number">0</span>% used [<span class="number">0x0000000081e00000</span>,<span class="number">0x0000000081ea7990</span>,<span class="number">0x0000000087380000</span>)</span><br><span class="line"> Metaspace       used 3498K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 387K, capacity 390K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>1、从打印日志就可以明显看出来，已经进行了GC</p>
<p>2、如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的<strong>Python</strong>，它更是<strong>同时支持引用计数和垃圾收集机制。</strong></li>
<li>具体哪种最优是要看场景的，业界有大规模实践中仅<strong>保留引用计数机制，以提高吞吐量的尝试。</strong></li>
<li>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是<strong>很难处理循环引用关系。</strong></li>
<li>Python如何解决循环引用？<ul>
<li>手动解除：很好理解，就是在合适的时机，解除引用关系。</li>
<li>使用<strong>弱引用</strong>weakref，weakref是Python提供的标准库，旨在解决循环引用。</li>
</ul>
</li>
</ol>
<h2 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h2><p><strong>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</strong></p>
<ol>
<li>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<strong>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</strong>。</li>
<li>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集</strong>（Tracing Garbage Collection）</li>
</ol>
<h3 id="可达性分析实现思路"><a href="#可达性分析实现思路" class="headerlink" title="可达性分析实现思路"></a>可达性分析实现思路</h3><ul>
<li><p>所谓**”GCRoots”根集合就是一组<code>必须活跃的引用</code>**</p>
</li>
<li><p>其基本思路如下：</p>
</li>
</ul>
<ol>
<li>可达性分析算法是以<strong>根对象集合（GCRoots）为起始点</strong>，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达。</strong></li>
<li>使用可达性分析算法后，内存中的存活对象都会被<strong>根对象集合直接或间接连接着</strong>，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain）</li>
<li>如果<strong>目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象</strong>。</li>
<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0006.png">

<h3 id="GC-Roots可以是哪些元素？"><a href="#GC-Roots可以是哪些元素？" class="headerlink" title="GC Roots可以是哪些元素？"></a>GC Roots可以是哪些元素？</h3><ol>
<li><strong>虚拟机栈中引用的对象</strong><ul>
<li>比如：<strong>各个线程被调用的方法中使用到的参数、局部变量等。</strong></li>
</ul>
</li>
<li><strong>本地方法栈内JNI（通常说的本地方法）引用的对象(native)</strong></li>
<li>方法区中<strong>类静态属性引用的对象</strong><ul>
<li>比如：Java类的引用<strong>类型静态变量</strong></li>
</ul>
</li>
<li>方法区中<strong>常量引用的对象</strong><ul>
<li>比如：<strong>字符串常量池（StringTable）里的引用</strong></li>
</ul>
</li>
<li>所有被同步锁<strong>synchronized持有的对象</strong></li>
<li>Java<strong>虚拟机内部的引用</strong>。<ul>
<li><strong>基本数据类型对应的Class对象</strong>，一些<strong>常驻的异常对象</strong>（如：NullPointerException、OutofMemoryError），系统类加载器。</li>
</ul>
</li>
<li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0007.png">



<ol>
<li>总结一句话就是，<strong>除了堆空间的周边，比如：虚拟机栈、本地方法栈、方法区、字符串常量池等地方对堆空间进行引用的，都可以作为<code>GC Roots</code>进行可达性分析</strong></li>
<li>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：<strong>分代收集</strong>和<strong>局部回收（PartialGC）</strong>。<ul>
<li><strong>如果只针对Java堆中的某一块区域进行垃圾回收</strong>（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li>
</ul>
</li>
</ol>
<p><strong>小技巧</strong></p>
<p>由于<strong>Root采用栈方式存放变量和指针</strong>，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>如果要使用可达性分析算法来判断内存是否可回收，那么<strong>分析工作必须在一个能保障一致性的快照中进行</strong>。这点不满足的话分析结果的准确性就无法保证。</li>
<li>这点也是导致<strong>GC进行时必须“Stop The World”</strong>的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</li>
</ol>
<h2 id="对象的-finalization-机制"><a href="#对象的-finalization-机制" class="headerlink" title="对象的 finalization 机制"></a>对象的 finalization 机制</h2><h3 id="finalize-方法机制"><a href="#finalize-方法机制" class="headerlink" title="finalize() 方法机制"></a>finalize() 方法机制</h3><p><strong>对象销毁前的回调函数：finalize()</strong></p>
<ol>
<li>Java语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</li>
<li>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</li>
<li>finalize() 方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</li>
</ol>
<p>Object 类中 finalize() 源码</p>
<pre><code>// 等待被重写
protected void finalize() throws Throwable &#123; &#125;
</code></pre>
<ol>
<li>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：<ol>
<li><strong>在finalize()时可能会导致对象复活。</strong></li>
<li>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</li>
<li>一个糟糕的finalize()会严重影响GC的性能。比如finalize是个死循环</li>
</ol>
</li>
<li>从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在<strong>本质上不同于C++中的析构函数</strong>。</li>
<li>finalize()方法对应了一个finalize线程，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li>
</ol>
<h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>由于finalize()方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态。</strong></p>
<ol>
<li>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它立即进行回收就是不合理的。为此，定义虚拟机中的对象可能的三种状态。如下：<ol>
<li>**<code>可触及的</code>**：从根节点开始，可以到达这个对象。</li>
<li>**<code>可复活的</code>**：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li>
<li><strong><code>不可触及的</code><strong>：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，</strong>因为finalize()只会被调用一次</strong>。</li>
</ol>
</li>
<li>以上3种状态中，<strong>是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</strong></li>
</ol>
<h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>判定一个对象objA是否可回收，<strong>至少要经历两次标记过程：</strong></p>
<ol>
<li>如果对象objA到GC Roots没有引用链，则进行第一次标记。</li>
<li>进行筛选，判断此对象是否有必要执行finalize()方法<ol>
<li>如果对象objA**没有重写finalize()<strong>方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为</strong><code>不可触及</code>**的。</li>
<li>如果对象objA重写了finalize()方法，<strong>且还未执行过，那么objA会被插入到F-Queue队列中</strong>，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</li>
<li>finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。<strong>如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。</strong>之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，<strong>对象会直接变成不可触及的状态</strong>，也就是说，一个对象的<strong>finalize()方法只会被调用一次。</strong></li>
</ol>
</li>
</ol>
<p><strong>通过 JVisual VM 查看 Finalizer 线程</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0008.png">



<h3 id="代码演示-finalize-方法可复活对象"><a href="#代码演示-finalize-方法可复活对象" class="headerlink" title="代码演示 finalize() 方法可复活对象"></a>代码演示 finalize() 方法可复活对象</h3><p>我们重写 CanReliveObj 类的 finalize()方法，在调用其 finalize()方法时，将 obj 指向当前类对象 this</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试Object类中finalize()方法，即对象的finalization机制。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanReliveObj</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj obj;<span class="comment">//类变量，属于 GC Root</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法只能被调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;<span class="comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = <span class="keyword">new</span> <span class="title class_">CanReliveObj</span>();</span><br><span class="line">            <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();<span class="comment">//调用垃圾回收器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第1次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第2次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>如果注释掉finalize()方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此方法只能被调用一次</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">       <span class="built_in">super</span>.finalize();</span><br><span class="line">       System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);</span><br><span class="line">       obj = <span class="built_in">this</span>;<span class="comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第<span class="number">1</span>次 gc</span><br><span class="line">obj is dead</span><br><span class="line">第<span class="number">2</span>次 gc</span><br><span class="line">obj is dead</span><br></pre></td></tr></table></figure>





<p><strong>放开finalize()方法</strong></p>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第<span class="number">1</span>次 gc</span><br><span class="line">调用当前类重写的finalize()方法</span><br><span class="line">obj is still alive</span><br><span class="line">第<span class="number">2</span>次 gc</span><br><span class="line">obj is dead</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一次自救成功，但由于 finalize() 方法只会执行一次，所以第二次自救失败</p>
<h2 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h2><h3 id="MAT-介绍"><a href="#MAT-介绍" class="headerlink" title="MAT 介绍"></a>MAT 介绍</h3><ol>
<li>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</li>
<li>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</li>
<li>大家可以在<a href="http://www.eclipse.org/mat/%E4%B8%8B%E8%BD%BD%E5%B9%B6%E4%BD%BF%E7%94%A8MAT">http://www.eclipse.org/mat/下载并使用MAT</a></li>
</ol>
<blockquote>
<p>1、虽然Jvisualvm很强大，但是在内存分析方面，还是MAT更好用一些</p>
<p>2、此小节主要是为了实时分析GC Roots是哪些东西，中间需要用到一个dump的文件</p>
</blockquote>
<h3 id="获取-dump-文件方式"><a href="#获取-dump-文件方式" class="headerlink" title="获取 dump 文件方式"></a>获取 dump 文件方式</h3><p><strong>方式一：命令行使用 jmap</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0009.png">



<p><strong>方式二：使用JVisualVM</strong></p>
<ol>
<li>捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获heap dump：</li>
<li>操作步骤下面演示</li>
</ol>
<h3 id="捕捉-dump-示例"><a href="#捕捉-dump-示例" class="headerlink" title="捕捉 dump 示例"></a>捕捉 dump 示例</h3><h4 id="使用JVisualVM捕捉-heap-dump"><a href="#使用JVisualVM捕捉-heap-dump" class="headerlink" title="使用JVisualVM捕捉 heap dump"></a>使用JVisualVM捕捉 heap dump</h4><p>代码：</p>
<ul>
<li>numList 和 birth 在第一次捕捉内存快照的时候，为 GC Roots</li>
<li>之后 numList 和 birth 置为 null ，对应的引用对象被回收，在第二次捕捉内存快照的时候，就不再是 GC Roots</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCRootsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            numList.add(String.valueOf(i));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;数据添加完毕，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">        numList = <span class="literal">null</span>;</span><br><span class="line">        birth = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;numList、birth已置空，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>如何捕捉堆内存快照</strong></p>
<p>1、先执行第一步，然后停下来，去生成此步骤dump文件</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0010.png">

<p>2、 点击【堆 Dump】</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0011.png">

<p>3、右键 –&gt; 另存为即可</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0012.jpg">

<p>4、输入命令，继续执行程序</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0013.png">

<p>5、我们接着捕获第二张堆内存快照</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0014.jpg">



<h4 id="使用-MAT-查看堆内存快照"><a href="#使用-MAT-查看堆内存快照" class="headerlink" title="使用 MAT 查看堆内存快照"></a>使用 MAT 查看堆内存快照</h4><p>1、打开 MAT ，选择File –&gt; Open File，打开刚刚的两个dump文件，<strong>我们先打开第一个dump文件</strong></p>
<blockquote>
<p>点击Open Heap Dump也行</p>
</blockquote>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0015.png">

<p>2、选择Java Basics –&gt; GC Roots</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0016.png">

<p>3、第一次捕捉堆内存快照时，GC Roots 中包含我们定义的两个局部变量，类型分别为 ArrayList 和 Date，Total:21</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0017.jpg">

<p>4、打开第二个dump文件，第二次捕获内存快照时，由于两个局部变量引用的对象被释放，所以这两个局部变量不再作为 GC Roots ，从 Total Entries &#x3D; 19 也可以看出（少了两个 GC Roots）</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0018.jpg">



<h3 id="JProfiler-GC-Roots-溯源"><a href="#JProfiler-GC-Roots-溯源" class="headerlink" title="JProfiler GC Roots 溯源"></a>JProfiler GC Roots 溯源</h3><p>1、在实际开发中，我们很少会查看所有的GC Roots。一般都是查看某一个或几个对象的GC Root是哪个，这个过程叫<strong>GC Roots 溯源</strong></p>
<p>2、下面我们使用使用 JProfiler 进行 GC Roots 溯源演示</p>
<p>依然用下面这个代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCRootsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            numList.add(String.valueOf(i));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;数据添加完毕，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">        numList = <span class="literal">null</span>;</span><br><span class="line">        birth = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;numList、birth已置空，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>1、</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0019.jpg">

<p>2、</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0020.png">

<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0021.jpg">

<p>可以发现颜色变绿了，可以动态的看变化</p>
<p>3、右击对象，选择 Show Selection In Heap Walker，单独的查看某个对象</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0022.png">



<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0023.png">



<p>4、选择Incoming References，表示追寻 GC Roots 的源头</p>
<p>点击Show Paths To GC Roots，在弹出界面中选择默认设置即可</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0024.jpg">

<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0025.png">



<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0026.png">

<h3 id="JProfiler-分析-OOM"><a href="#JProfiler-分析-OOM" class="headerlink" title="JProfiler 分析 OOM"></a>JProfiler 分析 OOM</h3><blockquote>
<p>这里是简单的讲一下，后面篇章会详解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms8m -Xmx8m </span></span><br><span class="line"><span class="comment"> * -XX:+HeapDumpOnOutOfMemoryError  这个参数的意思是当程序出现OOM的时候就会在当前工程目录生成一个dump文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//1MB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;HeapOOM&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">HeapOOM</span>());</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.atguigu.java.HeapOOM</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid14608.hprof ...</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.atguigu.java.HeapOOM.&lt;init&gt;(HeapOOM.java:<span class="number">12</span>)</span><br><span class="line">	at com.atguigu.java.HeapOOM.main(HeapOOM.java:<span class="number">20</span>)</span><br><span class="line">Heap dump file created [<span class="number">7797849</span> bytes in <span class="number">0.010</span> secs]</span><br><span class="line">count = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>打开这个dump文件</p>
<p>1、看这个超大对象</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0027.png">

<p>2、揪出 main() 线程中出问题的代码</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0028.png">



<h2 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h2><p><strong>垃圾清除阶段</strong></p>
<ul>
<li>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</li>
</ul>
<ol>
<li><strong>标记-清除算法（Mark-Sweep）</strong></li>
<li><strong>复制算法（Copying）</strong></li>
<li><strong>标记-压缩算法（Mark-Compact）</strong></li>
</ol>
<p><strong>背景</strong></p>
<p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p>
<p><strong>执行过程</strong></p>
<p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行<strong>两项工作，第一项则是标记，第二项则是清除</strong></p>
<ol>
<li>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。<ul>
<li>注意：标记的是被引用的对象，也就是可达对象，并非标记的是即将被清除的垃圾对象</li>
</ul>
</li>
<li>清除：Collector对堆内存<strong>从头到尾进行线性的遍历</strong>，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0029.png">



<p><strong>标记-清除算法的缺点</strong></p>
<ol>
<li>标记清除算法的效率不算高</li>
<li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li>
</ol>
<p><strong>注意：何为清除？</strong></p>
<p>这里所谓的<strong>清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是<code>覆盖原有的地址</code>）。</strong></p>
<p>关于空闲列表是在为对象分配内存的时候提过：</p>
<ol>
<li>如果内存规整<ul>
<li>采用指针碰撞的方式进行内存分配</li>
</ul>
</li>
<li>如果内存不规整<ul>
<li>虚拟机需要维护一个空闲列表</li>
<li>采用空闲列表分配内存</li>
</ul>
</li>
</ol>
<h2 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h2><p><strong>背景</strong></p>
<ol>
<li>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</li>
</ol>
<p><strong>核心思想</strong></p>
<p><strong>将活着的内存空间分为两块，每次只使用其中一块</strong>，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0030.png">

<p>新生代里面就用到了复制算法，<strong>Eden区和S0区存活对象整体复制到S1区</strong></p>
<p><strong>复制算法的优缺点</strong></p>
<p><strong>优点</strong></p>
<ol>
<li>没有标记和清除过程，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>
<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着<strong>GC需要维护region之间对象引用关系</strong>，不管是内存占用或者时间开销也不小</li>
</ol>
<p><strong>复制算法的应用场景</strong></p>
<ol>
<li><strong>如果系统中的<code>垃圾对象很多</code>，复制算法需要复制的存活对象数量并不会太大，效率较高</strong></li>
<li>老年代大量的对象存活，那么复制的对象将会有很多，效率会很低</li>
<li>在新生代，对常规应用的垃圾回收，<strong>一次通常可以回收70% - 99% 的内存空间。<code>回收性价比很高</code>。</strong>所以现在的商业虚拟机都是用这种收集算法回收新生代。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0031.png">



<h2 id="清除阶段：标记-压缩算法"><a href="#清除阶段：标记-压缩算法" class="headerlink" title="清除阶段：标记-压缩算法"></a>清除阶段：标记-压缩算法</h2><p><strong>标记-压缩（或标记-整理、Mark - Compact）算法</strong></p>
<p><strong>背景</strong></p>
<ol>
<li><p>复制算法的高效性是建立在**<code>存活对象少、垃圾对象多</code><strong>的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，</strong>基于老年代垃圾回收的特性，需要使用其他的算法。**</p>
</li>
<li><p>标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p>
</li>
<li><p>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p>
</li>
</ol>
<p><strong>执行过程</strong></p>
<ol>
<li><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p>
</li>
<li><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0032.png">



<p><strong>标记-压缩算法与标记-清除算法的比较</strong></p>
<ol>
<li><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p>
</li>
<li><p>二者的本质差异在于标记-清除算法是一种<strong>非移动式的回收算法</strong>，标记-压缩是<strong>移动式的</strong>。是否移动回收后的存活对象是一项优缺点并存的风险决策。</p>
</li>
<li><p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可**<code>(指针碰撞)</code>**，这比维护一个空闲列表显然少了许多开销。</p>
</li>
</ol>
<p><strong>标记-压缩算法的优缺点</strong></p>
<p><strong>优点</strong></p>
<ol>
<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中，内存减半的高额代价。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>从效率上来说，标记-整理算法要低于复制算法。</li>
<li><strong>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</strong>（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）</li>
<li>移动过程中，需要<strong>全程暂停用户应用程序。即：STW</strong></li>
</ol>
<h2 id="垃圾回收算法小结"><a href="#垃圾回收算法小结" class="headerlink" title="垃圾回收算法小结"></a>垃圾回收算法小结</h2><blockquote>
<p><strong>对比三种清除阶段的算法</strong></p>
</blockquote>
<ol>
<li><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p>
</li>
<li><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>标记清除</th>
<th>标记整理</th>
<th>复制</th>
</tr>
</thead>
<tbody><tr>
<td><strong>速率</strong></td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td><strong>空间开销</strong></td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的2倍空间（不堆积碎片）</td>
</tr>
<tr>
<td><strong>移动对象</strong></td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><blockquote>
<p>新生代老年代使用不同的回收算法</p>
</blockquote>
<p>Q：难道就没有一种最优的算法吗？</p>
<p>A：无，没有最好的算法，只有最合适的算法</p>
<p><strong>为什么要使用分代收集算法</strong></p>
<ol>
<li><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>
</li>
<li><p>分代收集算法，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</strong>一般是把Java堆分为新生代和老年代，这样就可以<strong>根据各个年代的特点使用不同的回收算法</strong>，以提高垃圾回收的效率。</p>
</li>
<li><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关:</p>
<ul>
<li>比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。</li>
<li>但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</li>
</ul>
</li>
</ol>
<p><strong>目前几乎所有的GC都采用分代收集算法执行垃圾回收的</strong></p>
<p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<ol>
<li><p>年轻代（Young Gen）</p>
<ul>
<li>年轻代特点：区域相对老年代较小，<strong>对象生命周期短、存活率低，回收频繁。</strong></li>
<li>这种情况**<code>复制算法</code>**的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</li>
</ul>
</li>
<li><p>老年代（Tenured Gen）</p>
<ul>
<li>老年代特点：区域较大，**&#96;对象生命周期长、存活率高，回收不及年轻代频繁。**</li>
<li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由**<code>标记-清除</code><strong>或者是</strong><code>标记-清除与标记-整理的混合实现</code>**。<ul>
<li><p>Mark阶段的开销与存活对象的数量成正比。</p>
</li>
<li><p>Sweep阶段的开销与所管理区域的大小成正相关。</p>
</li>
<li><p>Compact阶段的开销与存活对象的数据成正比。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p>
</li>
<li><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p>
</li>
</ol>
<h2 id="增量收集算法和分区算法"><a href="#增量收集算法和分区算法" class="headerlink" title="增量收集算法和分区算法"></a>增量收集算法和分区算法</h2><h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<strong>Stop the World</strong>状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p>
<p><strong>增量收集算法基本思想</strong></p>
<ol>
<li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让**<code>垃圾收集线程和应用程序线程交替执行</code><strong>。</strong>每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。**</li>
<li>总的来说，增量收集算法的**<code>基础仍是传统的标记-清除和复制算法</code><strong>。增量收集算法通过</strong>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作**</li>
</ol>
<p><strong>增量收集算法的缺点</strong></p>
<p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为**<code>线程切换和上下文转换的消耗，会使得垃圾回收的总体成本</code><strong>上升，</strong>造成系统吞吐量的下降**。</p>
<h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><blockquote>
<p>主要针对**<code>G1</code>**收集器来说的</p>
</blockquote>
<ol>
<li>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</li>
<li>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_010/0033.png">



<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>垃圾回收</title>
    <url>/2021/12/05/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC11%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h2 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc() 的理解"></a>System.gc() 的理解</h2><ol>
<li><p>在默认情况下，通过System.gc()者Runtime.getRuntime().gc() 的调用，<strong>会显式触发Full GC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
</li>
<li><p>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用(不能确保立即生效)</p>
</li>
<li><p>JVM实现者可以通过System.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，<strong>无须手动触发，否则就太过于麻烦了。</strong>在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</p>
</li>
</ol>
<p><strong>代码示例：手动执行 GC 操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemGCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemGCTest</span>();</span><br><span class="line">        System.gc();<span class="comment">//提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc</span></span><br><span class="line">        <span class="comment">//与Runtime.getRuntime().gc();的作用一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.runFinalization();//强制调用使用引用的对象的finalize()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果发生了GC，这个finalize()一定会被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;SystemGCTest 重写了finalize()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果不确定：有时候会调用 finalize() 方法，有时候并不会调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SystemGCTest 重写了finalize()</span><br><span class="line">或</span><br><span class="line">空</span><br></pre></td></tr></table></figure>





<h3 id="手动-GC-理解不可达对象的回收行为"><a href="#手动-GC-理解不可达对象的回收行为" class="headerlink" title="手动 GC 理解不可达对象的回收行为"></a>手动 GC 理解不可达对象的回收行为</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加上参数：  -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVarGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//10MB</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        buffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC3</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC4</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC5</span><span class="params">()</span> &#123;</span><br><span class="line">        localvarGC1();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalVarGC</span> <span class="variable">local</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVarGC</span>();</span><br><span class="line">        <span class="comment">//通过在main方法调用这几个方法进行测试</span></span><br><span class="line">        local.localvarGC1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JVM参数：</p>
<p><code>-Xms256m -Xmx256m -XX:+PrintGCDetails -XX:PretenureSizeThreshold=15m</code></p>
<p>1、第四个参数是设置大对象直接进入老年代的阈值，由于我的电脑8G和视频里老师的电脑16G不太一样。我测试的时候10M的数组都是直接进入到了老年代，为了保持一样的效果，我同时设置了堆内存和大对象阈值，尽量和宋红康老师保持一致</p>
<p>2、我也查过了大对象阈值的默认值</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_011/0001.png">

<p>我不太懂这个默认值为啥是0，我猜测可能是代表什么比例，目前也没有搜到相关的东西。这个不太重要，暂时就没有太深究，希望读者有知道的可以告知我一声。</p>
<blockquote>
<p>看不懂GC日志请看笔者的  <strong>堆</strong>那篇文章</p>
</blockquote>
<p><strong>1、调用 localvarGC1() 方法</strong></p>
<p>执行 System.gc() 仅仅是将年轻代的 buffer 数组对象放到了老年代，buffer对象仍然没有回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15492K-&gt;10728K(76288K)] 15492K-&gt;11000K(251392K), <span class="number">0.0066473</span> secs] [Times: user=<span class="number">0.08</span> sys=<span class="number">0.02</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 10728K-&gt;0K(76288K)] [ParOldGen: 272K-&gt;10911K(175104K)] 11000K-&gt;10911K(251392K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="number">0.0097940</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 655K [<span class="number">0x00000000fab00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">1</span>% used [<span class="number">0x00000000fab00000</span>,<span class="number">0x00000000faba3ee8</span>,<span class="number">0x00000000feb00000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x00000000feb00000</span>,<span class="number">0x00000000feb00000</span>,<span class="number">0x00000000ff580000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x00000000ff580000</span>,<span class="number">0x00000000ff580000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 10911K [<span class="number">0x00000000f0000000</span>, <span class="number">0x00000000fab00000</span>, <span class="number">0x00000000fab00000</span>)</span><br><span class="line">  object space 175104K, <span class="number">6</span>% used [<span class="number">0x00000000f0000000</span>,<span class="number">0x00000000f0aa7d08</span>,<span class="number">0x00000000fab00000</span>)</span><br><span class="line"> Metaspace       used 3498K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 387K, capacity 390K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>



<p><strong>2、调用 localvarGC2() 方法</strong></p>
<p>由于 buffer 数组对象没有引用指向它，执行 System.gc() 将被回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15492K-&gt;808K(76288K)] 15492K-&gt;816K(251392K), <span class="number">0.0294475</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.04</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 808K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;640K(175104K)] 816K-&gt;640K(251392K), [Metaspace: 3385K-&gt;3385K(1056768K)], <span class="number">0.0054210</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 1966K [<span class="number">0x00000000fab00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">3</span>% used [<span class="number">0x00000000fab00000</span>,<span class="number">0x00000000faceb9e0</span>,<span class="number">0x00000000feb00000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x00000000feb00000</span>,<span class="number">0x00000000feb00000</span>,<span class="number">0x00000000ff580000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x00000000ff580000</span>,<span class="number">0x00000000ff580000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 640K [<span class="number">0x00000000f0000000</span>, <span class="number">0x00000000fab00000</span>, <span class="number">0x00000000fab00000</span>)</span><br><span class="line">  object space 175104K, <span class="number">0</span>% used [<span class="number">0x00000000f0000000</span>,<span class="number">0x00000000f00a01a8</span>,<span class="number">0x00000000fab00000</span>)</span><br><span class="line"> Metaspace       used 3392K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 379K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>



<p><strong>3、调用 localvarGC3() 方法</strong></p>
<p>虽然出了代码块的作用域，但是 buffer 数组对象并没有被回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15492K-&gt;840K(76288K)] 15492K-&gt;11088K(251392K), <span class="number">0.0070281</span> secs] [Times: user=<span class="number">0.08</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 840K-&gt;0K(76288K)] [ParOldGen: 10248K-&gt;10900K(175104K)] 11088K-&gt;10900K(251392K), [Metaspace: 3386K-&gt;3386K(1056768K)], <span class="number">0.0084464</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 1966K [<span class="number">0x00000000fab00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">3</span>% used [<span class="number">0x00000000fab00000</span>,<span class="number">0x00000000faceb9e0</span>,<span class="number">0x00000000feb00000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x00000000feb00000</span>,<span class="number">0x00000000feb00000</span>,<span class="number">0x00000000ff580000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x00000000ff580000</span>,<span class="number">0x00000000ff580000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 10900K [<span class="number">0x00000000f0000000</span>, <span class="number">0x00000000fab00000</span>, <span class="number">0x00000000fab00000</span>)</span><br><span class="line">  object space 175104K, <span class="number">6</span>% used [<span class="number">0x00000000f0000000</span>,<span class="number">0x00000000f0aa52e8</span>,<span class="number">0x00000000fab00000</span>)</span><br><span class="line"> Metaspace       used 3393K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 379K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p><strong>原因：</strong></p>
<p>1、来看看字节码：实例方法局部变量表第一个变量肯定是 this</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_011/0002.png">

<p>2、你有没有看到，局部变量表的大小是 2。但是局部变量表里只有一个索引为0的啊？那索引为1的是哪个局部变量呢？实际上索引为1的位置是buffer在占用着，执行 System.gc() 时，栈中还有 buffer 变量指向堆中的字节数组，所以没有进行GC</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_011/0003.png">

<p>3、那么这种代码块的情况，什么时候会被GC呢？我们来看第四个方法</p>
<p><strong>4、调用 localvarGC4() 方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15492K-&gt;776K(76288K)] 15492K-&gt;784K(251392K), 0.0009430 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 776K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;646K(175104K)] 784K-&gt;646K(251392K), [Metaspace: 3485K-&gt;3485K(1056768K)], 0.0065829 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 1966K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 65536K, 3% used [0x00000000fab00000,0x00000000faceb9f8,0x00000000feb00000)</span><br><span class="line">  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)</span><br><span class="line">  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 175104K, used 646K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)</span><br><span class="line">  object space 175104K, 0% used [0x00000000f0000000,0x00000000f00a1b88,0x00000000fab00000)</span><br><span class="line"> Metaspace       used 3498K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 387K, capacity 390K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>Q：就多定义了一个局部变量 value ，就可以把字节数组回收了呢？</p>
<p>A：局部变量表长度为 2 ，这说明了出了代码块时，buffer 就出了其作用域范围，此时没有为 value 开启新的槽，value 变量直接占据了 buffer 变量的槽（Slot），导致堆中的字节数组没有引用再指向它，执行 System.gc() 时被回收。看，value 位于局部变量表中索引为 1 的位置。value这个局部变量把原本属于buffer的slot给占用了，这样栈上就没有buffer变量指向<code>new byte[10 * 1024 * 1024]</code>实例了。</p>
<blockquote>
<p>这点看不懂的可以看我前面的文章：虚拟机栈 –&gt; Slot的重复利用</p>
</blockquote>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_011/0004.png">



<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_011/0005.png">



<p><strong>调用 localvarGC5() 方法</strong></p>
<p>局部变量除了方法范围就是失效了，堆中的字节数组铁定被回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15492K-&gt;840K(76288K)] 15492K-&gt;11088K(251392K), <span class="number">0.0070281</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 840K-&gt;0K(76288K)] [ParOldGen: 10248K-&gt;10911K(175104K)] 11088K-&gt;10911K(251392K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="number">0.0082011</span> secs] [Times: user=<span class="number">0.03</span> sys=<span class="number">0.03</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] 10911K-&gt;10911K(251392K), <span class="number">0.0004440</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 0K-&gt;0K(76288K)] [ParOldGen: 10911K-&gt;671K(175104K)] 10911K-&gt;671K(251392K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="number">0.0108555</span> secs] [Times: user=<span class="number">0.08</span> sys=<span class="number">0.02</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 655K [<span class="number">0x00000000fab00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">1</span>% used [<span class="number">0x00000000fab00000</span>,<span class="number">0x00000000faba3ee8</span>,<span class="number">0x00000000feb00000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x00000000ff580000</span>,<span class="number">0x00000000ff580000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x00000000feb00000</span>,<span class="number">0x00000000feb00000</span>,<span class="number">0x00000000ff580000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 671K [<span class="number">0x00000000f0000000</span>, <span class="number">0x00000000fab00000</span>, <span class="number">0x00000000fab00000</span>)</span><br><span class="line">  object space 175104K, <span class="number">0</span>% used [<span class="number">0x00000000f0000000</span>,<span class="number">0x00000000f00a7cf8</span>,<span class="number">0x00000000fab00000</span>)</span><br><span class="line"> Metaspace       used 3499K, capacity 4502K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 387K, capacity 390K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>



<h2 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h2><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><ol>
<li>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</li>
<li>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。</li>
<li>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</li>
<li>Javadoc中对OutofMemoryError的解释是，**<code>没有空闲内存，并且垃圾收集器也无法提供更多内存。</code>**</li>
</ol>
<p><strong>内存溢出（OOM）原因分析</strong></p>
<p>首先说没有空闲内存的情况：说明Java虚拟机的<strong>堆内存</strong>不够。原因有二：</p>
<ol>
<li><p>Java虚拟机的堆内存设置不够。</p>
<ul>
<li>比如：**<code>可能存在内存泄漏问题</code><strong>；也很有可能就是</strong><code>堆的大小不合理</code>**，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。</li>
</ul>
</li>
<li><p>代码中**<code>创建了大量大对象</code>**，并且长时间不能被垃圾收集器收集（存在被引用）</p>
<ul>
<li>对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见。尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。</li>
<li>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。</li>
</ul>
</li>
<li><p>这里面隐含着一层意思是，<strong>在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</strong></p>
<ul>
<li>例如：在引用机制分析中，涉及到JVM会去尝试<strong>回收软引用指向的对象</strong>等。</li>
<li>在java.nio.Bits.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</li>
</ul>
</li>
<li><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p>
<ul>
<li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</li>
</ul>
</li>
</ol>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><blockquote>
<p>不用了，收又收不回来</p>
</blockquote>
<ol>
<li><p>也称作“存储渗漏”。严格来说，**<code>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</code>**</p>
</li>
<li><p>但实际情况很多时候一些不太好的实践（或疏忽）<strong>会导致对象的生命周期变得很长甚至导致OOM</strong>，也可以叫做宽泛意义上的“内存泄漏”。</p>
</li>
<li><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutofMemory异常，导致程序崩溃。</p>
</li>
<li><p>注意，<strong>这里的存储空间并不是指物理内存，而是指虚拟内存大小</strong>，这个虚拟内存大小取决于磁盘交换区设定的大小。</p>
</li>
</ol>
<p><strong>内存泄露官方例子</strong></p>
<p>左边的图：Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的对象。</p>
<p>右边的图：后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开（图示中的Forgotten Reference Memory Leak），从而导致没有办法被回收。</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_011/0006.png">





<p><strong>常见例子</strong></p>
<ol>
<li><strong><code>单例模式</code></strong><ul>
<li><strong>单例的生命周期和应用程序是一样长的</strong>（GC root 方法区中类静态属性引用的对象。 比如：Java类的引用类型静态变量），所以<strong>在单例程序中，如果持有对外部对象的引用</strong>的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</li>
</ul>
</li>
<li>一些提供**<code>close()的资源未关闭导致内存泄漏</code>**<ul>
<li>数据库连接 dataSourse.getConnection()，网络连接socket和io连接必须手动close，否则是不能被回收的。</li>
</ul>
</li>
</ol>
<h2 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop the World"></a>Stop the World</h2><ol>
<li><p>Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。<strong>停顿产生时整个应用程序线程都会被暂停，没有任何响应</strong>，有点像卡死的感觉，这个停顿称为STW。</p>
</li>
<li><p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿，为什么需要停顿所有 Java 执行线程呢？</p>
<ul>
<li><p>分析工作必须在一个能确保<strong>一致性的快照</strong>中进行</p>
</li>
<li><p>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</p>
</li>
<li><p><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></p>
</li>
</ul>
</li>
<li><p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</p>
</li>
<li><p>STW事件和采用哪款GC无关，所有的GC都有这个事件。</p>
</li>
<li><p>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
</li>
<li><p>STW是JVM在<strong>后台自动发起和自动完成</strong>的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>
</li>
<li><p>开发中不要用System.gc() ，这会导致Stop-the-World的发生。</p>
</li>
</ol>
<h3 id="代码感受-Stop-the-World"><a href="#代码感受-Stop-the-World" class="headerlink" title="代码感受 Stop the World"></a>代码感受 Stop the World</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopTheWorldDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">byte</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++)&#123;</span><br><span class="line">                        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        list.add(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(list.size() &gt; <span class="number">10000</span>)&#123;</span><br><span class="line">                        list.clear();</span><br><span class="line">                        System.gc();<span class="comment">//会触发full gc，进而会出现STW事件</span></span><br><span class="line">                     </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrintThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 每秒打印时间信息</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">                    System.out.println(t / <span class="number">1000</span> + <span class="string">&quot;.&quot;</span> + t % <span class="number">1000</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WorkThread</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkThread</span>();</span><br><span class="line">        <span class="type">PrintThread</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintThread</span>();</span><br><span class="line">        w.start();</span><br><span class="line">        p.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>关闭工作线程 w ，观察输出：当前时间间隔与上次时间间隔<strong>基本</strong>是每隔1秒打印一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span></span><br><span class="line"><span class="number">1.1</span></span><br><span class="line"><span class="number">2.2</span></span><br><span class="line"><span class="number">3.2</span></span><br><span class="line"><span class="number">4.3</span></span><br><span class="line"><span class="number">5.3</span></span><br><span class="line"><span class="number">6.3</span></span><br><span class="line"><span class="number">7.3</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>开启工作线程 w ，观察打印输出：当前时间间隔与上次时间间隔相差 1.3s ，可以明显感受到 Stop the World 的存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span></span><br><span class="line"><span class="number">1.4</span></span><br><span class="line"><span class="number">2.7</span></span><br><span class="line"><span class="number">3.8</span></span><br><span class="line"><span class="number">4.12</span></span><br><span class="line"><span class="number">5.13</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h3 id="并发的概念"><a href="#并发的概念" class="headerlink" title="并发的概念"></a>并发的概念</h3><ol>
<li><p>在操作系统中，是指<strong>一个时间段</strong>中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行</p>
</li>
<li><p>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换。由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_011/0007.png">



<h3 id="并行的概念"><a href="#并行的概念" class="headerlink" title="并行的概念"></a>并行的概念</h3><ol>
<li><p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以<strong>同时</strong>进行，我们称之为并行（Parallel）</p>
</li>
<li><p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行</p>
</li>
<li><p>适合科学计算，后台处理等弱交互场景</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_011/0008.png">

<blockquote>
<p><strong>并发与并行的对比</strong></p>
</blockquote>
<ol>
<li>并发，指的是多个事情，在同一时间段内同时发生了。</li>
<li>并行，指的是多个事情，在同一时间点上（或者说同一时刻）同时发生了。</li>
<li>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</li>
<li>只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</li>
</ol>
<h3 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h3><ol>
<li>并行（<strong>Parallel</strong>）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。<ul>
<li>如**<code>ParNew</code><strong>、</strong><code>Parallel Scavenge</code><strong>、</strong><code>Parallel Old</code>**</li>
</ul>
</li>
<li>串行（<strong>Serial</strong>）<ul>
<li>相较于并行的概念，单线程执行。</li>
<li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收（单线程）</li>
</ul>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_011/0009.png">



<p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<ol>
<li>并发（Concurrent）：指<strong>用户线程与垃圾收集线程同时执行</strong>（但不一定是并行的，可能会**<code>交替执行</code>**），垃圾回收线程在执行时不会停顿用户程序的运行。<ul>
<li>比如用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</li>
</ul>
</li>
<li>典型垃圾回收器：**<code>CMS、G1</code>**</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_011/0010.png">



<h2 id="HotSpot的算法实现细节"><a href="#HotSpot的算法实现细节" class="headerlink" title="HotSpot的算法实现细节"></a>HotSpot的算法实现细节</h2><h3 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h3><p>1、固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，尽管目标明确，但查找过程要做到高效并非一件容易的事情，现在Java应用越做越庞大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检查以这里为起源的引用肯定得消耗不少时间。 </p>
<p>2、迄今为止，<strong>所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的</strong>，因此毫无疑问根节点 枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。现在可达性分析算法耗时 最长的查找引用链的过程已经可以做到与用户线程一起并发，<strong>但根节点枚举始终还 是必须在一个能保障一致性的快照中才得以进行</strong>——这里“一致性”的意思是整个枚举期间执行子系统 看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化 的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有 用户线程的其中一个重要原因，即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、 ZGC等收集器，枚举根节点时也是必须要停顿的。</p>
<p>3、由于目前主流Java虚拟机使用的都是<strong>准确式垃圾收集</strong>，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有 执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot 的解决方案里，是使用一组称为<strong>OopMap的数据结构</strong>来达到这个目的。一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也 会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信 息了，<strong>并不需要真正一个不漏地从方法区等GC Roots开始查找</strong>。</p>
<p>4、Exact VM因它使用<strong>准确式内存管理</strong>（Exact Memory Management，也可以叫Non-Con- servative&#x2F;Accurate Memory Management）而得名。准确式内存管理是指虚拟机可以知道内存中某个位 置的数据具体是什么类型。譬如内存中有一个32bit的整数123456，虚拟机将有能力分辨出它到底是一 个指向了123456的内存地址的引用类型还是一个数值为123456的整数，准确分辨出哪些内存是引用类 型，这也是在垃圾收集时准确判断堆上的数据是否还可能被使用的前提。【<strong>这个不是特别重要，了解一下即可</strong>】</p>
<blockquote>
<p>常考面试：<strong>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举</strong></p>
</blockquote>
<h3 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h3><p><strong>安全点（Safepoint）</strong></p>
<blockquote>
<p><strong><code>执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</code></strong></p>
</blockquote>
<ol>
<li><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</p>
</li>
<li><p>Safe Point的选择很重要，<strong>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。比如：选择一些**<code>执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</code>**</p>
</li>
</ol>
<p><strong>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</strong></p>
<ol>
<li>抢先式中断：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li>
<li>主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候**<code>主动轮询</code>**这个标志，如果中断标志为真，则将自己进行中断挂起。</li>
</ol>
<p><strong>安全区域（Safe Region）</strong></p>
<ol>
<li>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？</li>
<li>例如线程处于Sleep状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</li>
<li><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</strong>。我们也可以把Safe Region看做是被扩展了的Safepoint。</li>
</ol>
<p><strong>安全区域的执行流程</strong></p>
<ol>
<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li>
<li>当线程即将离开Safe Region时，会检查JVM是否已经完成**<code>根节点枚举（即GC Roots的枚举）</code>**，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li>
</ol>
<h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><h4 id="什么是跨代引用？"><a href="#什么是跨代引用？" class="headerlink" title="什么是跨代引用？"></a>什么是跨代引用？</h4><p>1、一般的垃圾回收算法至少会划分出两个年代，年轻代和老年代。但是单纯的分代理论在垃圾回收的时候存在一个巨大的缺陷：**<code>为了找到年轻代中的存活对象，却不得不遍历整个老年代，反过来也是一样的。</code>**</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_011/0011.png">

<p>2、如果我们从年轻代开始遍历，那么可以断定N, S, P, Q都是存活对象。但是，V却不会被认为是存活对象，其占据的内存会被回收了。这就是一个惊天的大漏洞！因为U本身是老年代对象，而且有外部引用指向它，也就是说U是存活对象，而U指向了V，也就是说V也应该是存活对象才是！而这都是因为我们只遍历年轻代对象！</p>
<p>3、所以，为了解决这种跨代引用的问题，最笨的办法就是遍历老年代的对象，找出这些**<code>跨代引用</code>**来。这种方案存在极大的性能浪费。因为从两个分代假说里面，其实隐含了一个推论：跨代引用是极少的。也就是为了找出那么一点点跨代引用，我们却得遍历整个老年代！从上图来说，很显然的是，我们根本不必遍历R。</p>
<p>4、因此，为了避免这种遍历老年代的性能开销，通常的分代垃圾回收器会引入一种称为**<code>记忆集</code><strong>的技术。</strong>简单来说，记忆集就是用来<code>记录跨代</code>引用的表。**</p>
<h4 id="记忆集与卡表-1"><a href="#记忆集与卡表-1" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h4><p>1、为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建 立了名为<strong>记忆集（Remembered Set）的数据结构</strong>，用以避免把整个老年代加进GC Roots扫描范围。事实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集（Partial GC）行为的 垃圾收集器，典型的如G1、ZGC和Shenandoah收集器，都会面临相同的问题，因此我们有必要进一步 理清记忆集的原理和实现方式，以便在后续章节里介绍几款最新的收集器相关知识时能更好地理解。</p>
<p>2、记忆集是一种用于记录<strong>从非收集区域指向收集区域的指针集合的抽象数据结构</strong>。如果我们不考虑效率和成本的话，最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构。</p>
<blockquote>
<p>比如说我们有老年代（非收集区域）和年轻代（收集区域）的对象之间有一条引用链</p>
</blockquote>
<p>3、这种记录全部含跨代引用对象的实现方案，无论是空间占用还是维护成本都相当高昂。而在垃圾 收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针 就可以了，并不需要了解这些跨代指针的全部细节。那设计者在实现记忆集的时候，便可以选择更为 粗犷的记录粒度来节省记忆集的存储和维护成本，下面列举了一些可供选择（当然也可以选择这个范 围以外的）的记录精度：</p>
<ul>
<li>字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。 </li>
<li>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。 </li>
<li>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ul>
<p>4、其中，第三种“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集，这也是 目前最常用的一种记忆集实现形式，一些资料中甚至直接把它和记忆集混为一谈。前面定义中提到记忆集其实是一种“抽象”的数据结构，抽象的意思是只定义了记忆集的行为意图，并没有定义其行为的 具体实现。卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。 关于卡表与记忆集的关系，读者不妨按照Java语言中HashMap与Map的关系来类比理解。 卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这样做的</p>
<h2 id="再谈引用概述"><a href="#再谈引用概述" class="headerlink" title="再谈引用概述"></a>再谈引用概述</h2><ol>
<li><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p>
</li>
<li><p>既偏门又非常高频的面试题：强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</p>
</li>
<li><p>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：</p>
<ul>
<li>强引用（Strong Reference）</li>
<li>软引用（Soft Reference）</li>
<li>弱引用（Weak Reference）</li>
<li>虚引用（Phantom Reference）</li>
</ul>
</li>
<li><p>这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_011/0012.png" >



<p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p>
<ol>
<li><strong>强引用</strong>（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>object obj=new Object()</code>”这种引用关系。无论任何情况下，**<code>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。宁可报OOM，也不会GC强引用</code>**</li>
<li><strong>软引用</strong>（SoftReference）：在系统**<code>将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。</code>**如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li>
<li><strong>弱引用</strong>（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。**<code>当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</code>**</li>
<li><strong>虚引用</strong>（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，<strong>也无法通过虚引用来获得一个对象的实例</strong>。**<code>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</code>**</li>
</ol>
<h2 id="再谈引用：强引用"><a href="#再谈引用：强引用" class="headerlink" title="再谈引用：强引用"></a>再谈引用：强引用</h2><ol>
<li><p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，<strong>也是默认的引用类型</strong>。</p>
</li>
<li><p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>
</li>
<li><p><strong>只要强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong>只要强引用的对象是可达的，jvm宁可报OOM，也不会回收强引用。</p>
</li>
<li><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
</li>
<li><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，**<code>强引用是造成Java内存泄漏的主要原因之一。</code>**</p>
</li>
</ol>
<p><strong>强引用代码举例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrongReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span> (<span class="string">&quot;Hello,尚硅谷&quot;</span>);</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">str1</span> <span class="operator">=</span> str;</span><br><span class="line"></span><br><span class="line">        str = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello,尚硅谷</span><br></pre></td></tr></table></figure>



<p>局部变量str指向stringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是stringBuffer实例的强引用对应内存结构：</p>
<p><code>StringBuffer str = new StringBuffer(&quot;hello,尚硅谷&quot;);</code></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_011/0013.png">



<p><strong>总结</strong></p>
<p>本例中的两个引用，都是强引用，强引用具备以下特点：</p>
<ol>
<li>强引用可以直接访问目标对象。</li>
<li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li>
<li>强引用可能导致内存泄漏。</li>
</ol>
<h2 id="再谈引用：软引用"><a href="#再谈引用：软引用" class="headerlink" title="再谈引用：软引用"></a>再谈引用：软引用</h2><p><strong>软引用（Soft Reference）：内存不足即回收</strong></p>
<ol>
<li><p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。注意，这里的第一次回收是不可达的对象</p>
</li>
<li><p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
</li>
<li><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p>
</li>
<li><p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，**<code>迫不得已才清理。</code>**</p>
</li>
<li><p>一句话概括：**<code>当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</code>**</p>
</li>
</ol>
<p>在JDK1.2版之后提供了**<code>SoftReference</code>**类来实现软引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">// 声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>



<p><strong>软引用代码举例</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象，建立软引用</span></span><br><span class="line"><span class="comment">//        SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(new User(1, &quot;songhk&quot;));</span></span><br><span class="line">        <span class="comment">//上面的一行代码，等价于如下的三行代码</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;songhk&quot;</span>);</span><br><span class="line">        SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;User&gt;(u1);</span><br><span class="line">        u1 = <span class="literal">null</span>;<span class="comment">//取消强引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从软引用中重新获得强引用对象</span></span><br><span class="line">        System.out.println(userSoftRef.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---目前内存还不紧张---&quot;</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;After GC:&quot;</span>);</span><br><span class="line"><span class="comment">//        //垃圾回收之后获得软引用中的对象</span></span><br><span class="line">        System.out.println(userSoftRef.get());<span class="comment">//由于堆空间内存足够，所有不会回收软引用的可达对象。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---下面开始内存紧张了---&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//让系统认为内存资源紧张、不够</span></span><br><span class="line"><span class="comment">//            byte[] b = new byte[1024 * 1024 * 7];</span></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">7168</span> - <span class="number">635</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//再次从软引用中获取数据</span></span><br><span class="line">            System.out.println(userSoftRef.get());<span class="comment">//在报OOM之前，垃圾回收器会回收软引用的可达对象。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JVM参数</p>
<p><code>-Xms10m -Xmx10m</code></p>
<p>在 JVM 内存不足时，会清理软引用对象</p>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[id=<span class="number">1</span>, name=songhk] </span><br><span class="line">---目前内存还不紧张---</span><br><span class="line">After GC:</span><br><span class="line">[id=<span class="number">1</span>, name=songhk] </span><br><span class="line">---下面开始内存紧张了---</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.atguigu.java1.SoftReferenceTest.main(SoftReferenceTest.java:<span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="再谈引用：弱引用"><a href="#再谈引用：弱引用" class="headerlink" title="再谈引用：弱引用"></a>再谈引用：弱引用</h2><blockquote>
<p><strong>弱引用（Weak Reference）发现即回收</strong></p>
</blockquote>
<ol>
<li><p>弱引用也是用来描述那些非必需对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象</strong>。</p>
</li>
<li><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p>
</li>
<li><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
</li>
<li><p>软引用、弱引用都**<code>非常适合来保存那些可有可无的缓存数据</code>**。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
</li>
</ol>
<p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>

<p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p>
<p><strong>面试题：你开发中使用过WeakHashMap吗？</strong></p>
<p><strong>弱引用代码举例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构造了弱引用</span></span><br><span class="line">        WeakReference&lt;User&gt; userWeakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;User&gt;(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;songhk&quot;</span>));</span><br><span class="line">        <span class="comment">//从弱引用中重新获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 不管当前内存空间足够与否，都会回收它的内存</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After GC:&quot;</span>);</span><br><span class="line">        <span class="comment">//重新尝试从弱引用中获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>执行垃圾回收后，软引用对象必定被清除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[id=<span class="number">1</span>, name=songhk] </span><br><span class="line">After GC:</span><br><span class="line"><span class="literal">null</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h2 id="再谈引用：虚引用"><a href="#再谈引用：虚引用" class="headerlink" title="再谈引用：虚引用"></a>再谈引用：虚引用</h2><p><strong>虚引用（Phantom Reference）：<code>对象回收跟踪</code></strong></p>
<ol>
<li><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</p>
</li>
<li><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
</li>
<li><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null 。<strong>即通过虚引用无法获取到我们的数据</strong></p>
</li>
<li><p><strong><code>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</code></strong></p>
</li>
<li><p>**<code>虚引用必须和引用队列一起使用</code>**。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>
</li>
<li><p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p>
</li>
</ol>
<p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 声明引用队列</span></span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">phantomQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="comment">// 声明虚引用（还需要传入引用队列）</span></span><br><span class="line">PhantomReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure>



<p><strong>虚引用代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj;<span class="comment">//当前类对象的声明</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="literal">null</span>;<span class="comment">//引用队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="literal">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="literal">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; <span class="comment">//finalize()方法只能被调用一次！</span></span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类的finalize()方法&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckRefQueue</span>();</span><br><span class="line">        t.setDaemon(<span class="literal">true</span>);<span class="comment">//设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;PhantomReferenceTest&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">PhantomReferenceTest</span>();</span><br><span class="line">        <span class="comment">//构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;PhantomReferenceTest&gt;(obj, phantomQueue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//不可获取虚引用中的对象</span></span><br><span class="line">            System.out.println(phantomRef.get());</span><br><span class="line">			System.out.println(<span class="string">&quot;第 1 次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">//将强引用去除</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//第一次进行GC,由于对象可复活，GC无法回收该对象</span></span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第 2 次 gc&quot;</span>);</span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc(); <span class="comment">//一旦将obj对象回收，就会将此虚引用存放到引用队列中。</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>1、第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次GC，因为会调用finalize方法，将对象复活了，所以对象没有被回收</p>
<p>2、但是调用第二次GC操作的时候，因为finalize方法只能执行一次，所以就触发了GC操作，将对象回收了，同时将会触发第二个操作就是将待回收的对象存入到引用队列中。</p>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span></span><br><span class="line">第 <span class="number">1</span> 次 gc</span><br><span class="line">调用当前类的finalize()方法</span><br><span class="line">obj 可用</span><br><span class="line">第 <span class="number">2</span> 次 gc</span><br><span class="line">追踪垃圾回收过程：PhantomReferenceTest实例被GC了</span><br><span class="line">obj 是 <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h2 id="再谈引用：终结器引用（了解）"><a href="#再谈引用：终结器引用（了解）" class="headerlink" title="再谈引用：终结器引用（了解）"></a>再谈引用：终结器引用（了解）</h2><ol>
<li><p>它**<code>用于实现对象的finalize() 方法，也可以称为终结器引用</code>**</p>
</li>
<li><p><strong>无需手动编码</strong>，其内部配合引用队列使用</p>
</li>
<li><p><strong><code>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法</code><strong>，</strong>第二次</strong>GC时才回收被引用的对象</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/21/Hashmap1.8%E6%97%A7%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<hr>
<p>title: HashMap 1.8旧文档<br>date: 2020-12-16 18:14:27<br>categories:<br>    - JAVA源码</p>
<hr>
<h3 id="Java-集合框架-哈希表-HashMap"><a href="#Java-集合框架-哈希表-HashMap" class="headerlink" title="Java 集合框架 - 哈希表 HashMap"></a>Java 集合框架 - 哈希表 HashMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 底层存储的数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用 `#entrySet()` 方法后的缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key-value 的键值对数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap 的修改次数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阀值，当 &#123;<span class="doctag">@link</span> #size&#125; 超过 &#123;<span class="doctag">@link</span> #threshold&#125; 时，会进行扩容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容因子</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>重点看下 <code>table</code>、<code>size</code>、<code>threshold</code>、<code>loadFactor</code> 四个属性。 </p>
</li>
<li><p>具体的解释，我们在**[4. 构造方法]**中来看。这里我们先来看看 <code>table</code> Node 数组。代码如下 </p>
</li>
<li><pre><code class="java">// HashMap.java#Node.java

static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;

    /**
     * 哈希值
     */
    final int hash;
    /**
     * KEY 键
     */
    final K key;
    /**
     * VALUE 值
     */
    V value;
    /**
     * 下一个节点
     */
    Node&lt;K,V&gt; next;

    // ... 省略实现方法

&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-  实现了 Map.Entry 接口，该接口定义在 [`java.util.Map`](https://github.com/YunaiV/openjdk/blob/master/src/java.base/share/classes/java/util/Map.java) 接口中 </span><br><span class="line"></span><br><span class="line">- `hash` + `key` + `value` 属性，定义了 Node 节点的 3 个重要属性。</span><br><span class="line"></span><br><span class="line">- `next` 属性，指向下一个节点。通过它可以实现 `table` 数组的每一个位置可以形成链表。</span><br><span class="line"></span><br><span class="line">- Node 子类如下图： </span><br><span class="line">- ![1595729822373](images/1595729822373.png)</span><br><span class="line">-  TreeNode ，定义在 HashMap 中，红黑树节点。通过它可以实现 `table` 数组的每一个位置可以形成红黑树。</span><br><span class="line"></span><br><span class="line">#### 4.构造方法</span><br><span class="line"></span><br><span class="line">HashMap一共有4个构造方法</span><br><span class="line"></span><br><span class="line">-  **`#HashMap()`** 构造方法，创建一个初始值为16的HashMap对象，代码如下</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // HashMap.java</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 默认的初始化容量</span><br><span class="line">   *</span><br><span class="line">   * The default initial capacity - MUST be a power of two.</span><br><span class="line">   */</span><br><span class="line">  static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 默认加载因子为 0.75</span><br><span class="line">   *</span><br><span class="line">   * The load factor used when none specified in constructor.</span><br><span class="line">   */</span><br><span class="line">  static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * Constructs an empty &#123;@code HashMap&#125; with the default initial capacity</span><br><span class="line">   * (16) and the default load factor (0.75).</span><br><span class="line">   */</span><br><span class="line">  public HashMap() &#123;</span><br><span class="line">      this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>初始化 <code>loadFactor</code> 为 <code>DEFAULT_LOAD_FACTOR = 0.75</code> 。</p>
</li>
<li><p>在该构造方法上，并没有看到 <code>table</code> 数组的初始化。它是<strong>延迟</strong>初始化，在我们开始往 HashMap 中添加 key-value 键值对时，在 <code>#resize()</code> 方法中才真正初始化。</p>
</li>
<li><p><strong><code>#HashMap(int initialCapacity)</code></strong> 方法，初始化容量为<code>initialCapacity</code>的HashMap对象，代码如下：</p>
</li>
<li><pre><code class="java">// HashMap.java

public HashMap(int initialCapacity) &#123;
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-  内部调用 `#HashMap(int initialCapacity, float loadFactor)` 构造方法。 </span><br><span class="line"></span><br><span class="line">-  **`#HashMap(int initialCapacity, float loadFactor)`** 构造方法， 构造方法，初始化容量为 `initialCapacity` 、加载因子为 `loadFactor` 的 HashMap 对象。代码如下： </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // HashMap.java</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 最大的容量为2^30 。</span><br><span class="line">   *</span><br><span class="line">   * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="line">   * by either of the constructors with arguments.</span><br><span class="line">   * MUST be a power of two &lt;= 1&lt;&lt;30.</span><br><span class="line">   */</span><br><span class="line">  static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line">  </span><br><span class="line">  public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">      // 校验 initialCapacity 参数</span><br><span class="line">      if (initialCapacity &lt; 0)</span><br><span class="line">          throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      // 避免 initialCapacity 超过 MAXIMUM_CAPACITY</span><br><span class="line">      if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">          initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      // 校验 loadFactor 参数</span><br><span class="line">      if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">          throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">      // 设置 loadFactor 属性</span><br><span class="line">      this.loadFactor = loadFactor;</span><br><span class="line">      // &lt;X&gt; 计算 threshold 阀值</span><br><span class="line">      this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>点来看 <code>X</code> 处，调用 <code>#tableSizeFor(int cap)</code> 方法，返回大于 <code>cap</code> 的最小 2 的 N 次方。例如说，<code>cap = 10</code> 时返回 16 ，<code>cap = 28</code> 时返回 32 。代码如下 </p>
</li>
<li><pre><code class="java">// HashMap.java

static final int tableSizeFor(int cap) &#123;
    // 将 cap 从最高位（最左边）第一个为 1 开始的位开始，全部设置为 1 。
    int n = -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1);
    // 因为 n 已经是 0..01..1 的情况，那么 n + 1 就能满足 cap 的最小 2 的 N 次方
    // 在 cap 为 0 和 1 的时候，n 会为 -1 ，则此时最小 2 的 N 次方为 2^0 = 1 。
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
&#125;

// tableSizeFor的功能（不考虑大于最大容量的情况）是返回大于输入参数且最近的2的整数次幂的数。比如10，则返回16。
static final int tableSizeFor(int cap) &#123;
    // 将 cap 从最高位（最左边）第一个为 1 开始的位开始，全部设置为 1 。
    int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
&#125;

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 详解如下：</span><br><span class="line"></span><br><span class="line">  - 先来分析有关n位操作部分：先来假设n的二进制为01xxx...xxx。接着</span><br><span class="line">  - 对n右移1位：001xx...xxx，再位或：011xx...xxx</span><br><span class="line">  - 对n右移2为：00011...xxx，再位或：01111...xxx</span><br><span class="line">  - 此时前面已经有四个1了，再右移4位且位或可得8个1</span><br><span class="line">  - 同理，有8个1，右移8位肯定会让后八位也为1。</span><br><span class="line">  - 综上可得，该算法让最高位的1后面的位全变为1。</span><br><span class="line">  - 最后再让结果n+1，即得到了2的整数次幂的值了。</span><br><span class="line">  -  由于int是32位，所以&gt;&gt;&gt;16便能满足。 </span><br><span class="line"></span><br><span class="line">- ![](images/2489662-446566a23b9be33f.jpg)</span><br><span class="line"></span><br><span class="line">-  现在回来看看第一条语句： `int n = cap - 1;`</span><br><span class="line"></span><br><span class="line">- 让cap-1再赋值给n的目的是另找到的目标值大于或等于原值。例如二进制1000，十进制数值为8。如果不对它减1而直接操作，将得到答案10000，即16。显然不是结果。减1后二进制为111，再进行操作则会得到原来的数值1000，即8。</span><br><span class="line"></span><br><span class="line">- HashMap里的MAXIMUM_CAPACITY是2的30次方。结合tableSizeFor()的实现，猜测设置原因如下：</span><br><span class="line">   int的正数最大可达2的31-1次方，而没办法取到2的31次方。所以容量也无法达到2的31次方。又需要让容量满足2的幂次。所以设置为2的30次方</span><br><span class="line"></span><br><span class="line">-  那么，为什么这里的 `threshold` 要返回大于等于 `initialCapacity` 的最小 2 的 N 次方呢？ </span><br><span class="line"></span><br><span class="line">- &gt; 在 put 方法中，计算 `table` 数组对应的位置，逻辑是 `(n - 1) &amp; hash` ，这个和我们预想的 `hash % (n - 1)` 的有差别。这两者在 `n` 是 2 的 N 次方情况下是等价的。那么考虑到性能，我们会选择 `&amp;` 位操作。这样，就要求数组容量 `n` 要尽可能是 2 的 N 次方。</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 而在 `#resize()` 扩容方法中，我们会看到 HashMap 的容量，一直能够保证是 2 的 N 次方。</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 如此，`#tableSizeFor(int cap)` 方法，也需要保证返回的是 2 的 N 次方。</span><br><span class="line"></span><br><span class="line">-  **`HashMap(Map&lt;? extends K, ? extends V&gt; m)`**  构造方法， ，创建 HashMap 对象，并将 `c` 集合添加到其中。代码如下： </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // HashMap.java</span><br><span class="line">  </span><br><span class="line">  public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">      // 设置加载因子</span><br><span class="line">      this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">      // &lt;X&gt; 批量添加到 table 中</span><br><span class="line">      putMapEntries(m, false);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>X</code> 处，调用 <code>#putMapEntries(Map m, boolean evict)</code> 方法，批量添加到 <code>table</code> 中。代码如下 </p>
</li>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F; HashMap.java</p>
<p>final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {<br>int s &#x3D; m.size();<br>&#x2F;&#x2F; &lt;1&gt;<br>if (s &gt; 0) {<br>    &#x2F;&#x2F; 如果 table 为空，说明还没初始化，适合在构造方法的情况<br>    if (table &#x3D;&#x3D; null) { &#x2F;&#x2F; pre-size<br>        &#x2F;&#x2F; 根据 s 的大小 + loadFactor 负载因子，计算需要最小的 tables 大小<br>        float ft &#x3D; ((float)s &#x2F; loadFactor) + 1.0F; &#x2F;&#x2F; + 1.0F 的目的，是因为下面 (int) 直接取整，避免不够。<br>        int t &#x3D; ((ft &lt; (float)MAXIMUM_CAPACITY) ?<br>                 (int)ft : MAXIMUM_CAPACITY);<br>        &#x2F;&#x2F; 如果计算出来的 t 大于阀值，则计算新的阀值<br>        if (t &gt; threshold)<br>            threshold &#x3D; tableSizeFor(t);<br>    &#x2F;&#x2F; 如果 table 非空，说明已经初始化，需要不断扩容到阀值超过 s 的数量，避免扩容<br>    } else {<br>        &#x2F;&#x2F; Because of linked-list bucket constraints, we cannot<br>        &#x2F;&#x2F; expand all at once, but can reduce total resize<br>        &#x2F;&#x2F; effort by repeated doubling now vs later<br>        while (s &gt; threshold &amp;&amp; table.length &lt; MAXIMUM_CAPACITY)<br>            resize(); &#x2F;&#x2F; 扩容<br>    }<br><br>    &#x2F;&#x2F; &lt;2&gt; 遍历 m 集合，逐个添加到 HashMap 中。<br>    for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {<br>        K key &#x3D; e.getKey();<br>        V value &#x3D; e.getValue();<br>        putVal(hash(key), key, value, false, evict);<br>    }<br>}<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 整个过程分成 `&lt;1&gt;` 和 `&lt;2&gt;` 的两个步骤。</span><br><span class="line"></span><br><span class="line">- `&lt;1&gt;` 处，保证 `table` 容量足够，分成了 `table` 是否为空有不同的处理。可能比较疑惑的是，`table` 为空的情况的处理？因为此时 `table` 未初始化，我们只需要保证 `threshold` 大于数组大小即可，在 put key-value 键值的时候，在去真正的初始化 `table` 就好咧。</span><br><span class="line"></span><br><span class="line">- `&lt;2&gt;` 处，遍历 `m` 集合，逐个调用 `#putVal(hash, key, val, onlyIfAbsent, evict)` 方法，添加到 HashMap 中。关于这块的逻辑，我们本文的后面再来详细解析。</span><br><span class="line"></span><br><span class="line">#### 5. 哈希函数</span><br><span class="line"></span><br><span class="line">对于哈希函数来说，有两个方面特别重要：</span><br><span class="line"></span><br><span class="line">- 性能足够高。因为基本 HashMap 所有的操作，都需要用到哈希函数。</span><br><span class="line">- 对于计算出来的哈希值足够离散，保证哈希冲突的概率更小。</span><br><span class="line"></span><br><span class="line"> 在 HashMap 中，`#hash(Object key)` 静态方法，计算 key 的哈希值。代码如下 </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// HashMap.java</span><br><span class="line"></span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    // h = key.hashCode() 计算哈希值</span><br><span class="line">    // ^ (h &gt;&gt;&gt; 16) 高 16 位与自身进行异或计算，保证计算出来的 hash 更加离散</span><br><span class="line">   //如果只是hashCode的话，那么在进行路由算法的时候，当数组小的时候利用不到高16位，会产生很多高位的数都挤到一块去</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">    10100101 11000100 00100101 -&gt;hash码</span><br><span class="line">&amp;	00000000 00000000 00001111 -&gt; 数组长度-1 -&gt;这也是为什么数组长度是2幂的原因 -&gt; 末尾全1</span><br><span class="line">----------------------------------</span><br><span class="line">	00000000 00000000 00000101    //高位全部归零，只保留末四位</span><br></pre></td></tr></table></figure>

<ul>
<li>高效性：从整个计算过程上来说，<code>^ (h &gt;&gt;&gt; 16)</code> 只有这一块的逻辑，两个位操作，性能肯定是有保障的。那么，如果想要保证哈希函数的高效性，就需要传入的 <code>key</code> 自身的 <code>Object#hashCode()</code> 方法的高效即可。</li>
<li>离散型：和大多数胖友有一样的疑惑，为什么有 <code>^ (h &gt;&gt;&gt; 16)</code> 一段代码呢，总结来说，就是保证“hash 更加离散”。关于这块的解释，直接来看 <a href="https://www.zhihu.com/question/20733617/answer/111577937">《JDK 源码中 HashMap 的 hash 方法原理是什么？》</a> 的胖君的解答 ，好强！</li>
</ul>
<h4 id="6-添加单个元素"><a href="#6-添加单个元素" class="headerlink" title="6. 添加单个元素"></a>6. 添加单个元素</h4><ul>
<li><p><code>#put(K key, V value)</code> 方法，添加单个元素。代码如下 </p>
</li>
<li><p><code>tab[i = (n - 1) &amp; hash</code>路由算法-&gt;获得在数组中的位置(哪个桶)</p>
</li>
<li><pre><code class="java">// HashMap.java

public V put(K key, V value) &#123;
    // hash(key) 计算哈希值
    return putVal(hash(key), key, value, false, true);
&#125;

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) &#123;
    Node&lt;K,V&gt;[] tab; // tables 数组
    Node&lt;K,V&gt; p; // 对应位置的 Node 节点
    int n; // 数组大小
    int i; // 对应的 table 的位置
    // &lt;1&gt; 如果 table 未初始化，或者容量为 0 ，则进行扩容
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize() /*扩容*/ ).length;
    // &lt;2&gt; 如果对应位置的 Node 节点为空，则直接创建 Node 节点即可。
    if ((p = tab[i = (n - 1) &amp; hash] /*路由算法-&gt;获得对应下标位置首个的 Node 节点*/) == null)
        tab[i] = newNode(hash, key, value, null);
    // &lt;3&gt; 如果对应位置的 Node 节点非空，则可能存在哈希冲突
    else &#123;
        Node&lt;K,V&gt; e; // key 在 HashMap 对应的老节点
        K k;
        // &lt;3.1&gt; 如果找到的 p 节点，就是要找的，则则直接使用即可
        if (p.hash == hash &amp;&amp; // 判断 hash 值相等
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 判断 key 真正相等
            e = p;                                                            //-&gt;4.1
        // &lt;3.2&gt; 如果找到的 p 节点，是红黑树 Node 节点，则直接添加到树中
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);//-&gt;4.1
        // &lt;3.3&gt; 如果找到的 p 是 Node 节点，则说明是链表，需要遍历查找
        else &#123;
            // 顺序遍历链表
            for (int binCount = 0; ; ++binCount) &#123;
                // `(e = p.next)`：e 指向下一个节点，因为上面我们已经判断了最开始的 p 节点。
                // 如果已经遍历到链表的尾巴，则说明 key 在 HashMap 中不存在，则需要创建
                if ((e = p.next) == null) &#123;
                    // 创建新的 Node 节点
                    p.next = newNode(hash, key, value, null);
                    // 链表的长度如果数量达到 TREEIFY_THRESHOLD（8）时，则进行树化。
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break; // 结束
                &#125;
                // 如果遍历的 e 节点，就是要找的，则则直接使用即可 //-&gt;4.1
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break; // 结束
                // p 指向下一个节点
                p = e;
            &#125;
        &#125;
        // &lt;4.1&gt; 如果找到了对应的节点
        if (e != null) &#123; // existing mapping for key //有相同的key，已经经过了== hash equals重重判断，直接替换value
            V oldValue = e.value;
            // 修改节点的 value ，如果允许修改
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            // 节点被访问的回调
            afterNodeAccess(e);
            // 返回老的值
            return oldValue;
        &#125;
    &#125;
    // &lt;4.2&gt;
    // 增加修改次数
    ++modCount;
    // 如果超过阀值，则进行扩容
    if (++size &gt; threshold)
        resize();
    // 添加节点后的回调
    afterNodeInsertion(evict);
    // 返回 null
    return null;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-  `&lt;1&gt;` 处，如果 `table` 未初始化，或者容量为 0 ，则调用 `#resize()` 方法，进行扩容。 </span><br><span class="line"></span><br><span class="line">-  `&lt;2&gt;` 处，如果对应位置的 Node 节点为空，则直接创建 Node 节点即可。 </span><br><span class="line"></span><br><span class="line">  -  `i = (n - 1) &amp; hash` 代码段，计算 `table` 所在对应位置的下标。 此处，结合我们在 `#tableSizeFor(int cap)` 方法，在理解一波。 </span><br><span class="line"></span><br><span class="line">  -  调用 `#newNode(int hash, K key, V value, Node next)` 方法，创建 Node 节点即可。代码如下 </span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    // HashMap.java</span><br><span class="line">    </span><br><span class="line">    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        return new Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

-  这样，一个新的链表就出现了。当然，此处的 `next` 肯定是 `null`  
</code></pre>
</li>
<li><p><code>&lt;3&gt;</code> 处，如果对应位置的 Node 节点非空，则可能存在哈希冲突。需要分成 Node 节点是链表（<code>&lt;3.3&gt;</code>），还是红黑树（<code>&lt;3.2&gt;</code>）的情况。</p>
</li>
<li><p><code>&lt;3.1&gt;</code> 处，如果找到的 <code>p</code> 节点，就是要找的，则则直接使用即可。这是一个优化操作，无论 Node 节点是链表还是红黑树。</p>
</li>
<li><p><code>&lt;3.2&gt;</code> 处，如果找到的 <code>p</code> 节点，是红黑树 Node 节点，则调用 <code>TreeNode#putTreeVal(HashMap map, Node[] tab, int h, K k, V v)</code> 方法，直接添加到树中。这块，咱就先不深入了。</p>
</li>
<li><p><code>&lt;3.3&gt;</code> 处，如果找到的 <code>p</code> 是 Node 节点，则说明是链表，需要遍历查找。比较简单，胖友自己看下代码注释即可。其中，<code>binCount &gt;= TREEIFY_THRESHOLD - 1</code> 代码段，在链表的长度超过 <code>TREEIFY_THRESHOLD = 8</code> 的时候，会调用 <code>#treeifyBin(Node[] tab, int hash)</code> 方法，将链表进行树化。当然，树化还有一个条件，暂时没写！</p>
</li>
<li><p><code>&lt;4&gt;</code> 处，根据是否在 HashMap 中已经存在 key 对应的节点，有不同的处理。 </p>
</li>
<li><p><code>&lt;4.1&gt;</code> 处，如果存在的情况，会有如下处理 </p>
</li>
<li><p>1）如果满足需要修改节点，则进行修改。</p>
</li>
<li><p>2）如果节点被访问时，调用 <code>#afterNodeAccess((Node p)</code> 方法，节点被访问的回调。目前这是个一个空方法，用于 HashMap 的子类 LinkedHashMap 需要做的拓展逻辑。</p>
</li>
<li><p>3）返回老的值</p>
</li>
<li><p><code>&lt;4.2&gt;</code> 处，如果不存在的情况，会有如下处理： </p>
</li>
<li><p>1）增加修改次数。</p>
</li>
<li><p>2）增加 key-value 键值对 <code>size</code> 数。并且 <code>size</code> 如果超过阀值，则调用 <code>#resize()</code> 方法，进行扩容。</p>
</li>
<li><p>3）调用 <code>#afterNodeInsertion(boolean evict)</code> 方法，添加节点后的回调。目前这是个一个空方法，用于 HashMap 的子类 LinkedHashMap 需要做的拓展逻辑。</p>
</li>
<li><p>4）返回 <code>null</code> ，因为老值不存在。</p>
</li>
<li><p><code>#putIfAbsent(K key, V value)</code> 方法，当 <code>key</code> 不存在的时候，添加 key-value 键值对到其中。代码如下 </p>
</li>
<li><pre><code class="java">// HashMap.java

@Override
public V putIfAbsent(K key, V value) &#123;
    return putVal(hash(key), key, value, true, true);
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 7. 扩容</span><br><span class="line"></span><br><span class="line">-  `#resize()` 方法，**两倍扩容** HashMap 。实际上，我们在 **[4. 构造方法]** 中，看到 `table` 数组并未初始化，它是在 `#resize()` 方法中进行初始化，所以这是该方法的另外一个作用：**初始化数组**。代码如下： </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // HashMap.java</span><br><span class="line">  </span><br><span class="line">  final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">      int oldThr = threshold;</span><br><span class="line">      int newCap, newThr = 0;</span><br><span class="line">      // &lt;1&gt; 开始：</span><br><span class="line">      // &lt;1.1&gt; oldCap 大于 0 ，说明 table 非空</span><br><span class="line">      if (oldCap &gt; 0) &#123;</span><br><span class="line">          // &lt;1.1.1&gt; 超过最大容量，则直接设置 threshold 阀值为 Integer.MAX_VALUE ，不再允许扩容</span><br><span class="line">          if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              return oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">          // &lt;1.1.2&gt; newCap = oldCap &lt;&lt; 1 ，目的是两倍扩容</span><br><span class="line">          // 如果 oldCap &gt;= DEFAULT_INITIAL_CAPACITY 满足，说明当前容量大于默认值（16），则 2 倍阀值。</span><br><span class="line">          else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">      &#125;</span><br><span class="line">      // &lt;1.2.1&gt;【非默认构造方法】oldThr 大于 0 ，则使用 oldThr 作为新的容量</span><br><span class="line">      else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">          newCap = oldThr;</span><br><span class="line">      // &lt;1.2.2&gt;【默认构造方法】oldThr 等于 0 ，则使用 DEFAULT_INITIAL_CAPACITY 作为新的容量，使用 DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY 作为新的容量</span><br><span class="line">      else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">      // 1.3 如果上述的逻辑，未计算新的阀值，则使用 newCap * loadFactor 作为新的阀值</span><br><span class="line">  	//也就是newThr为0的时候newThr是下次扩容阈值，如果当前才有带参构造或者正常扩容，则不能用上面的默认扩容数据</span><br><span class="line">      if (newThr == 0) &#123;</span><br><span class="line">          float ft = (float)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (int)ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line">      // &lt;2&gt; 开始：</span><br><span class="line">      // 将 newThr 赋值给 threshold 属性</span><br><span class="line">      threshold = newThr;</span><br><span class="line">      // 创建新的 Node 数组，赋值给 table 属性</span><br><span class="line">      @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">      Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      // 如果老的 table 数组非空，则需要进行一波搬运</span><br><span class="line">      if (oldTab != null) &#123;</span><br><span class="line">          for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              // 获得老的 table 数组第 j 位置的 Node 节点 e</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                  // 置空老的 table 数组第 j 位置</span><br><span class="line">                  oldTab[j] = null;</span><br><span class="line">                  // &lt;2.1&gt; 如果 e 节点只有一个元素，直接赋值给新的 table 即可</span><br><span class="line">                  if (e.next == null)</span><br><span class="line">                      newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                  // &lt;2.2&gt; 如果 e 节点是红黑树节点，则通过红黑树分裂处理</span><br><span class="line">                  else if (e instanceof TreeNode)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                  // &lt;2.3&gt; 如果 e 节点是链表</span><br><span class="line">                  else &#123; // preserve order</span><br><span class="line">                      // HashMap 是成倍扩容，这样原来位置的链表的节点们，会被分散到新的 table 的两个位置中去</span><br><span class="line">                      // 通过 e.hash &amp; oldCap 计算，根据结果分到高位、和低位的位置中。</span><br><span class="line">                      // 1. 如果结果为 0 时，则放置到低位</span><br><span class="line">                      // 2. 如果结果非 1 时，则放置到高位</span><br><span class="line">                      Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                      Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                      Node&lt;K,V&gt; next;</span><br><span class="line">                      // 这里 do while 的原因是，e 已经非空，所以减少一次判断。细节~</span><br><span class="line">                      do &#123;</span><br><span class="line">                          // next 指向下一个节点</span><br><span class="line">                          next = e.next;</span><br><span class="line">                          // 满足低位</span><br><span class="line">                          if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                              if (loTail == null)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              else</span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          // 满足高位</span><br><span class="line">                          else &#123;</span><br><span class="line">                              if (hiTail == null)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              else</span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; while ((e = next) != null);</span><br><span class="line">                      // 设置低位到新的 newTab 的 j 位置上</span><br><span class="line">                      if (loTail != null) &#123;</span><br><span class="line">                          //这一步是因为loTail(地位链表最后一位)的next可能是下一位hiTail,将其next置空</span><br><span class="line">                          loTail.next = null;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                      // 设置高位到新的 newTab 的 j + oldCap 位置上</span><br><span class="line">                      if (hiTail != null) &#123;</span><br><span class="line">                          hiTail.next = null;//同理</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>不要怕，仅仅是代码长了点，逻辑很明确，就两步：1）计算新的容量和扩容阀值，并创建新的 <code>table</code> 数组；2）将老的 <code>table</code> 复制到新的 <code>table</code> 数组中。</p>
</li>
</ul>
<p>下面开始，我们进入【第一步】。</p>
<ul>
<li><code>&lt;1.1&gt;</code> 处，<code>oldCap</code> 大于 0 ，说明 <code>table</code> 非空，说明是<strong>两倍扩容</strong>的骚操作 </li>
<li><code>&lt;1.1.1&gt;</code> 处，超过最大容量，则直接设置 <code>threshold</code> 阀值为 <code>Integer.MAX_VALUE</code> ，不再允许扩容。</li>
<li>【重要】<code>&lt;1.1.2&gt;</code> 处，<strong>两倍扩容</strong>，这个暗搓搓的 <code>newCap = oldCap &lt;&lt; 1)</code> 代码段， 差点就看漏了。因为容量是两倍扩容，那么再 <code>newCap * loadFactor</code> 逻辑，相比直接 <code>oldThr &lt;&lt; 1</code> 慢，所以直接使用 <code>oldThr &lt;&lt; 1</code> 位运算的方案。</li>
<li><code>&lt;1.2.1&gt;</code> 和 <code>&lt;1.2.2&gt;</code> 处，<code>oldCap</code> 等于 0 ，说明 <code>table</code> 为空，说明是<strong>初始化</strong>的骚操作。 </li>
<li><code>&lt;1.2.1&gt;</code> 处，<code>oldThr</code> 大于 0 ，说明使用的是【非默认构造方法】，则使用 <code>oldThr</code> 作为新的容量。这里，我们结合 <code>#tableSizeFor(int cap)</code> 方法，发现 HashMap 容量一定会是 2 的 N 次方。</li>
<li><code>&lt;1.2.2&gt;</code> 处，<code>oldThr</code> 等于 0 ，说明使用的是【默认构造方法】，则使用 <code>DEFAULT_INITIAL_CAPACITY</code> 作为新的容量，然后计算新的 <code>newThr</code> 阀值</li>
<li><code>&lt;1.3&gt;</code> 处，如果上述的逻辑，未计算新的阀值，则使用 <code>newCap * loadFactor</code> 作为新的阀值。满足该情况的，有 <code>&lt;1.2.1&gt;</code> 和 <code>&lt;1.1.1&gt;</code> 的部分情况（自己看下那个判断条件）。</li>
</ul>
<p> 下面开始，我们进入【第二步】 </p>
<ul>
<li>一共分成 <code>&lt;2.1&gt;</code>、<code>&lt;2.2&gt;</code>、<code>&lt;2.3&gt;</code> 的三种情况。 相信看懂了 <code>#put(K key, V value)</code> 也是分成三种情况，就很容易明白是为什么了。 </li>
<li><code>&lt;2.1&gt;</code> 处，如果 <code>e</code> 节点只有一个元素，直接赋值给新的 <code>table</code> 即可。这是一个优化操作，无论 Node 节点是链表还是红黑树。</li>
<li><code>&lt;2.2&gt;</code> 处，如果 <code>e</code> 节点是红黑树节点，则通过红黑树分裂处理。</li>
<li><code>&lt;2.3&gt;</code> 处，如果 <code>e</code> 节点是链表，以为 HashMap 是成倍扩容，这样原来位置的链表的节点们，会被分散到新的 <code>table</code> 的两个位置中去。可能这里对于不熟悉位操作的胖友有点难理解，我们来一步一步看看<ul>
<li>1）我们在选择 <code>hash &amp; (cap - 1)</code> 方式，来获得到在 <code>table</code> 的位置。那么经过计算，<code>hash</code> 在 <code>cap</code> 最高位（最左边）的 <strong>1</strong> 自然就被抹去了。例如说，<code>11 &amp; (4 - 1) = &#123;1011 &amp; 011&#125; = &#123;11&#125; = 3</code> ，而 <code>15 &amp; (4 - 1) = &#123;1111 &amp; 011&#125; = &#123;11&#125;= 3</code> 。相当于 <code>15</code> 的 <code>1[1]11</code> 的 <code>[1]</code> 被<strong>抹去</strong>了。</li>
<li>2）HashMap 成倍扩容之后，我们在来看看示例。<code>11 &amp; (7 - 1) = &#123;1011 &amp; 0111&#125; = &#123;11&#125; = 3</code> ，而 <code>15 &amp; (8 - 1) = &#123;1111 &amp; 0111&#125; = &#123;111&#125;= 7</code> 。相当于 <code>15</code> 的 <code>1[1]11</code> 的 <code>[1]</code> 被<strong>保留</strong>了。</li>
<li>3）那么怎么判断这 <code>[1]</code> 是否能够在扩容的时候被保留呢，那就使用 <code>hash &amp; oldCap</code> 是否等于 1 即可得到。既然 <code>[1]</code> 被保留下来，那么其位置就会 <code>j + oldCap</code> ，因为 <code>[1]</code> 的<strong>价值</strong>就是 <code>+ oldCap</code> 。</li>
</ul>
</li>
</ul>
<h4 id="8-树化"><a href="#8-树化" class="headerlink" title="8. 树化"></a>8. 树化</h4><ul>
<li><p><code>#treeifyBin(Node[] tab, int hash)</code> 方法，将 <code>hash</code> 对应 <code>table</code> 位置的链表，转换成红黑树。代码如下： </p>
</li>
<li><pre><code class="java">// HashMap.java

/**
 * 每个位置链表树化成红黑树，需要的链表最小长度
 *
 * The bin count threshold for using a tree rather than list for a
 * bin.  Bins are converted to trees when adding an element to a
 * bin with at least this many nodes. The value must be greater
 * than 2 and should be at least 8 to mesh with assumptions in
 * tree removal about conversion back to plain bins upon
 * shrinkage.
 */
static final int TREEIFY_THRESHOLD = 8;

/**
 * HashMap 允许树化最小 key-value 键值对数
 *
 * The smallest table capacity for which bins may be treeified.
 * (Otherwise the table is resized if too many nodes in a bin.)
 * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts
 * between resizing and treeification thresholds.
 */
static final int MIN_TREEIFY_CAPACITY = 64;

final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;
    int n, index; Node&lt;K,V&gt; e;
    // &lt;1&gt; 如果 table 容量小于 MIN_TREEIFY_CAPACITY(64) ，则选择扩容
    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
        resize();
    // &lt;2&gt; 将 hash 对应位置进行树化
    else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;
        // 顺序遍历链表，逐个转换成 TreeNode 节点
        TreeNode&lt;K,V&gt; hd = null, tl = null;
        do &#123;
            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else &#123;
                p.prev = tl;
                tl.next = p;
            &#125;
            tl = p;
        &#125; while ((e = e.next) != null);
        // 树化
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-  在 **[6. 添加单个元素]** 中，我们已经看到，每个位置的链表想要树化成红黑树，想要链表长度大于等于 `TREEIFY_THRESHOLD = 8` 。那么可能胖友会疑惑，为什么是 8 呢？我们可以在 HashMap 代码上搜 `Implementation notes.` ，其中部分内容就解释了它。 </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // HashMap.java</span><br><span class="line">  </span><br><span class="line">   * Because TreeNodes are about twice the size of regular nodes, we</span><br><span class="line">   * use them only when bins contain enough nodes to warrant use</span><br><span class="line">   * (see TREEIFY_THRESHOLD). And when they become too small (due to</span><br><span class="line">   * removal or resizing) they are converted back to plain bins.  In</span><br><span class="line">   * usages with well-distributed user hashCodes, tree bins are</span><br><span class="line">   * rarely used.  Ideally, under random hashCodes, the frequency of</span><br><span class="line">   * nodes in bins follows a Poisson distribution</span><br><span class="line">   * (http://en.wikipedia.org/wiki/Poisson_distribution) with a</span><br><span class="line">   * parameter of about 0.5 on average for the default resizing</span><br><span class="line">   * threshold of 0.75, although with a large variance because of</span><br><span class="line">   * resizing granularity. Ignoring variance, the expected</span><br><span class="line">   * occurrences of list size k are (exp(-0.5) * pow(0.5, k) /</span><br><span class="line">   * factorial(k)). The first values are:</span><br><span class="line">   *</span><br><span class="line">   * 0:    0.60653066</span><br><span class="line">   * 1:    0.30326533</span><br><span class="line">   * 2:    0.07581633</span><br><span class="line">   * 3:    0.01263606</span><br><span class="line">   * 4:    0.00157952</span><br><span class="line">   * 5:    0.00015795</span><br><span class="line">   * 6:    0.00001316</span><br><span class="line">   * 7:    0.00000094</span><br><span class="line">   * 8:    0.00000006</span><br><span class="line">   * more: less than 1 in ten million</span><br></pre></td></tr></table></figure>

- 首先，参考 [泊松概率函数(Poisson distribution)](http://en.wikipedia.org/wiki/Poisson_distribution) ，当链表长度到达 8 的概率是 0.00000006 ，不到千万分之一。所以绝大多数情况下，在 hash 算法正常的时，不太会出现链表转红黑树的情况。
- 其次，TreeNode 相比普通的 Node 来说，会有**两倍**的空间占用。并且在长度比较小的情况下，红黑树的查找性能和链表是差别不大的。例如说，红黑树的 `O(logN) = log8 = 3` 和链表的 `O(N) = 8` 只相差 5 
- 毕竟 HashMap 是 JDK 提供的基础数据结构，必须在空间和时间做抉择。所以，选择链表是空间复杂度优先，选择红黑树是时间复杂度优化。在绝大多数情况下，不会出现需要红黑树的情况。
</code></pre>
</li>
<li><p><code>&lt;1&gt;</code> 处，如果 <code>table</code> 容量小于 <code>MIN_TREEIFY_CAPACITY = 64</code> 时，则调用 <code>#resize()</code> 方法，进行扩容。一般情况下，该链表可以分裂到两个位置上。当然，极端情况下，解决不了，这时候一般是 hash 算法有问题。</p>
</li>
<li><p><code>&lt;2&gt;</code> 处，如果 <code>table</code> 容量大于等于 <code>MIN_TREEIFY_CAPACITY = 64</code> 时，则将 <code>hash</code> 对应位置进行树化。一共有两步，因为和红黑树相关，这里就不拓展开了。</p>
</li>
<li><p>有树化，必然有取消树化。当 HashMap 因为移除 key 时，导致对应 <code>table</code> 位置的红黑树的内部节点数小于等于 <code>UNTREEIFY_THRESHOLD = 6</code> 时，则将红黑树退化成链表。具体在 <code>HashMap.TreeNode#untreeify(HashMap map)</code> 中实现，整列就不拓展开了。代码如下： </p>
</li>
<li><pre><code class="java">// HashMap.java

/**
 * The bin count threshold for untreeifying a (split) bin during a
 * resize operation. Should be less than TREEIFY_THRESHOLD, and at
 * most 6 to mesh with shrinkage detection under removal.
 */
static final int UNTREEIFY_THRESHOLD = 6;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-  暂时没有想明白为什么使用 6 作为取消树化的阀值。暂时的想法，避免后续移除 key 时，红黑树如果内部节点数小于 7 就退化成链表，这样可能导致过于频繁的树化和取消树化。 </span><br><span class="line"></span><br><span class="line">#### 9. 添加多个元素</span><br><span class="line"></span><br><span class="line">- `#putAll(Map m)` 方法，添加多个元素到 HashMap 中。代码如下： </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // HashMap.java</span><br><span class="line">  </span><br><span class="line">  public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">      putMapEntries(m, true);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>和 <code>#HashMap(Map m)</code> 构造方法一样，都调用 <code>#putMapEntries(Map m, boolean evict)</code> 方法。</p>
</li>
</ul>
<h4 id="10-移除多个元素"><a href="#10-移除多个元素" class="headerlink" title="10.移除多个元素"></a>10.移除多个元素</h4><ul>
<li><p><code>#remove(Object key)</code> 方法，移除 key 对应的 value ，并返回该 value 。代码如下： </p>
</li>
<li><pre><code class="java">// HashMap.java

public V remove(Object key) &#123;
    Node&lt;K,V&gt; e;
    // hash(key) 求哈希值
    return (e = removeNode(hash(key), key, null, false, true)) == null ?
        null : e.value;
&#125;

final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) &#123;
    Node&lt;K,V&gt;[] tab; // table 数组
    Node&lt;K,V&gt; p; // hash 对应 table 位置的 p 节点
    int n, index;
    // &lt;1&gt; 查找 hash 对应 table 位置的 p 节点
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (p = tab[index = (n - 1) &amp; hash]) != null) &#123;
        Node&lt;K,V&gt; node = null, // 如果找到 key 对应的节点，则赋值给 node
                e;
        K k; V v;
        // &lt;1.1&gt; 如果找到的 p 节点，就是要找的，则则直接使用即可
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            node = p;
        else if ((e = p.next) != null) &#123;
            // &lt;1.2&gt; 如果找到的 p 节点，是红黑树 Node 节点，则直接在红黑树中查找
            if (p instanceof TreeNode)
                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
            // &lt;1.3&gt; 如果找到的 p 是 Node 节点，则说明是链表，需要遍历查找
            else &#123;
                do &#123;
                    // 如果遍历的 e 节点，就是要找的，则则直接使用即可
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key ||
                         (key != null &amp;&amp; key.equals(k)))) &#123;
                        node = e;
                        break; // 结束
                    &#125;
                    p = e; // 注意，这里 p 会保存找到节点的前一个节点
                &#125; while ((e = e.next) != null);
            &#125;
        &#125;
        // &lt;2&gt; 如果找到 node 节点，则进行移除
        // 如果有要求匹配 value 的条件，这里会进行一次判断先移除
        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                             (value != null &amp;&amp; value.equals(v)))) &#123;
            // &lt;2.1&gt; 如果找到的 node 节点，是红黑树 Node 节点，则直接在红黑树中删除
            if (node instanceof TreeNode)
                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
            // &lt;2.2.1&gt; 如果查找到的是链表的头节点，则直接将 table 对应位置指向 node 的下一个节点，实现删除
            else if (node == p)
                tab[index] = node.next;
            // &lt;2.2.2&gt; 如果查找到的是链表的中间节点，则将 p 指向 node 的下一个节点，实现删除
            else
                p.next = node.next;
            // 增加修改次数
            ++modCount;
            // 减少 HashMap 数量
            --size;
            // 移除 Node 后的回调
            afterNodeRemoval(node);
            // 返回 node
            return node;
        &#125;
    &#125;
    // 查找不到，则返回 null
    return null;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-  在 HashMap 中，移除 和添加 key-value 键值对，整个流程是比较接近的。一共分成两步： </span><br><span class="line"></span><br><span class="line">  - `&lt;1&gt;` 处，查找到 key 对应的 Node 节点。</span><br><span class="line">  - `&lt;2&gt;` 处，将查找到的 Node 节点进行移除。</span><br><span class="line"></span><br><span class="line">-  整体逻辑比较简单，这里就不哔哔，胖友可以顺着 </span><br><span class="line"></span><br><span class="line">  - 第一步，`&lt;1.1&gt;`、`&lt;1.2&gt;`、`&lt;1.3&gt;` 三种情况。</span><br><span class="line">  - 第二步，`&lt;2.1&gt;`、`&lt;2.2.1&gt; + &lt;2.2.2&gt;` 两种情况。</span><br><span class="line"></span><br><span class="line">-  `#remove(Object key, Object value)` 方法，移除指定 key-value 的键值对。代码如下 </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // HashMap.java</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public boolean remove(Object key, Object value) &#123;</span><br><span class="line">      return removeNode(hash(key), key, value, true, true) != null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>也是基于 <code>#removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)</code> 方法来实现的，差别在于传入了 <code>value</code> 和 <code>matchValue = true</code> 参数。 </p>
</li>
<li><p>HashMap 暂时不提供批量移除多个元素的方法</p>
</li>
</ul>
<h4 id="11-查找单个元素"><a href="#11-查找单个元素" class="headerlink" title="11. 查找单个元素"></a>11. 查找单个元素</h4><ul>
<li><p><code>#get(Object key)</code> 方法，查找单个元素。代码如下 </p>
</li>
<li><pre><code class="java">// HashMap.java

public V get(Object key) &#123;
    Node&lt;K,V&gt; e;
    // hash(key) 哈希值
    return (e = getNode(hash(key), key)) == null ? null : e.value;
&#125;

final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    // 查找 hash 对应 table 位置的 p 节点
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) &#123;
        // 如果找到的 first 节点，就是要找的，则则直接使用即可
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        if ((e = first.next) != null) &#123;
            // 如果找到的 first 节点，是红黑树 Node 节点，则直接在红黑树中查找
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            // 如果找到的 e 是 Node 节点，则说明是链表，需要遍历查找
            do &#123;
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            &#125; while ((e = e.next) != null);
        &#125;
    &#125;
    return null;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-  比较简单，`#removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)` 的 SE 版 </span><br><span class="line"></span><br><span class="line">-  `#containsKey(Object key)` 方法，就是基于该方法实现。代码如下： </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // HashMap.java</span><br><span class="line">  </span><br><span class="line">  public boolean containsKey(Object key) &#123;</span><br><span class="line">      return getNode(hash(key), key) != null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>#containsValue(Object value)</code> 方法，查找指定 value 是否存在。代码如下： </p>
</li>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F; HashMap.java</p>
<p>public boolean containsValue(Object value) {<br>Node&lt;K,V&gt;[] tab; V v;<br>if ((tab &#x3D; table) !&#x3D; null &amp;&amp; size &gt; 0) {<br>    &#x2F;&#x2F; 遍历 table 数组<br>    for (Node&lt;K,V&gt; e : tab) {<br>        &#x2F;&#x2F; 处理链表或者红黑树节点<br>        for (; e !&#x3D; null; e &#x3D; e.next) {<br>            &#x2F;&#x2F; 如果值相等，则返回 true<br>            if ((v &#x3D; e.value) &#x3D;&#x3D; value ||<br>                (value !&#x3D; null &amp;&amp; value.equals(v)))<br>                return true;<br>        }<br>    }<br>}<br>&#x2F;&#x2F; 找不到，返回 false<br>return false;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-  `#getOrDefault(Object key, V defaultValue)` 方法，获得 key 对应的 value 。如果不存在，则返回 `defaultValue` 默认值。代码如下： </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // HashMap.java</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public V getOrDefault(Object key, V defaultValue) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="12-转换成数组"><a href="#12-转换成数组" class="headerlink" title="12. 转换成数组"></a>12. 转换成数组</h4><ul>
<li><p><code>#keysToArray(T[] a)</code> 方法，转换出 key 数组返回。代码如下： </p>
</li>
<li><pre><code class="java">// HashMap.java

&lt;T&gt; T[] keysToArray(T[] a) &#123;
    Object[] r = a;
    Node&lt;K,V&gt;[] tab;
    int idx = 0;
    if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;
        // 遍历 table 数组
        for (Node&lt;K,V&gt; e : tab) &#123;
            // 遍历链表或红黑树
            for (; e != null; e = e.next) &#123;
                // 逐个设置 key 到 r 数组中
                r[idx++] = e.key;
            &#125;
        &#125;
    &#125;
    // 返回
    return a;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-  细心的，可能已经意识到了，如果 `a` 数组的大小不够放下 HashMap 的所有 key 怎么办？答案是可以通过 `#prepareArray(T[] a)` 方法来保证。代码如下：</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // HashMap.java</span><br><span class="line">  </span><br><span class="line">  final &lt;T&gt; T[] prepareArray(T[] a) &#123;</span><br><span class="line">      int size = this.size;</span><br><span class="line">      // 如果 a 数组小于 HashMap 大小，则创建一个新的数组返回</span><br><span class="line">      if (a.length &lt; size) &#123;</span><br><span class="line">          return (T[]) java.lang.reflect.Array</span><br><span class="line">                  .newInstance(a.getClass().getComponentType(), size);</span><br><span class="line">      &#125;</span><br><span class="line">      // 如果 a 数组大于 HashMap 大小，则将 size 位置设置为 null</span><br><span class="line">      if (a.length &gt; size) &#123;</span><br><span class="line">          a[size] = null;</span><br><span class="line">      &#125;</span><br><span class="line">      return a;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>当 <code>a</code> 数组过小时，会创建一个新的数组返回。</p>
</li>
<li><p>当然，一般情况下，我们肯定是不会使用到该方法</p>
</li>
<li><p><code>#valuesToArray(T[] a)</code> 方法，转换出 value 数组返回。代码如下 </p>
</li>
<li><pre><code class="java">// HashMap.java

&lt;T&gt; T[] valuesToArray(T[] a) &#123;
    Object[] r = a;
    Node&lt;K,V&gt;[] tab;
    int idx = 0;
    if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;
        // 遍历 table 数组
        for (Node&lt;K,V&gt; e : tab) &#123;
            // 遍历链表或红黑树
            for (; e != null; e = e.next) &#123;
                // 逐个设置 value 到 r 数组中
                r[idx++] = e.value;
            &#125;
        &#125;
    &#125;
    // 返回
    return a;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 13. 转换成 Set/Collection</span><br><span class="line"></span><br><span class="line">-  `#keySet()` 方法，获得 key Set 。代码如下： </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // AbstractMap.java</span><br><span class="line">  transient Set&lt;K&gt;        keySet;</span><br><span class="line">  </span><br><span class="line">  // HashMap.java</span><br><span class="line">  public Set&lt;K&gt; keySet() &#123;</span><br><span class="line">      // 获得 keySet 缓存</span><br><span class="line">      Set&lt;K&gt; ks = keySet;</span><br><span class="line">      // 如果不存在，则进行创建</span><br><span class="line">      if (ks == null) &#123;</span><br><span class="line">          ks = new KeySet();</span><br><span class="line">          keySet = ks;</span><br><span class="line">      &#125;</span><br><span class="line">      return ks;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>创建的 KeySet 类，实现了 <a href="https://github.com/YunaiV/openjdk/blob/master/src/java.base/share/classes/java/util/AbstractSet.java"><code>java.util.AbstractSet</code></a> 抽像类，是 HashMap 的内部类。</p>
</li>
<li><p><code>#values()</code> 方法，获得 value 集合。代码如下 </p>
</li>
<li><p>&#96;&#96;&#96;java<br>  &#x2F;&#x2F; AbstractMap.java<br>  transient Collection<V> values;</p>
</li>
</ul>
<p>  &#x2F;&#x2F; HashMap.java<br>  public Collection<V> values() {<br>      &#x2F;&#x2F; 获得 vs 缓存<br>      Collection<V> vs &#x3D; values;<br>      &#x2F;&#x2F; 如果不存在，则进行创建<br>      if (vs &#x3D;&#x3D; null) {<br>          vs &#x3D; new Values();<br>          values &#x3D; vs;<br>      }<br>      return vs;<br>  }<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-  创建的 Values 类，实现了 [`java.util.AbstractCollection`](https://github.com/YunaiV/openjdk/blob/master/src/java.base/share/classes/java/util/AbstractCollection.java) 抽像类，是 HashMap 的内部类。 </span><br><span class="line"></span><br><span class="line">-  `#entrySet()` 方法，获得 key-value Set 。代码如下： </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // HashMap.java</span><br><span class="line">  </span><br><span class="line">  transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">  </span><br><span class="line">  public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">      Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">      // 获得 entrySet 缓存</span><br><span class="line">      // 如果不存在，则进行创建</span><br><span class="line">      return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>创建的 EntrySet 类，实现了 <a href="https://github.com/YunaiV/openjdk/blob/master/src/java.base/share/classes/java/util/AbstractSet.java"><code>java.util.AbstractSet</code></a> 抽像类，是 HashMap 的内部类。</li>
</ul>
<h4 id="14-清空"><a href="#14-清空" class="headerlink" title="14. 清空"></a>14. 清空</h4><ul>
<li><p><code>#clear()</code> 方法，清空 HashMap 。代码如下 </p>
</li>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F; HashMap.java</p>
<p>public void clear() {<br>Node&lt;K,V&gt;[] tab;<br>&#x2F;&#x2F; 增加修改次数<br>modCount++;<br>if ((tab &#x3D; table) !&#x3D; null &amp;&amp; size &gt; 0) {<br>    &#x2F;&#x2F; 设置大小为 0<br>    size &#x3D; 0;<br>    &#x2F;&#x2F; 设置每个位置为 null<br>    for (int i &#x3D; 0; i &lt; tab.length; ++i)<br>        tab[i] &#x3D; null;<br>}<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 15. 序列化</span><br><span class="line"></span><br><span class="line">-  `#writeObject(ObjectOutputStream s)` 方法，序列化 HashMap 对象。代码如下 </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // HashMap.java</span><br><span class="line">  </span><br><span class="line">  @java.io.Serial</span><br><span class="line">  private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">      throws IOException &#123;</span><br><span class="line">      // 获得 HashMap table 数组大小</span><br><span class="line">      int buckets = capacity();</span><br><span class="line">      // Write out the threshold, loadfactor, and any hidden stuff</span><br><span class="line">      // 写入非静态属性、非 transient 属性</span><br><span class="line">      s.defaultWriteObject();</span><br><span class="line">      // 写入 table 数组大小</span><br><span class="line">      s.writeInt(buckets);</span><br><span class="line">      // 写入 key-value 键值对数量</span><br><span class="line">      s.writeInt(size);</span><br><span class="line">      // 写入具体的 key-value 键值对</span><br><span class="line">      internalWriteEntries(s);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  final int capacity() &#123; // table 数组大小。封装方法的原因，需要考虑 table 未初始化的情况。</span><br><span class="line">      return (table != null) ? table.length :</span><br><span class="line">          (threshold &gt; 0) ? threshold :</span><br><span class="line">          DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // Called only from writeObject, to ensure compatible ordering.</span><br><span class="line">  void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab;</span><br><span class="line">      if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</span><br><span class="line">          // 遍历 table 数组</span><br><span class="line">          for (Node&lt;K,V&gt; e : tab) &#123;</span><br><span class="line">              // 遍历链表或红黑树</span><br><span class="line">              for (; e != null; e = e.next) &#123;</span><br><span class="line">                  // 写入 key</span><br><span class="line">                  s.writeObject(e.key);</span><br><span class="line">                  // 写入 value</span><br><span class="line">                  s.writeObject(e.value);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="16-反序列化"><a href="#16-反序列化" class="headerlink" title="16. 反序列化"></a>16. 反序列化</h4><ul>
<li><p><code>#readObject(ObjectInputStream s)</code> 方法，反序列化成 HashMap 对象。代码如下 </p>
</li>
<li><pre><code class="java">// HashMap.java

@java.io.Serial
private void readObject(java.io.ObjectInputStream s)
    throws IOException, ClassNotFoundException &#123;
    // Read in the threshold (ignored), loadfactor, and any hidden stuff
    // 读取非静态属性、非 transient 属性
    s.defaultReadObject();
    // 重新初始化
    reinitialize();
    // 校验 loadFactor 参数
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +
                                         loadFactor);
    // 读取 HashMap table 数组大小
    s.readInt();                // Read and ignore number of buckets
    // 读取 key-value 键值对数量 size
    int mappings = s.readInt(); // Read number of mappings (size)
    // 校验 size 参数
    if (mappings &lt; 0)
        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +
                                         mappings);
    else if (mappings &gt; 0) &#123; // (if zero, use defaults)
        // Size the table using given load factor only if within
        // range of 0.25...4.0
        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);
        float fc = (float)mappings / lf + 1.0f;
        // 计算容量
        int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?
                   DEFAULT_INITIAL_CAPACITY :
                   (fc &gt;= MAXIMUM_CAPACITY) ?
                   MAXIMUM_CAPACITY :
                   tableSizeFor((int)fc));
        // 计算 threshold 阀值
        float ft = (float)cap * lf;
        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?
                     (int)ft : Integer.MAX_VALUE);

        // Check Map.Entry[].class since it&#39;s the nearest public type to
        // what we&#39;re actually creating.
        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap); // 不知道作甚，哈哈哈。
        // 创建 table 数组
        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
        Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];
        table = tab;

        // Read the keys and values, and put the mappings in the HashMap
        // 遍历读取 key-value 键值对
        for (int i = 0; i &lt; mappings; i++) &#123;
            // 读取 key
            @SuppressWarnings(&quot;unchecked&quot;)
            K key = (K) s.readObject();
            // 读取 value
            @SuppressWarnings(&quot;unchecked&quot;)
            V value = (V) s.readObject();
            // 添加 key-value 键值对
            putVal(hash(key), key, value, false, false);
        &#125;
    &#125;
&#125;

/**
 * Reset to initial default state.  Called by clone and readObject.
 */
void reinitialize() &#123;
    table = null;
    entrySet = null;
    keySet = null;
    values = null;
    modCount = 0;
    threshold = 0;
    size = 0;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 17. 克隆</span><br><span class="line"></span><br><span class="line">- `#clone()` 方法，克隆 HashMap 对象。代码如下 </span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  // HashMap.java</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public Object clone() &#123;</span><br><span class="line">      // 克隆 HashMap 对象</span><br><span class="line">      HashMap&lt;K,V&gt; result;</span><br><span class="line">      try &#123;</span><br><span class="line">          result = (HashMap&lt;K,V&gt;)super.clone();</span><br><span class="line">      &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">          // this shouldn&#x27;t happen, since we are Cloneable</span><br><span class="line">          throw new InternalError(e);</span><br><span class="line">      &#125;</span><br><span class="line">      // 重新初始化</span><br><span class="line">      result.reinitialize();</span><br><span class="line">      // 批量添加 key-value 键值对到其中</span><br><span class="line">      result.putMapEntries(this, false);</span><br><span class="line">      // 返回 result</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>对于 key-value 键值对是浅拷贝，</p>
</li>
</ul>
<h4 id="18-总结与彩蛋"><a href="#18-总结与彩蛋" class="headerlink" title="18.总结与彩蛋"></a>18.总结与彩蛋</h4><p>在理解 HashMap 的实现原理之后，再去看 HashMap 的实现代码，其实会比想象中简单非常多 </p>
<p>几个新增的方法没有写，</p>
<ul>
<li><code>#replace(K key, V oldValue, V newValue)</code></li>
<li><code>#replace(K key, V value)</code></li>
<li><code>#computeIfAbsent(K key, Function mappingFunction)</code></li>
<li><code>#computeIfPresent(K key, BiFunction remappingFunction)</code></li>
<li><code>#compute(K key, BiFunction remappingFunction)</code></li>
<li><code>#merge(K key, V value, BiFunction remappingFunction)</code></li>
<li><code>#forEach(BiConsumer action)</code></li>
<li><code>#replaceAll(BiFunction function)</code></li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><p>HashMap 是一种散列表的数据结构，底层采用数组 + 链表 + 红黑树来实现存储。 </p>
</li>
<li><blockquote>
<p>Redis Hash 数据结构，采用数组 + 链表实现。</p>
<p>Redis Zset 数据结构，采用跳表实现。</p>
<p>因为红黑树实现起来相对复杂，我们自己在实现 HashMap 可以考虑采用数组 + 链表 + 跳表来实现存储。</p>
</blockquote>
</li>
<li><p>HashMap 默认容量为 16(<code>1 &lt;&lt; 4</code>)，每次超过阀值时，按照两倍大小进行自动扩容，所以容量总是 2^N 次方。并且，底层的 <code>table</code> 数组是延迟初始化，在首次添加 key-value 键值对才进行初始化。 </p>
</li>
<li><p>HashMap 默认加载因子是 0.75 ，如果我们已知 HashMap 的大小，需要正确设置容量和加载因子。</p>
</li>
<li><p>HashMap 每个槽位在满足如下两个条件时，可以进行树化成红黑树，避免槽位是链表数据结构时，链表过长，导致查找性能过慢。</p>
<ul>
<li>条件一，HashMap 的 <code>table</code> 数组大于等于 64 。</li>
<li>条件二，槽位链表长度大于等于 8 时。选择 8 作为阀值的原因是，参考 <a href="http://en.wikipedia.org/wiki/Poisson_distribution">泊松概率函数(Poisson distribution)</a> ，概率不足千万分之一。</li>
<li>在槽位的红黑树的节点数量小于等于 6 时，会退化回链表。</li>
</ul>
</li>
<li><p>HashMap 的查找和添加 key-value 键值对的<strong>平均</strong>时间复杂度为 O(1) 。 </p>
</li>
<li><p>对于槽位是链表的节点，<strong>平均</strong>时间复杂度为 O(k) 。其中 k 为链表长度。</p>
</li>
<li><p>对于槽位是红黑树的节点，<strong>平均</strong>时间复杂度为 O(logk) 。其中 k 为红黑树节点数量。</p>
</li>
<li><p>推荐文章： 美团技术团队 的 <a href="https://zhuanlan.zhihu.com/p/21673805">Java 8系列之重新认识HashMap</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JVM介绍</title>
    <url>/2021/12/05/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC1%E7%AB%A0-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="第1章-JVM和Java体系架构"><a href="#第1章-JVM和Java体系架构" class="headerlink" title="第1章-JVM和Java体系架构"></a>第1章-JVM和Java体系架构</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你是否也遇到过这些问题？</p>
<ol>
<li>运行着的线上系统突然卡死，系统无法访问，甚至直接OOM！</li>
<li>想解决线上JVM GC问题，但却无从下手。</li>
<li>新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就JJ了。</li>
<li>每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_001/0001.png">

<p>大部分Java开发人员，除了会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。</p>
<h2 id="开发人员如何看待上层框架"><a href="#开发人员如何看待上层框架" class="headerlink" title="开发人员如何看待上层框架"></a>开发人员如何看待上层框架</h2><ol>
<li>一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。</li>
<li>如果我们把核心类库的API比做数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_001/0002.png">

<ul>
<li>计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言。</li>
</ul>
<h2 id="架构师每天都在思考什么？"><a href="#架构师每天都在思考什么？" class="headerlink" title="架构师每天都在思考什么？"></a>架构师每天都在思考什么？</h2><ol>
<li>应该如何让我的系统更快？</li>
<li>如何避免系统出现瓶颈？</li>
</ol>
<p><strong>知乎上有条帖子：应该如何看招聘信息，直通年薪50万+？</strong></p>
<ol>
<li>参与现有系统的性能优化，重构，保证平台性能和稳定性</li>
<li>根据业务场景和需求，决定技术方向，做技术选型</li>
<li>能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求</li>
<li>解决各类潜在系统风险，核心功能的架构与代码编写</li>
<li>分析系统瓶颈，解决各种疑难杂症，性能调优等</li>
</ol>
<h2 id="我们为什么要学习JVM"><a href="#我们为什么要学习JVM" class="headerlink" title="我们为什么要学习JVM"></a>我们为什么要学习JVM</h2><ol>
<li>面试的需要（BATJ、TMD，PKQ等面试都爱问）</li>
<li>中高级程序员必备技能</li>
</ol>
<ul>
<li>项目管理、调优的需要</li>
</ul>
<ol start="3">
<li>追求极客的精神，<ul>
<li>比如：垃圾回收算法、JIT、底层原理</li>
</ul>
</li>
</ol>
<h2 id="Java-VS-C"><a href="#Java-VS-C" class="headerlink" title="Java VS C++"></a>Java VS C++</h2><ol>
<li>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</li>
<li>C++语言需要程序员自己来分配内存和回收内存，对于高手来说可能更加舒服，但是对于普通开发者，如果技术实力不够，很容易造成内存泄漏。而Java全部交给JVM进行内存分配和回收，这也是一种趋势，减少程序员的工作量。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_001/0003.png">

<h2 id="什么人需要学JVM？"><a href="#什么人需要学JVM？" class="headerlink" title="什么人需要学JVM？"></a>什么人需要学JVM？</h2><ol>
<li>拥有一定开发经验的Java开发人员，希望升职加薪</li>
<li>软件设计师，架构师</li>
<li>系统调优人员</li>
<li>虚拟机爱好者，JVM实践者</li>
</ol>
<h2 id="推荐及参考书籍"><a href="#推荐及参考书籍" class="headerlink" title="推荐及参考书籍"></a>推荐及参考书籍</h2><p><strong>官方文档</strong></p>
<p><strong>英文文档规范</strong>：<a href="https://docs.oracle.com/javase/specs/index.html">https://docs.oracle.com/javase/specs/index.html</a></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_001/0004.png">

<p><strong>中文书籍：</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_001/0005.png">

<blockquote>
<p>周志明老师的这本书<strong>非常推荐看</strong>，不过只推荐看第三版，第三版较第二版更新了很多，个人觉得没必要再看第二版。</p>
</blockquote>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_001/0006.png">



<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_001/0007.png">

<h2 id="TIOBE排行榜"><a href="#TIOBE排行榜" class="headerlink" title="TIOBE排行榜"></a>TIOBE排行榜</h2><p><strong>TIOBE 排行榜</strong>：<a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_001/0008.png">

<ul>
<li>世界上没有最好的编程语言，只有最适用于具体应用场景的编程语言。</li>
<li>目前网上一直流传Java被python，go撼动Java第一的地位。学习者不需要太担心，Java强大的生态圈，也不是说是朝夕之间可以被撼动的。</li>
</ul>
<h2 id="Java生态圈"><a href="#Java生态圈" class="headerlink" title="Java生态圈"></a>Java生态圈</h2><p>Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p>
<ol>
<li>作为一个平台，Java虚拟机扮演着举足轻重的作用<ul>
<li>Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分</li>
</ul>
</li>
<li>作为一种文化，Java几乎成为了“开源”的代名词。<ul>
<li>第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。</li>
<li>就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。</li>
</ul>
</li>
<li>作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。</li>
</ol>
<h2 id="Java-跨平台的语言"><a href="#Java-跨平台的语言" class="headerlink" title="Java-跨平台的语言"></a>Java-跨平台的语言</h2><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_001/0009.png">

<h2 id="JVM-跨语言的平台"><a href="#JVM-跨语言的平台" class="headerlink" title="JVM-跨语言的平台"></a>JVM-跨语言的平台</h2><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_001/0010.png">



<ol>
<li>随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。</li>
<li>Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</li>
</ol>
<ul>
<li>Java不是最强大的语言，但是JVM是最强大的虚拟机</li>
</ul>
<ol>
<li><p>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。</p>
</li>
<li><p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</p>
</li>
<li><p>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</p>
</li>
</ol>
<h2 id="多语言混合编程"><a href="#多语言混合编程" class="headerlink" title="多语言混合编程"></a>多语言混合编程</h2><ol>
<li><p>Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</p>
</li>
<li><p>试想一下，在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby&#x2F;Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。</p>
</li>
<li><p>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如DaVinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。</p>
</li>
</ol>
<h2 id="如何真正搞懂JVM？"><a href="#如何真正搞懂JVM？" class="headerlink" title="如何真正搞懂JVM？"></a>如何真正搞懂JVM？</h2><ol>
<li>Java虚拟机非常复杂，要想真正理解它的工作原理，最好的方式就是自己动手编写一个！</li>
<li>自己动手写一个Java虚拟机，难吗？</li>
<li>天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_001/0011.png">

<h2 id="Java发展重大事件"><a href="#Java发展重大事件" class="headerlink" title="Java发展重大事件"></a>Java发展重大事件</h2><ul>
<li>1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为Oak，后期命名为Java</li>
<li>1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相。</li>
<li>1996年1月23日Sun Microsystems发布了JDK 1.0。</li>
<li>1998年，JDK1.2版本发布。同时，Sun发布了JSP&#x2F;Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。</li>
<li>2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。</li>
<li>2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。</li>
<li>2003年年底，Java平台的scala正式发布，同年Groovy也加入了Java阵营。</li>
<li>2004年，JDK1.5发布。同时JDK1.5改名为JavaSE5.0。</li>
<li>2006年，JDK6发布。同年，Java开源并建立了OpenJDK。顺理成章，Hotspot虚拟机也成为了OpenJDK中的默认虚拟机。</li>
<li>2007年，Java平台迎来了新伙伴Clojure。</li>
<li>2008年，oracle收购了BEA，得到了JRockit虚拟机。</li>
<li>2009年，Twitter宣布把后台大部分程序从Ruby迁移到Scala，这是Java平台的又一次大规模应用。</li>
<li>2010年，Oracle收购了Sun，获得Java商标和最真价值的HotSpot虚拟机。此时，Oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit。JCP组织管理Java语言</li>
<li>2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。</li>
<li><strong>2017年，JDK9发布。将G1设置为默认GC，替代CMS</strong></li>
<li>同年，IBM的J9开源，形成了现在的Open J9社区</li>
<li>2018年，Android的Java侵权案判决，Google赔偿Oracle计88亿美元</li>
<li>同年，Oracle宣告JavagE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会</li>
<li><strong>同年，JDK11发布，LTS版本的JDK，发布革命性的ZGC，调整JDK授权许可</strong></li>
<li>2019年，JDK12发布，加入RedHat领导开发的Shenandoah GC</li>
</ul>
<h2 id="Open-JDK和Oracle-JDK"><a href="#Open-JDK和Oracle-JDK" class="headerlink" title="Open JDK和Oracle JDK"></a>Open JDK和Oracle JDK</h2><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_001/0012.png">

<ul>
<li>在JDK11之前，Oracle JDK中还会存在一些Open JDK中没有的，闭源的功能。但在JDK11中，我们可以认为Open JDK和Oracle JDK代码实质上已经达到完全一致的程度了。</li>
<li>主要的区别就是两者更新周期不一样</li>
</ul>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="虚拟机概念"><a href="#虚拟机概念" class="headerlink" title="虚拟机概念"></a>虚拟机概念</h3><ul>
<li><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p>
<ul>
<li>大名鼎鼎的Virtual Box，VMware就属于系统虚拟机，它们完全是对物理计算机硬件的仿真(模拟)，提供了一个可运行完整操作系统的软件平台。</li>
</ul>
<ul>
<li>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</li>
</ul>
</li>
<li><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
</li>
</ul>
<h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><ol>
<li>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</li>
<li>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</li>
<li><strong>Java技术的核心就是Java虚拟机</strong>（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</li>
</ol>
<p><strong>作用：</strong></p>
<p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释&#x2F;编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p>
<p><strong>特点：</strong></p>
<ol>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ol>
<h2 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h2><p>JVM是运行在操作系统之上的，它与硬件没有直接的交互</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_001/0013.png">



<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_001/0014.png">



<h2 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h2><ol>
<li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</li>
<li>它采用<strong>解释器与即时编译器</strong>并存的架构。</li>
<li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++程序一较高下的地步。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_001/0015.png">



<h2 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h2><p>凡是能生成被Java虚拟机所能解释、运行的字节码文件，那么理论上我们就可以自己设计一套语言了</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_001/0016.png">



<h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong>，另外一种指令集架构则是<strong>基于寄存器的指令集架构</strong>。具体来说：这两种架构之间的区别：</p>
<h3 id="基于栈的指令集架构"><a href="#基于栈的指令集架构" class="headerlink" title="基于栈的指令集架构"></a>基于栈的指令集架构</h3><p>基于栈式架构的特点：</p>
<ol>
<li>设计和实现更简单，适用于资源受限的系统；</li>
<li>避开了寄存器的分配难题：使用零地址指令方式分配</li>
<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>
</ol>
<h3 id="基于寄存器的指令级架构"><a href="#基于寄存器的指令级架构" class="headerlink" title="基于寄存器的指令级架构"></a>基于寄存器的指令级架构</h3><p>基于寄存器架构的特点：</p>
<ol>
<li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li>
<li>指令集架构则完全依赖硬件，与硬件的耦合度高，可移植性差</li>
<li>性能优秀和执行更高效</li>
<li>花费更少的指令去完成一项操作</li>
<li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</li>
</ol>
<h3 id="两种架构的举例"><a href="#两种架构的举例" class="headerlink" title="两种架构的举例"></a>两种架构的举例</h3><p>同样执行2+3这种逻辑操作，其指令分别如下：</p>
<ul>
<li><p><strong>基于栈的计算流程（以Java虚拟机为例）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iconst_2 <span class="comment">//常量2入栈</span></span><br><span class="line">istore_1</span><br><span class="line">iconst_3 <span class="comment">// 常量3入栈</span></span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd <span class="comment">//常量2/3出栈，执行相加</span></span><br><span class="line">istore_0 <span class="comment">// 结果5入栈</span></span><br></pre></td></tr></table></figure>

<p>8个指令</p>
</li>
<li><p><strong>而基于寄存器的计算流程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mov eax,<span class="number">2</span> <span class="comment">//将eax寄存器的值设为1</span></span><br><span class="line">add eax,<span class="number">3</span> <span class="comment">//使eax寄存器的值加3</span></span><br></pre></td></tr></table></figure>

<p>2个指令</p>
</li>
</ul>
<blockquote>
<p>具体后面会讲</p>
</blockquote>
<h3 id="JVM架构总结"><a href="#JVM架构总结" class="headerlink" title="JVM架构总结"></a>JVM架构总结</h3><ol>
<li><p><strong>由于跨平台性的设计，Java的指令都是根据栈来设计的</strong>。<strong>不同平台CPU架构不同，所以不能设计为基于寄存器的</strong>。栈的优点：跨平台，指令集小，编译器容易实现，缺点是性能比寄存器差一些。</p>
</li>
<li><p>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpot VM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p>
</li>
</ol>
<ul>
<li>因为基于栈的架构跨平台性好、指令集小，虽然相对于基于寄存器的架构来说，基于栈的架构编译得到的指令更多，执行性能也不如基于寄存器的架构好，但考虑到其跨平台性与移植性，我们还是选用栈的架构</li>
</ul>
<h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p>
<h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ol>
<li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</li>
<li>程序开始执行时他才运行，程序结束时他就停止</li>
<li><strong>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</strong></li>
</ol>
<h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p><strong>有如下的几种情况：</strong></p>
<ol>
<li><p>程序正常执行结束</p>
</li>
<li><p>程序在执行过程中遇到了异常或错误而异常终止</p>
</li>
<li><p>由于操作系统用现错误而导致Java虚拟机进程终止</p>
</li>
<li><p>某线程调用Runtime类或System类的exit()方法，或Runtime类的halt()方法，并且Java安全管理器也允许这次exit()或halt()操作。</p>
</li>
<li><p>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</p>
</li>
</ol>
<h2 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ol>
<li>早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是<strong>世界上第一款商用Java虚拟机</strong>，JDK1.4时完全被淘汰。</li>
<li>这款虚拟机内部只提供解释器，没有即时编译器，因此效率比较低。【即时编译器会把热点代码的本地机器指令缓存起来，那么以后使用热点代码的时候，效率就比较高】</li>
<li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作，解释器和编译器不能配合工作。<ul>
<li>我们将字节码指令翻译成机器指令也是需要花时间的，如果只使用JIT，就需要把所有字节码指令都翻译成机器指令，就会导致翻译时间过长，也就是说在程序刚启动的时候，等待时间会很长。</li>
<li>而解释器就是走到哪，解释到哪。</li>
</ul>
</li>
<li>现在Hotspot内置了此虚拟机。</li>
</ol>
<h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><ol>
<li><p>为了解决上一个虚拟机问题，jdk1.2时，Sun提供了此虚拟机。</p>
</li>
<li><p>Exact Memory Management：准确式内存管理</p>
<ul>
<li><p>也可以叫Non-Conservative&#x2F;Accurate Memory Management</p>
</li>
<li><p>虚拟机可以知道内存中某个位置的数据具体是什么类型。</p>
</li>
</ul>
</li>
<li><p>具备现代高性能虚拟机的维形</p>
<ul>
<li><p>热点探测（寻找出热点代码进行缓存）</p>
</li>
<li><p>编译器与解释器混合工作模式</p>
</li>
</ul>
</li>
<li><p>只在Solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换</p>
</li>
</ol>
<h3 id="HotSpot-VM（重点）"><a href="#HotSpot-VM（重点）" class="headerlink" title="HotSpot VM（重点）"></a>HotSpot VM（重点）</h3><ol>
<li><p>HotSpot历史</p>
<ul>
<li><p>最初由一家名为“Longview Technologies”的小公司设计</p>
</li>
<li><p>1997年，此公司被Sun收购；2009年，Sun公司被甲骨文收购。</p>
</li>
<li><p>JDK1.3时，HotSpot VM成为默认虚拟机</p>
</li>
</ul>
</li>
<li><p>目前<strong>Hotspot占有绝对的市场地位，称霸武林</strong>。</p>
<ul>
<li><p>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</p>
</li>
<li><p>Sun&#x2F;oracle JDK和openJDK的默认虚拟机</p>
</li>
<li><p>因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。（比如其他两个商用虚机都没有方法区的概念）</p>
</li>
</ul>
</li>
<li><p>从服务器、桌面到移动端、嵌入式都有应用。</p>
</li>
<li><p>名称中的HotSpot指的就是它的热点代码探测技术。</p>
<ul>
<li><p>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</p>
</li>
<li><p>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</p>
</li>
</ul>
</li>
</ol>
<h3 id="JRockit（商用三大虚拟机之一）"><a href="#JRockit（商用三大虚拟机之一）" class="headerlink" title="JRockit（商用三大虚拟机之一）"></a>JRockit（商用三大虚拟机之一）</h3><ol>
<li><p>专注于服务器端应用：它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</p>
</li>
<li><p>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM：使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</p>
</li>
<li><p>优势：全面的Java运行时解决方案组合</p>
<ul>
<li><p>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</p>
</li>
<li><p>Mission Control服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</p>
</li>
</ul>
</li>
<li><p>2008年，JRockit被Oracle收购。</p>
</li>
<li><p>Oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</p>
</li>
<li><p>高斯林：目前就职于谷歌，研究人工智能和水下机器人</p>
</li>
</ol>
<h3 id="IBM的J9（商用三大虚拟机之一）"><a href="#IBM的J9（商用三大虚拟机之一）" class="headerlink" title="IBM的J9（商用三大虚拟机之一）"></a>IBM的J9（商用三大虚拟机之一）</h3><ol>
<li><p>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</p>
</li>
<li><p>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。</p>
</li>
<li><p>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。</p>
</li>
<li><p>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给Eclipse基金会管理，也称为Eclipse OpenJ9</p>
</li>
<li><p>OpenJDK -&gt; 是JDK开源了，包括了虚拟机</p>
</li>
</ol>
<h3 id="KVM和CDC-x2F-CLDC-Hotspot"><a href="#KVM和CDC-x2F-CLDC-Hotspot" class="headerlink" title="KVM和CDC&#x2F;CLDC Hotspot"></a>KVM和CDC&#x2F;CLDC Hotspot</h3><ol>
<li><p>Oracle在Java ME产品线上的两款虚拟机为：CDC&#x2F;CLDC HotSpot Implementation VM </p>
</li>
<li><p>KVM（Kilobyte）是CLDC-HI早期产品</p>
</li>
<li><p>目前移动领域地位尴尬，智能机被Android和iOS二分天下。</p>
</li>
<li><p>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p>
<ul>
<li><p>智能控制器、传感器</p>
</li>
<li><p>老人手机、经济欠发达地区的功能手机</p>
</li>
</ul>
</li>
<li><p>所有的虚拟机的原则：一次编译，到处运行。</p>
</li>
</ol>
<h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><ol>
<li>前面三大“高性能Java虚拟机”使用在<strong>通用硬件平台上</strong></li>
<li>这里Azul VW和BEA Liquid VM是与<strong>特定硬件平台绑定</strong>、软硬件配合的专有虚拟机：高性能Java虚拟机中的战斗机。</li>
<li>Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的Java虚拟机。</li>
<li>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</li>
<li>2010年，Azul Systems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。</li>
</ol>
<h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><ol>
<li>高性能Java虚拟机中的战斗机。</li>
<li>BEA公司开发的，直接运行在自家Hypervisor系统上</li>
<li>Liquid VM即是现在的JRockit VE（Virtual Edition）。<strong>Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等</strong>。</li>
<li>随着JRockit虚拟机终止开发，Liquid vM项目也停止了。</li>
</ol>
<h3 id="Apache-Marmony"><a href="#Apache-Marmony" class="headerlink" title="Apache Marmony"></a>Apache Marmony</h3><ol>
<li><p>Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。</p>
</li>
<li><p>它是IElf和Intel联合开发的开源JVM，受到同样开源的Open JDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</p>
</li>
<li><p>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</p>
</li>
</ol>
<h3 id="Micorsoft-JVM"><a href="#Micorsoft-JVM" class="headerlink" title="Micorsoft JVM"></a>Micorsoft JVM</h3><ol>
<li><p>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</p>
</li>
<li><p>只能在window平台下运行。但确是当时Windows下性能最好的Java VM。</p>
</li>
<li><p>1997年，Sun以侵犯商标、不正当竞争罪名指控微软成功，赔了Sun很多钱。微软WindowsXP SP3中抹掉了其VM。现在Windows上安装的jdk都是HotSpot。</p>
</li>
</ol>
<h3 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h3><ol>
<li><p>由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p>
</li>
<li><p><strong>基于OpenJDK开发了自己的定制版本AlibabaJDK</strong>，简称AJDK。是整个阿里Java体系的基石。</p>
</li>
<li><p>基于OpenJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。</p>
<ul>
<li>创新的GCIH（GCinvisible heap）技术实现了off-heap，<strong>即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的</strong>。</li>
<li>GCIH中的<strong>对象还能够在多个Java虚拟机进程中实现共享</strong></li>
<li>使用crc32指令实现JvM intrinsic降低JNI的调用开销</li>
<li>PMU hardware的Java profiling tool和诊断协助功能</li>
<li>针对大数据场景的ZenGC</li>
</ul>
</li>
<li><p>taobao vm应用在阿里产品上性能高，<strong>硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能</strong></p>
</li>
</ol>
<ul>
<li>目前已经在淘宝、天猫上线，把Oracle官方JvM版本全部替换了。</li>
</ul>
<h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><ol>
<li><p>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</p>
</li>
<li><p><strong>Dalvik VM只能称作虚拟机，而不能称作“Java虚拟机”</strong>，它没有遵循 Java虚拟机规范</p>
</li>
<li><p>不能直接执行Java的Class文件</p>
</li>
<li><p>基于寄存器架构，不是jvm的栈架构。</p>
</li>
<li><p>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</p>
</li>
</ol>
<ul>
<li>它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li>
</ul>
<ol start="7">
<li>Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。</li>
</ol>
<h3 id="Graal-VM（未来虚拟机）"><a href="#Graal-VM（未来虚拟机）" class="headerlink" title="Graal VM（未来虚拟机）"></a>Graal VM（未来虚拟机）</h3><ol>
<li><p>2018年4月，Oracle Labs公开了GraalvM，号称 “<strong>Run Programs Faster Anywhere</strong>”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。</p>
</li>
<li><p>GraalVM在HotSpot VM基础上增强而成的<strong>跨语言全栈虚拟机，可以作为“任何语言”</strong>的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</p>
</li>
<li><p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p>
</li>
<li><p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p>
</li>
<li><p><strong>如果说HotSpot有一天真的被取代，Graalvm希望最大</strong>。但是Java的软件生态没有丝毫变化。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以Oracle HotSpot VM为默认虚拟机。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>垃圾回收器</title>
    <url>/2021/12/05/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC12%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="GC-分类与性能指标"><a href="#GC-分类与性能指标" class="headerlink" title="GC 分类与性能指标"></a>GC 分类与性能指标</h2><h3 id="垃圾回收器概述"><a href="#垃圾回收器概述" class="headerlink" title="垃圾回收器概述"></a>垃圾回收器概述</h3><ol>
<li><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</p>
</li>
<li><p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</p>
</li>
<li><p>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</p>
</li>
</ol>
<p><strong>Java不同版本新特性</strong></p>
<ol>
<li>语法层面：Lambda表达式、switch、自动拆箱装箱、enum、泛型</li>
<li>API层面：Stream API、新的日期时间、Optional、String、集合框架</li>
<li>底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池等</li>
</ol>
<h3 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h3><p><strong>按线程数分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0001.png">

<ol>
<li>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。<ol>
<li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中</li>
<li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器</li>
</ol>
</li>
<li>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</li>
</ol>
<p><strong>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。</strong></p>
<ol>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>
<li>独占式垃圾回收器（Stop the World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0002.png">



<p><strong>按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。</strong></p>
<ol>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。再分配对象空间使用指针碰撞</li>
<li>非压缩式的垃圾回收器不进行这步操作，分配对象空间使用空闲列表</li>
</ol>
<p><strong>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</strong></p>
<h3 id="评估-GC-的性能指标"><a href="#评估-GC-的性能指标" class="headerlink" title="评估 GC 的性能指标"></a>评估 GC 的性能指标</h3><p><strong>指标</strong></p>
<ol>
<li><p>吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</p>
</li>
<li><p>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</p>
</li>
<li><p>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</p>
</li>
<li><p>收集频率：相对于应用程序的执行，收集操作发生的频率。</p>
</li>
<li><p>内存占用：Java堆区所占的内存大小。</p>
</li>
<li><p>快速：一个对象从诞生到被回收所经历的时间。</p>
</li>
<li><p>吞吐量、暂停时间、内存占用这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p>
</li>
<li><p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p>
</li>
<li><p>简单来说，主要抓住两点：</p>
<ul>
<li><strong><code>吞吐量</code></strong></li>
<li><strong><code>暂停时间</code></strong></li>
</ul>
</li>
</ol>
<p><strong>吞吐量（throughput）</strong></p>
<ol>
<li>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量&#x3D;运行用户代码时间 &#x2F;（运行用户代码时间+垃圾收集时间）<ul>
<li>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</li>
</ul>
</li>
<li>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的**<code>应用程序有更长的时间</code>**基准，快速响应是不必考虑的</li>
<li>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2&#x3D;0.4</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0003.png">



<p><strong>暂停时间（pause time）</strong></p>
<ol>
<li>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态。<ul>
<li>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的</li>
</ul>
</li>
<li>暂停时间优先，意味着**<code>尽可能让单次STW的时间最短</code>**：0.1+0.1 + 0.1+ 0.1+ 0.1&#x3D;0.5，但是总的GC时间可能会长</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0004.png">



<p><strong>吞吐量 vs 暂停时间</strong></p>
<ol>
<li><p><strong>高吞吐量较好</strong>因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p>
</li>
<li><p>低暂停时间（低延迟）较好，是从最终用户的角度来看，不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有较低的暂停时间是非常重要的，特别是对于一个交互式应用程序（就是和用户交互比较多的场景）。</p>
</li>
<li><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p>
<ul>
<li>因为如果选择以吞吐量优先，那么<strong>必然需要降低内存回收的执行频率</strong>，但是这样会导致GC需要更长的暂停时间来执行内存回收。</li>
<li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li>
</ul>
</li>
<li><p>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p>
</li>
<li><p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p>
</li>
</ol>
<h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><ol>
<li>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</li>
<li>那么，Java常见的垃圾收集器有哪些？</li>
</ol>
<h3 id="垃圾收集器发展史"><a href="#垃圾收集器发展史" class="headerlink" title="垃圾收集器发展史"></a>垃圾收集器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p>
<ol>
<li>1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li>
<li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·</li>
<li>Parallel GC在JDK6之后成为HotSpot默认GC。</li>
<li>2012年，在JDK1.7u4版本中，G1可用。</li>
<li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li>
<li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>
<li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li>
<li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。</li>
<li>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</li>
<li>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用</li>
</ol>
<h3 id="7款经典的垃圾收集器"><a href="#7款经典的垃圾收集器" class="headerlink" title="7款经典的垃圾收集器"></a>7款经典的垃圾收集器</h3><ol>
<li>串行回收器：Serial、Serial old</li>
<li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li>
<li>并发回收器：CMS、G1</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0005.png">

<p><strong>官方文档</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0006.jpg">



<p><strong>7款经典回收器与垃圾分代之间的关系</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0007.png">

<ol>
<li><p>新生代收集器：Serial、ParNew、Parallel Scavenge；</p>
</li>
<li><p>老年代收集器：Serial old、Parallel old、CMS；</p>
</li>
<li><p>整堆收集器：G1；</p>
</li>
</ol>
<h3 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h3><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0008.png">



<ol>
<li><p>两个收集器间有连线，表明它们可以搭配使用：</p>
<ul>
<li>Serial&#x2F;Serial old</li>
<li>Serial&#x2F;CMS    （JDK9废弃）</li>
<li>ParNew&#x2F;Serial Old （JDK9废弃）</li>
<li>ParNew&#x2F;CMS</li>
<li>Parallel Scavenge&#x2F;Serial Old  （预计废弃）</li>
<li>Parallel Scavenge&#x2F;Parallel Old</li>
<li>G1</li>
</ul>
</li>
<li><p>其中Serial Old作为CMS出现”Concurrent Mode Failure”失败的后备预案。</p>
</li>
<li><p>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</p>
</li>
<li><p>（绿色虚线）JDK14中：弃用Parallel Scavenge和Serial Old GC组合（JEP366）</p>
</li>
<li><p>（青色虚线）JDK14中：删除CMS垃圾回收器（JEP363）</p>
</li>
<li><p>为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p>
</li>
<li><p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以<strong>我们选择的只是对具体应用最合适的收集器</strong>。</p>
</li>
</ol>
<h3 id="查看默认垃圾收集器"><a href="#查看默认垃圾收集器" class="headerlink" title="查看默认垃圾收集器"></a>查看默认垃圾收集器</h3><ol>
<li>-XX:+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</li>
<li>使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</li>
</ol>
<h4 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h4><p><strong>在 JDK 8 下，设置 JVM 参数</strong></p>
<p>-XX:+PrintCommandLineFlags</p>
<p>程序打印输出：-XX:+UseParallelGC 表示使用使用 ParallelGC ，ParallelGC 默认和 Parallel Old 绑定使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:InitialHeapSize=<span class="number">266620736</span> -XX:MaxHeapSize=<span class="number">4265931776</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC </span><br></pre></td></tr></table></figure>



<p><strong>通过命令行指令查看</strong></p>
<p>命令行命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jps</span><br><span class="line">jinfo -flag UseParallelGC 进程id</span><br><span class="line">jinfo -flag UseParallelOldGC 进程id</span><br></pre></td></tr></table></figure>



<p>JDK 8 中默认使用 ParallelGC 和 ParallelOldGC 的组合</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0009.png">

<h4 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h4><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0010.png">



<h2 id="Serial-回收器：串行回收"><a href="#Serial-回收器：串行回收" class="headerlink" title="Serial 回收器：串行回收"></a>Serial 回收器：串行回收</h2><p><strong>Serial 回收器：串行回收</strong></p>
<ol>
<li><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p>
</li>
<li><p>Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。</p>
</li>
<li><p>Serial收集器采用**<code>复制算法</code><strong>、</strong><code>串行回收</code>**和”Stop-the-World”机制的方式执行内存回收。</p>
</li>
<li><p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial old收集器同样也采用了<strong>串行</strong>回收和”Stop the World”机制，只不过内存回收算法使用的是<strong>标记-压缩算法。</strong></p>
</li>
<li><p>Serial Old是运行在<strong>Client模式</strong>下默认的老年代的垃圾回收器，Serial Old在Server模式下主要有两个用途：①与新生代的Parallel Scavenge配合使用②作为<strong>老年代CMS收集器的后备垃圾收集方案</strong></p>
</li>
</ol>
<p>这个收集器是一个单线程的收集器，“单线程”的意义：它只会使用一个CPU（串行）或一条收集线程去完成垃圾收集工作。更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0011.png">



<p><strong>Serial 回收器的优势</strong></p>
<ol>
<li>优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于<strong>没有线程交互的开销</strong>，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在Client模式下的虚拟机是个不错的选择。</li>
<li>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</li>
<li>在HotSpot虚拟机中，使用-XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。<ul>
<li>等价于新生代用Serial GC，且老年代用Serial Old GC</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核CPU才可以用。现在都不是单核的了。</p>
</li>
<li><p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java Web应用程序中是不会采用串行垃圾收集器的。</p>
</li>
</ol>
<h2 id="ParNew-回收器：并行回收"><a href="#ParNew-回收器：并行回收" class="headerlink" title="ParNew 回收器：并行回收"></a>ParNew 回收器：并行回收</h2><ol>
<li>如果说Serial GC是年轻代中的单线程垃圾收集器，那么**<code>ParNew收集器则是Serial收集器的多线程版本。</code>**<ul>
<li>Par是Parallel的缩写，New：只能处理新生代</li>
</ul>
</li>
<li>ParNew 收集器除了采用<strong>并行回收</strong>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。**<code>ParNew收集器在年轻代中同样也是采用复制算法</code><strong>、</strong><code>&quot;Stop-the-World&quot;机制。</code>**</li>
<li>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0012.png">

<ol>
<li>对于新生代，**<code>回收次数频繁</code><strong>，使用</strong>并行方式高效**。</li>
<li>对于老年代，回收次数少，使用<strong>串行方式节省资源</strong>。<strong>（<code>CPU并行需要切换线程，串行可以省去切换线程的资源</code>）</strong></li>
</ol>
<p><strong>ParNew 回收器与 Serial 回收器比较</strong></p>
<p>Q：由于ParNew收集器基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？</p>
<p>A：<strong>不能</strong></p>
<ol>
<li>ParNew收集器运行在<strong>多CPU的环境</strong>下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>但是在<strong>单个CPU</strong>的环境下，ParNew收集器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li>
<li>除Serial外，目前只有ParNew GC能与CMS收集器配合工作</li>
</ol>
<p><strong>设置 ParNew 垃圾回收器</strong></p>
<ol>
<li><p>在程序中，开发人员可以通过选项”-XX:+UseParNewGC”手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>
</li>
<li><p>-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。</p>
</li>
</ol>
<h2 id="Parallel-amp-Parallel-Old-回收器：吞吐量优先"><a href="#Parallel-amp-Parallel-Old-回收器：吞吐量优先" class="headerlink" title="Parallel&amp;Parallel Old 回收器：吞吐量优先"></a>Parallel&amp;<strong>Parallel Old</strong> 回收器：吞吐量优先</h2><p><strong>Parallel Scavenge 回收器：吞吐量优先</strong></p>
<ol>
<li><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器<strong>同样也采用了<code>复制算法、并行回收和&quot;Stop the World&quot;机制</code>。</strong></p>
</li>
<li><p>那么Parallel收集器的出现是否<code>多此一举</code>？</p>
<ul>
<li>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个<strong>可控制的吞吐量</strong>（Throughput），它也被称为吞吐量优先的垃圾收集器。</li>
<li><strong>自适应调节策略</strong>也是**<code>Parallel Scavenge</code><strong>与</strong><code>ParNew</code><strong>一个重要区别。（</strong>动态调整内存分配情况，以达到一个最优的吞吐量或低延迟**）</li>
</ul>
</li>
<li><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，<strong>主要适合在后台运算而不需要太多交互的任务</strong>。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
</li>
<li><p>Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的<strong>Parallel Old收集器，用来代替老年代的Serial Old收集器。</strong></p>
</li>
<li><p><strong><code>Parallel Old</code><strong>收集器采用了</strong><code>标记-压缩算法</code><strong>，但同样也是基于</strong><code>并行回收和&quot;Stop-the-World&quot;机制。</code></strong></p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0013.png">

<ol>
<li>在程序吞吐量优先的应用场景中，<strong>Parallel收集器和Parallel Old收集器</strong>的组合，在server模式下的内存回收性能很不错。</li>
<li><strong>在Java8中，默认是此垃圾收集器。</strong></li>
</ol>
<p><strong>Parallel Scavenge 回收器参数设置</strong></p>
<ol>
<li><p>-XX:+UseParallelGC 手动指定年轻代使用Parallel并行收集器执行内存回收任务。</p>
</li>
<li><p>-XX:+UseParallelOldGC：手动指定老年代都是使用并行回收收集器。</p>
<ul>
<li><p>分别适用于新生代和老年代</p>
</li>
<li><p>上面两个参数分别适用于新生代和老年代。默认jdk8是开启的。默认开启一个，另一个也会被开启。（互相激活）</p>
</li>
</ul>
</li>
<li><p>-XX:ParallelGCThreads：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p>
<ol>
<li><p>在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。</p>
</li>
<li><p>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]&#x2F;8]</p>
</li>
</ol>
</li>
<li><p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒。</p>
<ol>
<li>为了尽可能地把停顿时间控制在XX:MaxGCPauseMillis 以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li>
<li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</li>
<li>该参数使用需谨慎。</li>
</ol>
</li>
<li><p>-XX:GCTimeRatio垃圾收集时间占总时间的比例，即等于 1 &#x2F; (N+1) ，用于衡量吞吐量的大小。</p>
<ol>
<li><p>取值范围(0, 100)。默认值99，也就是垃圾回收时间占比不超过1。</p>
</li>
<li><p>与前一个-XX:MaxGCPauseMillis参数有一定矛盾性，STW暂停时间越长，Radio参数就容易超过设定的比例。</p>
</li>
</ol>
</li>
<li><p>-XX:+UseAdaptiveSizePolicy 设置Parallel Scavenge收集器具有<strong>自适应调节策略</strong></p>
<ol>
<li><p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</p>
</li>
<li><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。</p>
</li>
</ol>
</li>
</ol>
<h2 id="CMS-回收器：低延迟-老年代的收集器"><a href="#CMS-回收器：低延迟-老年代的收集器" class="headerlink" title="CMS 回收器：低延迟 老年代的收集器"></a>CMS 回收器：低延迟 老年代的收集器</h2><p><strong><code>标记-清除</code></strong> <strong><code>Stop-the-World</code></strong></p>
<h3 id="CMS-回收器-专门老年代的收集器"><a href="#CMS-回收器-专门老年代的收集器" class="headerlink" title="CMS 回收器 专门老年代的收集器"></a>CMS 回收器 专门<code>老年代</code>的收集器</h3><ol>
<li>在JDK1.5时期，Hotspot推出了一款在<strong>强交互应用中（就是和用户打交道的引用）</strong>几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，<strong>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</strong></li>
<li>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。<ul>
<li>目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</li>
</ul>
</li>
<li>CMS的垃圾收集算法采用**<code>标记-清除算法，并且也会&quot;Stop-the-World&quot;</code>**</li>
<li>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作（因为实现的框架不一样，没办法兼容使用），所以在JDK1.5中使用CMS来收集老年代的时候，**<code>新生代只能选择ParNew或者Serial收集器中的一个。</code>**</li>
<li>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</li>
</ol>
<h3 id="CMS-工作原理（过程）"><a href="#CMS-工作原理（过程）" class="headerlink" title="CMS 工作原理（过程）"></a>CMS 工作原理（过程）</h3><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0014.png">

<p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即**<code>初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。</code>**(涉及STW的阶段主要是：初始标记 和 重新标记)</p>
<ol>
<li><p><strong><code>初始标记</code><strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“</strong>Stop-the-World</strong>”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是<strong>标记出GC Roots能<code>直接</code>关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<strong>速度非常快</strong>。</p>
</li>
<li><p><strong><code>并发标记</code><strong>（Concurrent-Mark）阶段：</strong>从GC Roots的<code>直接关联对象开始遍历整个对象图</code><strong>的过程，</strong><code>这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</code></strong></p>
</li>
<li><p><strong><code>重新标记</code><strong>（Remark）阶段：由于在并发标记阶段中，</strong><code>程序的工作线程会和垃圾收集线程同时运行或者交叉运行</code><strong>，</strong><code>并发过程中用户程序修改了对象引用关系,本来不是垃圾现在变成垃圾了 1）可达&gt; 不可达（2）不可达&gt;可达（3）新的对象。</code><strong>，</strong>因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，</strong>这个阶段的停顿时间通常会比初始标记阶段稍长一些，并且也会导致<strong>“Stop-the-World”</strong>的发生，但也远比并发标记阶段的时间短。</p>
<blockquote>
<p>无法发现 Concurrent Mark 期间堆外根集（<strong>寄存器、栈</strong>）的<strong>引用变化</strong>。为此在 concurrent mark 之后，需要一个 remark 阶段再 STW 扫一遍<strong>根集GC Roots</strong></p>
</blockquote>
</li>
<li><p><strong><code>并发清除</code><strong>（Concurrent-Sweep）阶段：此阶段清理删除掉</strong>标记阶段判断的已经死亡的对象</strong>，<strong>释放内存空间</strong>。<strong>由于<code>不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</code></strong></p>
</li>
</ol>
<h3 id="CMS分析"><a href="#CMS分析" class="headerlink" title="CMS分析"></a>CMS分析</h3><p><strong><code>阈值96%</code></strong></p>
<ol>
<li>尽管CMS收集器采用的是并发回收（非独占式），<strong>但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制</strong>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。</li>
<li><strong>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的</strong>。</li>
<li>另外，由于在<strong>垃圾收集阶段用户线程没有中断</strong>，所以在CMS回收过程中，<strong>还应该<code>确保应用程序用户线程有足够的内存可用（不然收集垃圾过程中用户线程挂了）</code><strong>。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，</strong>而是当堆内存使用率达到某一阈值时<code>jdk6以上默认92%</code>，便开始进行回收</strong>，<strong>以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。<code>要是CMS运行期间预留的内存无法满足程序需要，</code><strong>就会出现一次</strong>“Concurrent Mode Failure”</strong> 失败，这时虚拟机将启动后备预案：**<code>临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</code>**</li>
<li>CMS收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，<strong>不可避免地将会产生一些内存碎片</strong>。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而**<code>只能够选择空闲列表（Free List）执行内存分配。</code>**</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0015.png">



<p><strong>为什么 CMS 不采用标记-压缩算法呢？</strong></p>
<p>答案其实很简答，因为当**<code>并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用</code>呢<strong>？</strong>要保证用户线程能继续执行，前提的它运行的资源不受影响嘛**。Mark Compact更适合“stop the world”这种场景下使用</p>
<h3 id="CMS-的优点与弊端"><a href="#CMS-的优点与弊端" class="headerlink" title="CMS 的优点与弊端"></a>CMS 的优点与弊端</h3><p><strong>优点</strong></p>
<ol>
<li>并发收集</li>
<li>低延迟</li>
</ol>
<p><strong>弊端</strong></p>
<ol>
<li><strong>会产生内存碎片</strong>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。</li>
<li><strong>CMS收集器对CPU资源非常敏感</strong>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li>
<li><strong>CMS收集器无法处理浮动垃圾</strong>。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，<strong>那么在<code>并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记</code>，最终会导致这些新产生的垃圾对象没有被及时回收，</strong>从而**<code>只能在下一次执行GC</code>**时释放这些之前未被回收的内存空间。</li>
</ol>
<h3 id="CMS-参数配置"><a href="#CMS-参数配置" class="headerlink" title="CMS 参数配置"></a>CMS 参数配置</h3><ul>
<li><p>-XX:+UseConcMarkSweepGC：手动指定使用CMS收集器执行内存回收任务。</p>
<p>开启该参数后会自动将-XX:+UseParNewGC打开。即：ParNew（Young区）+CMS（Old区）+Serial Old（Old区备选方案）的组合。</p>
</li>
<li><p>-XX:CMSInitiatingOccupanyFraction：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p>
</li>
</ul>
<ol>
<li><p>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%</p>
</li>
<li><p>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。</p>
</li>
</ol>
<ul>
<li><p>-XX:+UseCMSCompactAtFullCollection：用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p>
</li>
<li><p>-XX:CMSFullGCsBeforeCompaction：设置在执行多少次Full GC后对内存空间进行压缩整理。</p>
</li>
<li><p>-XX:ParallelCMSThreads：设置CMS的线程数量。</p>
</li>
</ul>
<ol>
<li>CMS默认启动的线程数是 (ParallelGCThreads + 3) &#x2F; 4，ParallelGCThreads是年轻代并行收集器的线程数，可以当做是 CPU 最大支持的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢？</p>
<ol>
<li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li>
<li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li>
<li>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</li>
</ol>
<h3 id="JDK-后续版本中-CMS-的变化"><a href="#JDK-后续版本中-CMS-的变化" class="headerlink" title="JDK 后续版本中 CMS 的变化"></a>JDK 后续版本中 CMS 的变化</h3><ol>
<li>JDK9新特性：CMS被标记为Deprecate了（JEP291）<ul>
<li>如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX:+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</li>
</ul>
</li>
<li>JDK14新特性：删除CMS垃圾回收器（JEP363）移除了CMS垃圾收集器，<ul>
<li>如果在JDK14中使用XX:+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</li>
</ul>
</li>
</ol>
<h2 id="G1-回收器：区域化分代式"><a href="#G1-回收器：区域化分代式" class="headerlink" title="G1 回收器：区域化分代式"></a>G1 回收器：区域化分代式</h2><h3 id="为什么还需要G1"><a href="#为什么还需要G1" class="headerlink" title="为什么还需要G1"></a>为什么还需要G1</h3><p><strong>既然我们已经有了前面几个强大的 GC ，为什么还要发布 Garbage First（G1）GC？</strong></p>
<ol>
<li>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li>
<li>G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</li>
<li>与此同时，<strong>为了适应现在不断扩大的内存和不断增加的处理器数量</strong>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</li>
<li>官方给G1设定的目标是在**<code>延迟可控的情况下获得尽可能高的吞吐量</code>**STW时间一定的情况下，程序运行时间尽量高，所以才担当起“全功能收集器”的重任与期望。</li>
</ol>
<h3 id="为什么名字叫Garbage-First-G1-呢？"><a href="#为什么名字叫Garbage-First-G1-呢？" class="headerlink" title="为什么名字叫Garbage First(G1)呢？"></a>为什么名字叫Garbage First(G1)呢？</h3><ol>
<li>因为G1是一个并行回收器，它把**<code>堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代</code>**等。</li>
<li>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1**<code>跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值）</code><strong>，在后台维护一个</strong><code>优先列表</code><strong>，</strong>每次根据允许的收集时间，<code>优先回收价值最大的Region</code>。**</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：**<code>垃圾优先（Garbage First）</code>**。</li>
<li>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</li>
<li>在JDK1.7版本正式启用，移除了Experimental的标识，<strong>是<code>JDK9以后的默认垃圾回收器</code><strong>，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方称为</strong>“全功能的垃圾收集器”</strong>。</li>
<li>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。<strong>G1在JDK8中还不是默认的垃圾回收器</strong>，需要使用-XX:+UseG1GC来启用。</li>
</ol>
<h3 id="G1-回收器的优势"><a href="#G1-回收器的优势" class="headerlink" title="G1 回收器的优势"></a>G1 回收器的优势</h3><p>**<code>与其他GC收集器相比，G1使用了全新的分区算法</code>**，其特点如下所示：</p>
<ol>
<li><p><strong>并行与并发兼备</strong></p>
<ul>
<li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li>
<li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
</li>
<li><p><strong>分代收集</strong></p>
<ul>
<li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>
<li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li>
<li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>
</ul>
<p>G1的分代，已经不是下面这样的了</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0016.png">

<p>G1的分区是这样的一个区域</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0017.png">

<p><strong>空间整合</strong></p>
<ol>
<li>CMS：**<code>“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</code>**</li>
<li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。**<code>Region之间是复制算法</code>，但<code>整体上实际可看作是标记-压缩（Mark-Compact）算法</code>**，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>
</ol>
<h3 id="可预测的停顿时间模型"><a href="#可预测的停顿时间模型" class="headerlink" title="可预测的停顿时间模型"></a>可预测的停顿时间模型</h3><p><strong>可预测的停顿时间模型（即：软实时soft real-time）</strong></p>
<p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<ol>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的Region</strong>。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li>
<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ol>
<h3 id="G1-回收器的缺点"><a href="#G1-回收器的缺点" class="headerlink" title="G1 回收器的缺点"></a>G1 回收器的缺点</h3><ol>
<li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</li>
<li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</li>
</ol>
<h3 id="G1-参数设置"><a href="#G1-参数设置" class="headerlink" title="G1 参数设置"></a>G1 参数设置</h3><ul>
<li><p>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</p>
</li>
<li><p>-XX:G1HeapRegionSize：设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000。</p>
</li>
<li><p>-XX:MaxGCPauseMillis：设置期望达到的最大GC停顿时间指标，JVM会尽力实现，但不保证达到。默认值是200ms</p>
</li>
<li><p>-XX:+ParallelGCThread：设置STW工作线程数的值。最多设置为8</p>
</li>
<li><p>-XX:ConcGCThreads：设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1&#x2F;4左右。</p>
</li>
<li><p>-XX:InitiatingHeapOccupancyPercent：设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p>
</li>
</ul>
<h3 id="G1-收集器的常见操作步骤"><a href="#G1-收集器的常见操作步骤" class="headerlink" title="G1 收集器的常见操作步骤"></a>G1 收集器的常见操作步骤</h3><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p>
<ol>
<li>第一步：开启G1垃圾收集器</li>
<li>第二步：设置堆的最大内存</li>
<li>第三步：设置最大的停顿时间</li>
</ol>
<p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC，在不同的条件下被触发。</p>
<h3 id="G1-的适用场景"><a href="#G1-的适用场景" class="headerlink" title="G1 的适用场景"></a>G1 的适用场景</h3><ol>
<li>面向服务端应用，针对具有**<code>大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</code>**</li>
<li>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</li>
<li>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</li>
<li>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：<ul>
<li>超过50%的Java堆被活动数据占用；</li>
<li>对象分配频率或年代提升频率变化很大；</li>
<li>GC停顿时间过长（长于0.5至1秒）</li>
</ul>
</li>
<li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器均使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li>
</ol>
<h3 id="分区-Region"><a href="#分区-Region" class="headerlink" title="分区 Region"></a>分区 Region</h3><blockquote>
<p>分区跟之前有所不同</p>
</blockquote>
<p><strong>分区 Region：化整为零</strong></p>
<ol>
<li><p>使用G1收集器时，它将整个<strong>Java堆划分成约2048个<code>大小相同的独立Region块</code><strong>，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过XX:G1HeapRegionSize设定。</strong>所有的<code>Region大小相同</code>，且在JVM生命周期内不会被改变。</strong></p>
</li>
<li><p>虽然还保留有新生代和老年代的概念，但**<code>新生代和老年代不再是物理隔离的了</code><strong>，它们都是一部分Region（不需要连续）的集合。通过</strong><code>Region的动态分配方式实现逻辑上的连续</code>**。</p>
</li>
<li><p>一个Region有可能属于Eden，Survivor或者Old&#x2F;Tenured内存区域。但是一个Region只可能属于一个角色。图中的E表示该Region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</p>
</li>
<li><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过0.5个Region，就放到H。</p>
</li>
</ol>
<blockquote>
<p>纠错：尚硅谷视频里这里写的是超过1.5个region。根据<a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">官方文档</a>:  <strong>The G1 Garbage Collector Step by Step</strong></p>
<p>As shown regions can be allocated into Eden, survivor, and old generation regions. In addition, there is a fourth type of object known as Humongous regions. These regions are designed to hold objects that are 50% the size of a standard region or larger. They are stored as a set of contiguous regions. Finally the last type of regions would be the unused areas of the heap.</p>
<p>翻译：</p>
<p>如图所示，可以将区域分配到**<code>Eden</code><strong>，</strong><code>幸存者</code><strong>和</strong><code>旧时代区域</code><strong>。 此外，还有第四种类型的物体被称为</strong><code>巨大区域</code><strong>。 这些区域旨在</strong><code>容纳标准区域大小的50％或更大的对象</code><strong>。 <strong>它们存储为一组连续区域</strong>。 最后，最后一种区域类型是</strong>堆的未使用区域。**</p>
</blockquote>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0018.png">



<p><strong>设置 H 的原因</strong></p>
<p>对于<strong>堆中的大对象，默认直接会被分配到老年代</strong>，但是如果<strong>它是<code>一个短期存在的大对象</code><strong>就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如</strong>果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储</strong>。<strong>为了能找到连续的H区，有时候不得不启动Full GC</strong>。G1的大多数行为都把H区作为老年代的一部分来看待。</p>
<p><strong>Regio的细节</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0019.png">

<ol>
<li>每个Region都是通过**<code>指针碰撞</code>**来分配空间</li>
<li>G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。</li>
<li>TLAB还是用来保证并发性</li>
</ol>
<h3 id="G1-垃圾回收流程"><a href="#G1-垃圾回收流程" class="headerlink" title="G1 垃圾回收流程"></a>G1 垃圾回收流程</h3><p>G1 GC的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li>**<code>年轻代GC</code>**（Young GC）只有Eden区耗尽的时候会触发</li>
<li>**<code>老年代并发标记过程</code>**（Concurrent Marking）</li>
<li>**<code>混合回收</code>**（Mixed GC）</li>
<li>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</li>
</ul>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0020.png">

<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMC5tZWl0dWFuLm5ldC90cmF2ZWxjdWJlLzJmNTZhOWEyNDliYzhkNzRmNGY0NTU3ODJhYmNlNmJlMTQ3OTk3LnBuZ0AxODMyd184NDhoXzgwcQ?x-oss-process=image/format,png" alt="img"></p>
<p>顺时针，Young GC –&gt; Young GC+Concurrent Marking –&gt; Mixed GC顺序，进行垃圾回收</p>
<blockquote>
<p>-XX:InitiatingHeapOccupancyPercent：设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45</p>
<p>也就是**<code>堆使用超过45%</code><strong>会触发</strong><code>并发标记</code><strong>了，</strong><code>并发标记（可能会被 young gc打断</code>**）完之后马上开始混合回收</p>
</blockquote>
<p><strong>回收流程</strong></p>
<ol>
<li>应用程序分配内存，**<code>当年轻代的Eden区用尽时开始年轻代回收过程</code>只有Eden区耗尽的时候会触发，Servior区是跟着回收<strong>；G1的年轻代收集阶段是一个</strong><code>并行的独占式收集器</code><strong>。在年轻代回收期，</strong><code>G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</code>**</li>
<li><strong>当堆内存使用<code>达到一定值（默认45%）</code>时，开始老年代并发标记过程。</strong></li>
<li><strong>标记完成<code>马上开始混合回收</code>过程。</strong>对于一个混合回收期，**<code>G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分</code><strong>。和年轻代不同，老年代的G1回收器和其他GC不同，</strong>G1的老年代回收器<code>不需要整个老年代被回收</code>，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了**。同时，这个老年代Region是和年轻代一起被回收的。</li>
<li>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</li>
</ol>
<h3 id="Remembered-Set（记忆集）"><a href="#Remembered-Set（记忆集）" class="headerlink" title="Remembered Set（记忆集）"></a>Remembered Set（记忆集）</h3><blockquote>
<p>当**<code>引用的对象不在自己所在的region的时候</code>**，要通过CardTable(卡表)把相关的引用信息记录到对方的Remenbered Set中</p>
</blockquote>
<ol>
<li><p><strong>一个对象被不同区域引用的问题</strong></p>
</li>
<li><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？<code>老年代中的引用使用了年轻代</code></p>
</li>
<li><p>在其他的分代收集器，也存在这样的问题（而G1更突出，因为G1主要针对大堆）</p>
</li>
<li><p>回收新生代也不得不同时扫描老年代？这样的话会降低Minor GC的效率</p>
</li>
</ol>
<p><strong>解决方法：</strong></p>
<ol>
<li><p>无论G1还是其他分代收集器，**<code>JVM都是使用Remembered Set来避免全堆扫描；</code>**</p>
</li>
<li><p><strong><code>每个Region都有一个对应的Remembered Set</code></strong></p>
</li>
<li><p><strong><code>每次Reference类型数据写操作时</code><strong>，都会产生一个</strong>Write Barrier暂时中断操作</strong>；</p>
</li>
<li><p>然后**<code>检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region</code><strong>（</strong><code>其他收集器：检查老年代对象是否引用了新生代对象</code>**）；</p>
</li>
<li><p>如果不同，通过CardTable把**<code>相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中</code>**；</p>
</li>
<li><p>当进行垃圾收集时，在**<code>GC根节点的枚举范围加入Remembered Set</code>**；就可以保证不进行全局扫描，也不会有遗漏。</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0021.png">

<ol>
<li>在回收 Region 时，为了不进行全堆的扫描，引入了 Remembered Set</li>
<li>Remembered Set 记录了当前 Region 中的对象被哪个对象引用了</li>
<li>这样在进行 Region 复制时，就不要扫描整个堆，只需要去 Remembered Set 里面找到引用了当前 Region 的对象</li>
<li><strong><code>Region 复制完毕后，修改 Remembered Set 中对象的引用即可(该表记录了地址，需要修改调整之前的引用)</code></strong></li>
</ol>
<h3 id="G1回收过程一：年轻代-GC"><a href="#G1回收过程一：年轻代-GC" class="headerlink" title="G1回收过程一：年轻代 GC"></a>G1回收过程一：年轻代 GC</h3><blockquote>
<p>触发<strong>STW</strong>，年轻代GC一定会用到记忆集，因为不可能去老年代扫一遍吧？老年代回收的时候本身就会回收年轻代，就不需要担心了</p>
</blockquote>
<ol>
<li>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，<strong>当<code>Eden空间耗尽时</code>，G1会启动一次年轻代垃圾回收过程。</strong></li>
<li><strong>年轻代回收只回收<code>Eden</code>区和<code>Survivor</code>区</strong></li>
<li><strong>YGC时，首先G1停止应用程序的执行（Stop-The-World）</strong>，**<code>G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</code>**</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0022.png">

<p>图的大致意思就是：</p>
<p>1、**<code>回收完E和S区，剩余存活的对象会复制到新的S区</code>**</p>
<p>2、**<code>S区达到一定的阈值可以晋升为O区</code>**</p>
<p><strong>年轻代GC回收过程：</strong></p>
<p><img src="/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC12%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20220222164450031.png" alt="image-20220222164450031"></p>
<blockquote>
<p><strong>回收完之后，空闲的Eden区会添加到链表(LinkedList)中，供下次写入使用</strong></p>
</blockquote>
<p><strong>备注：</strong></p>
<ol>
<li>对于应用程序的引用赋值语句 oldObject.field（这个是老年代）&#x3D;object（这个是新生代），JVM会在之前和之后执行特殊的操作以在<strong>dirty card queue</strong>中入队一个保存了<strong>对象引用信息的card</strong>。在年轻代回收的时候，G1<strong>会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。</strong></li>
<li>那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要<strong>线程同步</strong>，开销会很大，使用队列性能会好很多。</li>
</ol>
<h3 id="G1回收过程二：并发标记过程"><a href="#G1回收过程二：并发标记过程" class="headerlink" title="G1回收过程二：并发标记过程"></a>G1回收过程二：并发标记过程</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">---------------</span><br><span class="line">|<span class="params">	年轻代GC   </span>|</span><br><span class="line">---------------</span><br><span class="line">|<span class="params">	老年代标记  </span>|</span><br><span class="line">---------------</span><br></pre></td></tr></table></figure>

<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0020.png" style="zoom:50%;" >

<p>并发标记完马上开始混合回收</p>
<blockquote>
<p><strong><code>当垃圾达到堆内存的45%的时候就会进行G1垃圾回收</code><strong>，进行的就是</strong><code>并发标记和混合回收</code></strong></p>
</blockquote>
<ol>
<li><strong>初始标记阶段</strong>：<strong>标记从根节点直接可达的对象。这个阶段是<code>STW</code>的</strong>，并且会触发一次**<code>年轻代GC</code><strong>。正是由于该阶段时STW的，所以我们</strong><code>只扫描根节点可达的对象，以节省时间。</code>**</li>
<li><strong>根区域扫描</strong>（Root Region Scanning）：G1 GC扫描**<code>Survivor区直接可达的老年代区域对象</code><strong>，并</strong>标记被引用的对象<strong>。这一过程必须在</strong><code>Young GC</code>**之前完成，因为Young GC会使用复制算法对Survivor区进行GC。</li>
<li><strong>并发标记</strong>（Concurrent Marking）：<ol>
<li>在<strong>整个堆</strong>中进行并发标记（和应用程序并发执行），此过程可能被**<code>Young GC</code>**中断。</li>
<li><strong>在并发标记阶段，若发现区域对象中的<code>所有对象都是垃圾</code>，那这个区域会被立即回收。</strong></li>
<li>同时，并发标记过程中，**<code>会计算每个区域的对象活性</code><strong>（区域中</strong><code>存活对象的比例</code>**）。</li>
</ol>
</li>
<li><strong>再次标记</strong>（Remark）：由于应用程序持续进行，需要<strong>修正上一次的标记结果</strong>。是**<code>STW</code>**的。G1中采用了比CMS更快的<code>原始快照算法：Snapshot-At-The-Beginning（SATB）。</code></li>
<li><strong>独占清理</strong>（cleanup，STW）：<strong>计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。</strong>为下阶段做铺垫。是**<code>STW</code><strong>的。这个阶段</strong>并不会实际上去做垃圾的收集**</li>
<li><strong>并发清理阶段</strong>：<strong>识别并清理完全空闲的区域。</strong></li>
</ol>
<h3 id="G1回收过程三：混合回收过程"><a href="#G1回收过程三：混合回收过程" class="headerlink" title="G1回收过程三：混合回收过程"></a>G1回收过程三：混合回收过程</h3><blockquote>
<p>并发标记完马上开始混合回收</p>
</blockquote>
<p>当越来越多的对象晋升到老年代Old Region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，（默认值45%），也就是<strong>垃圾超过45%<strong>的时候触发混合回收，即Mixed GC，该算法并不是一个Old GC，</strong>除了回收整个Young Region，还会回收一部分的Old Region。</strong>这里需要注意：是一部分老年代，而不是全部老年代。根据设定的垃圾回收时间尽可能的回收价值大的region，可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是<strong>Mixed GC并不是Full GC。</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0023.png">



<p><strong>混合回收的细节</strong></p>
<ol>
<li>并发标记结束以后，老年代中<strong>百分百为垃圾的内存分段被回收了</strong>，<strong>部分为垃圾的内存分段被计算了出来</strong>。默认情况下，这些老年代的内存分段<strong>会分8次</strong>（可以通过-XX:G1MixedGCCountTarget设置）<strong>被回收</strong>。</li>
<li>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。<strong>混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段</strong>。具体过程请参考上面的年轻代回收过程。</li>
<li>由于老年代中的内存分段默认分8次回收，G1会<strong>优先回收垃圾多的内存分段</strong>。垃圾占内存分段比例越高的，越会被先回收。并且有一个<strong>阈值</strong>会决定内存分段是否被回收。XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是<strong>垃圾占内存分段比例要达到<code>65%</code>才会被回收</strong>。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li>
<li>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，**<code>意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收</code>**。因为GC会花费很多的时间但是回收到的内存却很少。</li>
</ol>
<h3 id="G1-回收可选的过程四：Full-GC"><a href="#G1-回收可选的过程四：Full-GC" class="headerlink" title="G1 回收可选的过程四：Full GC"></a>G1 回收可选的过程四：Full GC</h3><ol>
<li><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（**<code>Stop-The-World</code><strong>），使用</strong>单线程**的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
</li>
<li><p>要避免Full GC的发生，一旦发生Full GC，需要对JVM参数进行调整。什么时候会发生Ful1GC呢？比如**<code>堆内存太小</code><strong>，当</strong><code>G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC</code>**，这种情况可以通过增大内存解决。</p>
</li>
</ol>
<p>导致G1 Full GC的原因可能有两个：</p>
<ol>
<li><strong>EVacuation的时候没有足够的to-space来存放晋升的对象；</strong></li>
<li><strong>并发处理过程完成之前空间耗尽。</strong></li>
</ol>
<h3 id="G1补充"><a href="#G1补充" class="headerlink" title="G1补充"></a>G1补充</h3><p>从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，<strong>而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。</strong>另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<p><strong>G1 回收器的优化建议</strong></p>
<ol>
<li>年轻代大小<ul>
<li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小，因为固定年轻代的大小会覆盖可预测的暂停时间目标。我们让G1自己去调整</li>
</ul>
</li>
<li>暂停时间目标不要太过严苛<ul>
<li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li>
<li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
</ul>
</li>
</ol>
<h2 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h2><h3 id="7-种垃圾回收器的比较"><a href="#7-种垃圾回收器的比较" class="headerlink" title="7 种垃圾回收器的比较"></a>7 种垃圾回收器的比较</h3><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0034.jpg">



<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0024.png">





<h3 id="怎么选择垃圾回收器"><a href="#怎么选择垃圾回收器" class="headerlink" title="怎么选择垃圾回收器"></a>怎么选择垃圾回收器</h3><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？</p>
<ol>
<li>优先调整堆的大小让JVM自适应完成。</li>
<li>如果内存小于100M，使用串行收集器</li>
<li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li>
<li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li>
<li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li>
<li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li>
</ol>
<p>最后需要明确一个观点：</p>
<ol>
<li>没有最好的收集器，更没有万能的收集算法</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ol>
<p><strong>面试</strong></p>
<ol>
<li>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。</li>
<li>这里较通用、基础性的部分如下：<ul>
<li>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li>
<li>垃圾收集器工作的基本流程。</li>
</ul>
</li>
<li>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</li>
</ol>
<h2 id="GC-日志分析"><a href="#GC-日志分析" class="headerlink" title="GC 日志分析"></a>GC 日志分析</h2><h3 id="常用参数配置"><a href="#常用参数配置" class="headerlink" title="常用参数配置"></a>常用参数配置</h3><blockquote>
<p><strong>GC 日志参数设置</strong></p>
</blockquote>
<p><strong>通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。</strong></p>
<p>内存分配与垃圾回收的参数列表</p>
<ol>
<li>-XX:+PrintGC ：输出GC日志。类似：-verbose:gc</li>
<li>-XX:+PrintGCDetails ：输出GC的详细日志</li>
<li>-XX:+PrintGCTimestamps ：输出GC的时间戳（以基准时间的形式）</li>
<li>-XX:+PrintGCDatestamps ：输出GC的时间戳（以日期的形式，如2013-05-04T21: 53: 59.234 +0800）</li>
<li>-XX:+PrintHeapAtGC ：在进行GC的前后打印出堆的信息</li>
<li>-Xloggc:…&#x2F;logs&#x2F;gc.log ：日志文件的输出路径</li>
</ol>
<blockquote>
<p><strong>verbose:gc</strong></p>
</blockquote>
<p>1、JVM 参数</p>
<p><code>-verbose:gc</code></p>
<p>2、这个只会显示总的GC堆的变化，如下：</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0025.png">

<p>3、参数解析</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0026.png">



<blockquote>
<p><strong>PrintGCDetails</strong></p>
</blockquote>
<p>1、JVM 参数</p>
<p><code>-XX:+PrintGCDetails</code></p>
<p>2、输入信息如下</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0027.png">

<p>3、参数解析</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0028.png">



<blockquote>
<p><strong>PrintGCTimestamps 和 PrintGCDatestamps</strong></p>
</blockquote>
<p>1、JVM 参数</p>
<p><code>-XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps</code></p>
<p>2、输出信息如下</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0029.png">

<p>3、说明：日志带上了日期和时间</p>
<h3 id="GC-日志补充说明"><a href="#GC-日志补充说明" class="headerlink" title="GC 日志补充说明"></a>GC 日志补充说明</h3><ol>
<li><p>“[GC”和”[Full GC”说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了”Stop The World”</p>
</li>
<li><p>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew”</p>
</li>
<li><p>使用ParNew收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation”</p>
</li>
<li><p>使用Parallel scavenge收集器在新生代的名字是”[PSYoungGen”</p>
</li>
<li><p>老年代的收集和新生代道理一样，名字也是收集器决定的</p>
</li>
<li><p>使用G1收集器的话，会显示为”garbage-first heap”</p>
</li>
<li><p>Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p>
</li>
<li><p>[ PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K-&gt;704K (9216K)</p>
<ul>
<li>中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）</li>
<li>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li>
</ul>
</li>
<li><p>user代表用户态回收耗时，sys内核态回收耗时，real实际耗时。由于多核线程切换的原因，时间总和可能会超过real时间</p>
</li>
</ol>
<h4 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h4><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0030.png">



<h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0031.png">



<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在jdk7 和 jdk8中分别执行</span></span><br><span class="line"><span class="comment"> * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCLogTest1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> &#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>JDK7 中的情况</strong></p>
<p>1、首先我们会将3个2M的数组存放到Eden区，然后后面4M的数组来了后，将无法存储，因为Eden区只剩下2M的剩余空间了，那么将会进行一次Young GC操作，将原来Eden区的内容，存放到Survivor区，但是Survivor区也存放不下，那么就会直接晋级存入Old 区</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0032.png">

<p>2、然后我们将4M对象存入到Eden区中</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0033.png">

<p>老年代图画的有问题，free应该是4M</p>
<p><strong>JDK8 中的情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.atguigu.java.GCLogTest1</span><br><span class="line">[GC (Allocation Failure) [DefNew: 6322K-&gt;668K(9216K), <span class="number">0.0034812</span> secs] 6322K-&gt;4764K(19456K), <span class="number">0.0035169</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> <span class="title class_">generation</span>   total 9216K, used 7050K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,  <span class="number">77</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff23b668</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,  <span class="number">65</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff5a71d8</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 4096K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,  <span class="number">40</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffa00020</span>, <span class="number">0x00000000ffa00200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3469K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 381K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0035.jpg">

<p>与 JDK7 不同的是，JDK8 直接判定 4M 的数组为大对象，直接怼到老年区去了</p>
<h3 id="常用日志分析工具"><a href="#常用日志分析工具" class="headerlink" title="常用日志分析工具"></a>常用日志分析工具</h3><p><strong>保存日志文件</strong></p>
<p><strong>JVM参数</strong>：<code>-XLoggc:./logs/gc.log</code>，  .&#x2F; 表示当前目录，在 IDEA中程序运行的当前目录是工程的根目录，而不是模块的根目录</p>
<p>可以用一些工具去分析这些GC日志，常用的日志分析工具有：</p>
<p>GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等</p>
<p><strong>推荐：GCeasy</strong></p>
<p>在线分析网址：gceasy.io</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0036.jpg">



<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0037.png">



<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0038.png">



<h2 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h2><h3 id="垃圾回收器的发展过程"><a href="#垃圾回收器的发展过程" class="headerlink" title="垃圾回收器的发展过程"></a>垃圾回收器的发展过程</h3><ol>
<li>GC仍然处于飞速发展之中，目前的默认选项G1 GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Full GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，Fu11GC已经是并行运行，在很多场景下，其表现还略优于ParallelGC的并行Ful1GC实现。</li>
<li>即使是SerialGC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在serverless等新的应用场景下，Serial Gc找到了新的舞台。</li>
<li>比较不幸的是CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除</li>
<li>现在G1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和Shenandoah（Open JDK12），其特点：主打低停顿时间</li>
</ol>
<h3 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h3><p><strong>Open JDK12的Shenandoash GC：低停顿时间的GC（实验性）</strong></p>
<ol>
<li><p>Shenandoah无疑是众多GC中最孤独的一个。是第一款不由Oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的受到官方的排挤。比如号称openJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。</p>
</li>
<li><p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。</p>
</li>
<li><p>Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
</li>
</ol>
<p>这是RedHat在2016年发表的论文数据，测试内容是使用ES对200GB的维基百科数据进行索引。从结果看：</p>
<ol>
<li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li>
<li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0039.png">

<p>总结</p>
<ol>
<li>Shenandoah GC的弱项：高运行负担下的吞吐量下降。</li>
<li>Shenandoah GC的强项：低延迟时间。</li>
</ol>
<h3 id="令人震惊、革命性的-ZGC"><a href="#令人震惊、革命性的-ZGC" class="headerlink" title="令人震惊、革命性的 ZGC"></a>令人震惊、革命性的 ZGC</h3><ol>
<li><p>官方文档：<a href="https://docs.oracle.com/en/java/javase/12/gctuning/">https://docs.oracle.com/en/java/javase/12/gctuning/</a></p>
</li>
<li><p>ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</p>
</li>
<li><p>《深入理解Java虚拟机》一书中这样定义ZGC：ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了**<code>读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法</code><strong>的，以</strong>低延迟**为首要目标的一款垃圾收集器。</p>
</li>
<li><p>ZGC的工作过程可以分为4个阶段：<strong>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</strong> 等。</p>
</li>
<li><p>ZGC几乎在所有地方并发执行的，除了<strong>0</strong>的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p>
</li>
</ol>
<p><strong>吞吐量</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0040.png">

<p>max-JOPS：以低延迟为首要前提下的数据</p>
<p>critical-JOPS：不考虑低延迟下的数据</p>
<p><strong>低延迟</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0041.png">

<p>在ZGC的强项停顿时间测试上，它毫不留情的将Parallel、G1拉开了两个数量级的差距。无论平均停顿、95%停顿、998停顿、99. 98停顿，还是最大停顿时间，ZGC都能毫不费劲控制在10毫秒以内。</p>
<p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0042.png">



<ol>
<li><p>JDK14之前，ZGC仅Linux才支持。</p>
</li>
<li><p>尽管许多使用ZGC的用户都使用类Linux的环境，但在Windows和macOS上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macOS上。</p>
</li>
<li><p>现在mac或Windows上也能使用ZGC了，示例如下：</p>
<p>-XX:+UnlockExperimentalVMOptions-XX：+UseZGC</p>
</li>
</ol>
<h3 id="面向大堆的-AliGC"><a href="#面向大堆的-AliGC" class="headerlink" title="面向大堆的 AliGC"></a>面向大堆的 AliGC</h3><p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_012/0043.png">]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>类加载器子系统</title>
    <url>/2021/12/05/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="第2章-类加载子系统"><a href="#第2章-类加载子系统" class="headerlink" title="第2章-类加载子系统"></a>第2章-类加载子系统</h1><h2 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h2><h3 id="简图"><a href="#简图" class="headerlink" title="简图"></a>简图</h3><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0001.png">

<h3 id="详细图"><a href="#详细图" class="headerlink" title="详细图"></a>详细图</h3><p>英文版</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0002.jpg">



<p>中文版</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0003.jpg">

<p>注意：方法区只有HotSpot虚拟机有，J9，JRockit都没有</p>
<p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p>
<ol>
<li>类加载器</li>
<li>执行引擎</li>
</ol>
<h2 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h2><p><strong>类加载器子系统作用：</strong></p>
<ol>
<li><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。”<strong>CAFEBABE</strong>“</p>
</li>
<li><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p>
</li>
<li><p><strong>加载的类信息存放于一块称为方法区的内存空间</strong>。除了类的信息外，方法区(<strong>元空间</strong>)中还会存放运行时<strong>常量池信息</strong>，可能还包括<strong>字符串字面量</strong>和<strong>数字常量</strong>（这部分<strong>常量信息是Class文件中常量池部分的内存映射</strong>）</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0004.png">



<h2 id="类加载器ClassLoader角色"><a href="#类加载器ClassLoader角色" class="headerlink" title="类加载器ClassLoader角色"></a>类加载器ClassLoader角色</h2><ol>
<li>class file（在下图中就是Car.class文件）存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li>
<li>class file加载到JVM中，被称为<strong>DNA元数据模板</strong>（在下图中就是内存中的Car Class），放在方法区。</li>
<li>在**.class文件–&gt;JVM–&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader）**，扮演一个快递员的角色。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0005.png">

<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;谢谢ClassLoader加载我....&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;你的大恩大德，我下辈子再报！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>它的加载过程是怎么样的呢?</p>
<ul>
<li>执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader</li>
<li>加载成功，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main</li>
<li>加载失败则抛出异常</li>
</ul>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0006.png">

<p>完整的流程图如下所示：</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0007.png">



<h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p><strong>加载：</strong></p>
<ol>
<li><p><strong>通过一个类的全限定名获取定义此类的二进制字节流</strong></p>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为方法区的<strong>运行时数据结构</strong></p>
</li>
<li><p><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</p>
</li>
</ol>
<p><strong>加载class文件的方式：</strong></p>
<ol>
<li>从<code>本地系统中直接加载</code></li>
<li>通过网络获取，典型场景：Web Applet</li>
<li>从zip压缩包中读取，成为日后<code>jar、war</code>格式的基础</li>
<li>运行时计算生成，使用最多的是：<code>动态代理技术</code></li>
<li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li>
<li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li>
</ol>
<h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><p>链接分为三个子阶段：<strong>验证</strong> -&gt; <strong>准备</strong> -&gt; <strong>解析</strong></p>
<h4 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证(Verify)"></a>验证(Verify)</h4><ol>
<li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li>
<li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li>
</ol>
<p><strong>举例</strong></p>
<p>使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0008.png">

<h4 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备(Prepare)"></a>准备(Prepare)</h4><p><code>只给变量，不会执行static方法</code></p>
<ol>
<li>为<strong>类变量</strong>（static变量）分配内存并且设置该类变量的默认初始值，即零值</li>
<li>这里不包含用<strong>final修饰的static</strong>，因为final在<strong>编译</strong>的时候就会分配好了默认值，准备阶段会显式初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> a 虽然存在 ConstantValue 但还是得去&lt;init&gt;方法中初始化</span><br><span class="line"></span><br><span class="line">而 <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> b 却不需要</span><br><span class="line"></span><br><span class="line">现在结果很明显了，他在类实例化时发生的初始化</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注意：这里<code>不会</code>为<strong>实例变量</strong>（静态变量前要加static关键字，而实例变量前则不加。）分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java<strong>堆</strong>中</li>
</ol>
<p><strong>举例</strong></p>
<p>代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloApp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//prepare：a = 0 ---&gt; initial : a = 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析(Resolve)"></a>解析(Resolve)</h4><ol>
<li><p><strong>将常量池内的符号引用转换为直接引用的过程</strong></p>
</li>
<li><p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</p>
</li>
<li><p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p>
</li>
<li><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p>
</li>
</ol>
<p><strong>符号引用</strong></p>
<ul>
<li>反编译 class 文件后可以查看符号引用，下面带# 的就是符号引用</li>
</ul>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0023.png"/>

<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p><code>&lt;cinit&gt;&amp;&lt;init&gt;</code></p>
<p><code>一个是类的初始化方法&lt;clinit&gt;, 另一个是实例的初始化方法&lt;init&gt;</code></p>
<h4 id="类的初始化时机"><a href="#类的初始化时机" class="headerlink" title="类的初始化时机"></a>类的初始化时机</h4><p>到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化</p>
<ol>
<li><p>创建类的实例 <code>new、getstatic、putstatic、invokestatic</code></p>
</li>
<li><p>访问某个类或接口的静态变量，或者对该静态变量赋值(被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候</p>
</li>
<li><p>调用类的静态方法</p>
</li>
<li><p>反射（比如：Class.forName(“com.atguigu.Test”)）</p>
<p>使用 <code>java.lang.reflect</code>包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</p>
</li>
<li><p>初始化一个类的子类,如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
</li>
<li><p>Java虚拟机启动时被标明为启动类的类,当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p>
</li>
<li><p>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</p>
</li>
</ol>
<p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）</p>
<h4 id="clinit-lt-执行带static的东西"><a href="#clinit-lt-执行带static的东西" class="headerlink" title="clinit() &lt;- 执行带static的东西"></a>clinit() &lt;- <code>执行带static的东西</code></h4><p><code>一个是类的初始化方法&lt;clinit&gt;</code></p>
<p><code>&lt;clinit()&gt;是类构造器方法，&lt;init()&gt;是类的构造器</code></p>
<ol>
<li><p>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程<code>准备阶段赋初值（0，\u0000,FALSE...），这个阶段赋用户定义的值</code></p>
</li>
<li><p>此方法不需定义，是javac编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和静态代码块中的<code>语句</code>合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法</p>
</li>
<li><p><code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</p>
</li>
<li><p><code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：类的构造器是虚拟机视角下的<code>&lt;init&gt;()</code>比如说 public myList(){}）</p>
</li>
<li><p>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</p>
</li>
<li><p>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</p>
</li>
</ol>
<blockquote>
<p>IDEA 中安装 JClassLib Bytecode viewer 插件，可以很方便的看字节码。安装过程可以自行百度</p>
</blockquote>
<h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><p><code>实例的初始化方法</code></p>
<p>实例化途径4种：</p>
<ul>
<li>调用new操作符；</li>
<li>调用Class或java.lang.reflect.Constructor对象的newInstance()方法；</li>
<li>调用任何现有对象的clone()方法；</li>
<li>通过java.io.ObjectInputStream类的getObject()方法反序列化。</li>
</ul>
<blockquote>
<p>会调用哪些</p>
</blockquote>
<ol>
<li>父类变量初始化</li>
<li>父类语句块</li>
<li>父类构造函数</li>
<li>子类变量初始化</li>
<li>子类语句块</li>
<li>子类构造函数</li>
</ol>
<h4 id="1，2，3说明"><a href="#1，2，3说明" class="headerlink" title="1，2，3说明"></a>1，2，3说明</h4><p><strong>举例1：有static变量</strong></p>
<p>查看下面这个代码的字节码，可以发现有一个<code>&lt;clinit&gt;()</code>方法。</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0009.png">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassInitTest</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       num = <span class="number">2</span>;</span><br><span class="line">       number = <span class="number">20</span>;</span><br><span class="line">       System.out.println(num);</span><br><span class="line">       <span class="comment">//System.out.println(number);//报错：非法的前向引用。</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1、linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span></span><br><span class="line"><span class="comment">    * 2、这里因为静态代码块出现在声明变量语句前面，所以之前被准备阶段为0的number变量会</span></span><br><span class="line"><span class="comment">    * 首先被初始化为20，再接着被初始化成10（这也是面试时常考的问题哦）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ClassInitTest.num);<span class="comment">//2</span></span><br><span class="line">        System.out.println(ClassInitTest.number);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&lt;clint字节码&gt;：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> <span class="number">1</span> putstatic #<span class="number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"> <span class="number">4</span> iconst_2</span><br><span class="line"> <span class="number">5</span> putstatic #<span class="number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"> <span class="number">8</span> bipush <span class="number">20</span>	 <span class="comment">//先赋20</span></span><br><span class="line"><span class="number">10</span> putstatic #<span class="number">5</span> &lt;com/atguigu/java/ClassInitTest.number&gt;</span><br><span class="line"><span class="number">13</span> getstatic #<span class="number">2</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">16</span> getstatic #<span class="number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"><span class="number">19</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">22</span> bipush <span class="number">10</span>	<span class="comment">//再赋10</span></span><br><span class="line"><span class="number">24</span> putstatic #<span class="number">5</span> &lt;com/atguigu/java/ClassInitTest.number&gt;</span><br><span class="line"><span class="number">27</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<p>当我们代码中包含static变量的时候，就会有clinit方法</p>
<p><strong>举例2：无 static 变量</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0010.png">

<p>加上之后就有了</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0011.png">

<h4 id="4说明"><a href="#4说明" class="headerlink" title="4说明"></a>4说明</h4><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0012.png">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Public <span class="keyword">class</span> <span class="title class_">ClinitTest</span>&#123; <span class="comment">//为什么此时没有new ClinitTest，这个类也会被初始化呢？因为这个类是启动类(main())</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//&lt;init&gt;</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">//&lt;cinit&gt;</span></span><br><span class="line">	ClinitTest()&#123; <span class="comment">//&lt;init&gt;</span></span><br><span class="line">		a=<span class="number">10</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在构造器中：</p>
<ul>
<li>先将类变量 a 赋值为 10</li>
<li>再将局部变量赋值为 20</li>
</ul>
<h4 id="5说明"><a href="#5说明" class="headerlink" title="5说明"></a>5说明</h4><p>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0013.png">

<p>如上代码，加载流程如下：</p>
<ul>
<li>首先，执行 main() 方法需要加载 ClinitTest1 类</li>
<li>获取 Son.B 静态变量，需要加载 Son 类</li>
<li>Son 类的父类是 Father 类，所以需要先执行 Father 类的加载，再执行 Son 类的加载</li>
</ul>
<h4 id="6说明"><a href="#6说明" class="headerlink" title="6说明"></a>6说明</h4><p>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">            <span class="type">DeadThread</span> <span class="variable">dead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadThread</span>();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeadThread</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;初始化当前类&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程2开始</span><br><span class="line">线程1开始</span><br><span class="line">线程2初始化当前类</span><br><span class="line"></span><br><span class="line">/然后程序卡死了</span><br></pre></td></tr></table></figure>



<p>程序卡死，分析原因：</p>
<ul>
<li>两个线程同时去加载 DeadThread 类，而 DeadThread 类中静态代码块中有一处死循环</li>
<li>先加载 DeadThread 类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放</li>
<li>所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次）</li>
</ul>
<h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</p>
</li>
<li><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></p>
</li>
<li><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0014.png">



<p><strong>ExtClassLoader</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0015.png">

<p><strong>AppClassLoader</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0016.png">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取其上层：获取不到引导类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>我们尝试获取引导类加载器，获取到的值为 null ，这并不代表引导类加载器不存在，<strong>因为引导类加载器右 C&#x2F;C++ 语言，我们获取不到</strong></li>
<li>两次获取系统类加载器的值都相同：sun.misc.Launcher$AppClassLoader@18b4aac2 ，这说明<strong>系统类加载器是全局唯一的</strong></li>
</ul>
<h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><blockquote>
<p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p>
</blockquote>
<ol>
<li>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部</li>
<li>它用来加载<strong>Java的核心库</strong>（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li>
<li>并不继承自java.lang.ClassLoader，没有父加载器</li>
<li>加载扩展类和应用程序类加载器，并作为他们的父类加载器</li>
<li>出于安全考虑，Bootstrap启动类加载器只加载包名为<strong>java</strong>、<strong>javax</strong>、<strong>sun</strong>等开头的类</li>
</ol>
<h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><blockquote>
<p><strong>扩展类加载器（Extension ClassLoader）</strong></p>
</blockquote>
<ol>
<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为启动类加载器</li>
<li>从<strong>java.ext.dirs</strong>系统属性所指定的目录中<strong>加载类库</strong>，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li>
</ol>
<h4 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h4><blockquote>
<p><strong>应用程序类加载器（也称为系统类加载器，AppClassLoader）</strong></p>
</blockquote>
<ol>
<li>Java语言编写，由sun.misc.LaunchersAppClassLoader实现</li>
<li>派生于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li>
<li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li>
<li>通过classLoader.getSystemclassLoader()方法可以获取到该类加载器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;**********启动类加载器**************&quot;</span>);</span><br><span class="line">        <span class="comment">//获取BootstrapClassLoader能够加载的api的路径</span></span><br><span class="line">        URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL element : urLs) &#123;</span><br><span class="line">            System.out.println(element.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Provider.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;***********扩展类加载器*************&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">extDirs</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String path : extDirs.split(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> CurveDB.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>输出结果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**********启动类加载器**************</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/resources.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/rt.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/sunrsasign.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/jsse.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/jce.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/charsets.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/lib/jfr.jar</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1<span class="number">.8</span><span class="number">.0_131</span>/jre/classes</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">***********扩展类加载器*************</span><br><span class="line">C:\Program Files\Java\jdk1<span class="number">.8</span><span class="number">.0_131</span>\jre\lib\ext</span><br><span class="line">C:\Windows\Sun\Java\lib\ext</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@29453f44</span><br></pre></td></tr></table></figure>



<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><h4 id="什么时候需要自定义类加载器？"><a href="#什么时候需要自定义类加载器？" class="headerlink" title="什么时候需要自定义类加载器？"></a>什么时候需要自定义类加载器？</h4><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那为什么还需要自定义类加载器？</p>
<ol>
<li>隔离加载类（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间价之间是隔离的）</li>
<li>修改类加载的方式</li>
<li>扩展加载源（还可以考虑从数据库中加载类，路由器等等不同的地方）</li>
<li>防止源码泄漏（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密）</li>
</ol>
<h4 id="如何自定义类加载器？"><a href="#如何自定义类加载器？" class="headerlink" title="如何自定义类加载器？"></a>如何自定义类加载器？</h4><ol>
<li>开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findclass()方法中</li>
<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li>
</ol>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//defineClass和findClass搭配使用</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, result, <span class="number">0</span>, result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//自定义流的获取方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getClassFromCustomPath(String name) &#123;</span><br><span class="line">        <span class="comment">//从自定义路径中加载指定类:细节略</span></span><br><span class="line">        <span class="comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">customClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;One&quot;</span>, <span class="literal">true</span>, customClassLoader);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h3><blockquote>
<p><strong>ClassLoader 类介绍</strong></p>
</blockquote>
<p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0017.png">

<p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0018.png">

<h4 id="获取ClassLoader途径"><a href="#获取ClassLoader途径" class="headerlink" title="获取ClassLoader途径"></a>获取ClassLoader途径</h4><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0019.png">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">            <span class="comment">//2.</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">            System.out.println(classLoader1);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader2</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">            System.out.println(classLoader2);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">null</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1540e19d</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>



<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><h3 id="双亲委派机制原理"><a href="#双亲委派机制原理" class="headerlink" title="双亲委派机制原理"></a>双亲委派机制原理</h3><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，<strong>也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。</strong>而且<strong>加载某个类的class文件时</strong>，Java虚拟机采用的是<strong>双亲委派模式</strong>，即把请求交由父类处理，它是一种<strong>任务委派</strong>模式</p>
<ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
<li>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0020.png">

<h3 id="双亲委派机制代码演示"><a href="#双亲委派机制代码演示" class="headerlink" title="双亲委派机制代码演示"></a>双亲委派机制代码演示</h3><h4 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h4><p>1、我们自己建立一个 java.lang.String 类，写上 static 代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2、在另外的程序中加载 String 类，看看加载的 String 类是 JDK 自带的 String 类，还是我们自己编写的 String 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        java.lang.<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.lang.String();</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,atguigu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">StringTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest</span>();</span><br><span class="line">        System.out.println(test.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello,atguigu.com</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>



<p>程序并没有输出我们静态代码块中的内容，可见仍然加载的是 JDK 自带的 String 类。</p>
<p>把刚刚的类改一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0021.png">

<p>由于双亲委派机制一直找父类，所以最后找到了Bootstrap ClassLoader，Bootstrap ClassLoader找到的是 JDK 自带的 String 类，在那个String类中并没有 main() 方法，所以就报了上面的错误。</p>
<h4 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShkStart</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.SecurityException: Prohibited <span class="keyword">package</span> name: java.lang</span><br><span class="line">	at java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="number">662</span>)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">761</span>)</span><br><span class="line">	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:<span class="number">142</span>)</span><br><span class="line">	at java.net.URLClassLoader.defineClass(URLClassLoader.java:<span class="number">467</span>)</span><br><span class="line">	at java.net.URLClassLoader.access$<span class="number">100</span>(URLClassLoader.java:<span class="number">73</span>)</span><br><span class="line">	at java.net.URLClassLoader$<span class="number">1.</span>run(URLClassLoader.java:<span class="number">368</span>)</span><br><span class="line">	at java.net.URLClassLoader$<span class="number">1.</span>run(URLClassLoader.java:<span class="number">362</span>)</span><br><span class="line">	at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">	at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">361</span>)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>)</span><br><span class="line">	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">335</span>)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:<span class="number">495</span>)</span><br><span class="line">Error: A JNI error has occurred, please check your installation and <span class="keyword">try</span> again</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> </span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>即使类名没有重复，也禁止使用java.lang这种包名。这是一种保护机制</p>
<h4 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a>举例3</h4><p>当我们加载jdbc.jar 用于实现数据库连接的时候</p>
<ol>
<li>我们现在程序中需要用到SPI接口，而SPI接口属于rt.jar包中Java核心api</li>
<li>然后使用双清委派机制，引导类加载器把rt.jar包加载进来，而rt.jar包中的SPI存在一些接口，接口我们就需要具体的实现类了</li>
<li>具体的实现类就涉及到了某些第三方的jar包了，比如我们加载SPI的实现类jdbc.jar包【首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的】</li>
<li>第三方的jar包中的类属于系统类加载器来加载</li>
<li>从这里面就可以看到SPI核心接口由引导类加载器来加载，SPI具体实现类由系统类加载器来加载</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_002/0022.png">



<h3 id="双亲委派机制优势"><a href="#双亲委派机制优势" class="headerlink" title="双亲委派机制优势"></a>双亲委派机制优势</h3><p>通过上面的例子，我们可以知道，双亲机制可以</p>
<ol>
<li><p>避免类的重复加载</p>
</li>
<li><p>保护程序安全，防止核心API被随意篡改</p>
<ul>
<li>自定义类：自定义java.lang.String 没有被加载。</li>
<li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li>
</ul>
</li>
</ol>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><ol>
<li>自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。</li>
<li>这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="如何判断两个class对象是否相同？"><a href="#如何判断两个class对象是否相同？" class="headerlink" title="如何判断两个class对象是否相同？"></a>如何判断两个class对象是否相同？</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p>
<ol>
<li>类的完整类名必须一致，包括包名</li>
<li><strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></li>
<li>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</li>
</ol>
<h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><ol>
<li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li>
<li><strong>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong></li>
<li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的（后面讲）</li>
</ol>
<h2 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h2><p><img src="/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20220216161858172.png" alt="image-20220216161858172"></p>
<p><code>注意</code>：其中<code>#2</code>是访问某个类或者接口的<strong>非final类型</strong>的<code>静态变量</code>&#x2F;对该<code>静态变量赋值</code></p>
<blockquote>
<p>A:因为final类型的基本类型的静态变量会在编译器就加入常量池，不需要主动使用类对类进行初始化，可以直接调用</p>
<p>链接：</p>
<p><a href="https://blog.csdn.net/tiantiandjava/article/details/86505855">JVM 编译优化 静态常量会被添加到当前类的“常量池”中，无需加载引用类（常量不加载&#x2F;常量找不到&#x2F;常量不更新）</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟机栈</title>
    <url>/2021/12/05/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</url>
    <content><![CDATA[<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="虚拟机栈的出现背景"><a href="#虚拟机栈的出现背景" class="headerlink" title="虚拟机栈的出现背景"></a>虚拟机栈的出现背景</h3><ol>
<li>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。</li>
<li>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</li>
</ol>
<h3 id="内存中的栈与堆"><a href="#内存中的栈与堆" class="headerlink" title="内存中的栈与堆"></a>内存中的栈与堆</h3><ol>
<li>首先栈是<strong>运行时</strong>的单位，而堆是<strong>存储</strong>的单位。</li>
<li>即：栈解决程序的运行问题，即<strong>程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</strong></li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0001.png">



<h3 id="虚拟机栈基本内容"><a href="#虚拟机栈基本内容" class="headerlink" title="虚拟机栈基本内容"></a>虚拟机栈基本内容</h3><ul>
<li><p>Java虚拟机栈是什么？</p>
<ul>
<li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用</strong>，栈是线程私有的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StackTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackTest</span>();</span><br><span class="line">        test.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0002.png">

<ul>
<li><p>虚拟机栈的生命周期</p>
<ul>
<li>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</li>
</ul>
</li>
<li><p>虚拟机栈的作用</p>
<ul>
<li>主管Java程序的运行，它保<strong>存方法的局部变量（8 种基本数据类型、对象的引用地址）</strong>、<strong>部分结果，并参与方法的调用和返回。</strong></li>
<li><strong>局部变量</strong>，它是相比于成员变量来说的（或属性）</li>
<li><strong>基本数据类型变量</strong> VS <strong>引用类型变量（类、数组、接口</strong>）</li>
</ul>
</li>
</ul>
<h3 id="虚拟机栈的特点"><a href="#虚拟机栈的特点" class="headerlink" title="虚拟机栈的特点"></a>虚拟机栈的特点</h3><ul>
<li><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p>
</li>
<li><p>JVM直接对Java栈的操作只有两个：</p>
<ul>
<li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li>
<li>执行结束后的<strong>出栈</strong>工作</li>
</ul>
</li>
<li><p>对于栈来说不存在垃圾回收问题</p>
<ul>
<li>栈不需要GC，但是可能存在<strong>OOM</strong></li>
</ul>
</li>
</ul>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0003.png">

<h3 id="虚拟机栈的异常"><a href="#虚拟机栈的异常" class="headerlink" title="虚拟机栈的异常"></a>虚拟机栈的异常</h3><p><strong>面试题：栈中可能出现的异常？</strong></p>
<ul>
<li><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p>
<ul>
<li><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。</p>
</li>
<li><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。</p>
</li>
</ul>
</li>
</ul>
<h3 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>多去官方文档看看：<a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></p>
<p>地址经常变</p>
</blockquote>
<p>我们可以使用参数 <strong>-Xss</strong> 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p>
<blockquote>
<p>Sets the thread stack size (in bytes). Append the letter <code>k</code> or <code>K</code> to indicate KB, <code>m</code> or <code>M</code> to indicate MB, and <code>g</code> or <code>G</code> to indicate GB. The default value depends on the platform:</p>
<ul>
<li>Linux&#x2F;x64 (64-bit): 1024 KB</li>
<li>macOS (64-bit): 1024 KB</li>
<li>Oracle Solaris&#x2F;x64 (64-bit): 1024 KB</li>
<li>Windows: The default value depends on virtual memory</li>
</ul>
</blockquote>
<p>The following examples set the thread stack size to 1024 KB in different units:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure>

<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackErrorTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        count++;</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>没设置参数前</strong></p>
<p>部分输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">11404</span></span><br><span class="line"><span class="number">11405</span></span><br><span class="line"><span class="number">11406</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">	at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:<span class="number">691</span>)</span><br></pre></td></tr></table></figure>

<p>说明栈在11406这个深度溢出了</p>
<p><strong>设置栈参数之后</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0004.png">

<p>部分输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2474</span></span><br><span class="line"><span class="number">2475</span></span><br><span class="line"><span class="number">2476</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">	at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:<span class="number">77</span>)</span><br></pre></td></tr></table></figure>

<p>说明参数起作用了</p>
<h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h3><ol>
<li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在</li>
<li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li>
</ol>
<h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><ol>
<li><p>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</p>
</li>
<li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。<strong>即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的</strong>。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></p>
</li>
<li><p><strong>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</strong></p>
</li>
<li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0005.png">

<ol>
<li><strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li>
<li>Java方法有两种返回函数的方式。<ul>
<li>一种是正常的函数返回，使用return指令。</li>
<li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li>
<li>但不管使用哪种方式，都会导致栈帧被弹出。</li>
</ul>
</li>
</ol>
<h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p>
<ul>
<li><p><strong>局部变量表</strong>（Local Variables）</p>
</li>
<li><p><strong>操作数栈</strong>（Operand Stack）（或表达式栈）</p>
</li>
<li><p><strong>动态链接</strong>（Dynamic Linking）（或指向运行时常量池的方法引用）</p>
</li>
<li><p><strong>方法返回地址</strong>（Return Address）（或方法正常退出或者异常退出的定义）</p>
</li>
<li><p><strong>一些附加信息</strong></p>
</li>
</ul>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0006.png">

<p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0007.png">

<h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><h3 id="认识局部变量表"><a href="#认识局部变量表" class="headerlink" title="认识局部变量表"></a>认识局部变量表</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ol>
<li>局部变量表也被称之为<strong>局部变量数组</strong>或<strong>本地变量表</strong></li>
<li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li>
<li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</li>
<li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<ul>
<li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</li>
<li>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>
</ul>
</li>
<li>局部变量表中的变量只在当前方法调用中有效。<ul>
<li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li>
<li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li>
</ul>
</li>
</ol>
<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariablesTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//练习：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStatic</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class="line"><span class="comment">//        System.out.println(this.count);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关于Slot的使用的理解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LocalVariablesTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">        test2(date, name1);</span><br><span class="line">        System.out.println(date + name1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(Date dateP, String name2)</span> &#123;</span><br><span class="line">        dateP = <span class="literal">null</span>;</span><br><span class="line">        name2 = <span class="string">&quot;songhongkang&quot;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">130.5</span>;<span class="comment">//占据两个slot</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> dateP + name2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            b = a + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0008.png">

<p>看完字节码后，可得结论：所以局部变量表所需的容量大小是在编译期确定下来的。</p>
<h4 id="部分详解"><a href="#部分详解" class="headerlink" title="部分详解"></a>部分详解</h4><p>为了更好讲解，我们直接用jclasslib来看字节码，以main方法为例来讲解。一些一目了然的就不讲了</p>
<p>1、0-15  也就是有16行字节码</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0009.png">



<p>2、方法异常信息表</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0010.png">

<p>3、Misc</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0011.png">

<p>4、行号表</p>
<p>Java代码的行号和字节码指令行号的对应关系</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0012.png">



<p>5、注意：生效行数和剩余有效行数都是针对于字节码文件的行数</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0013.png">

<p>1、图中圈的东西表示该局部变量的作用域</p>
<p>2、Start PC&#x3D;&#x3D;11表示在字节码的11行开始生效，也就是Java代码对应的第15行。而声明int num在java代码的是第14行，说明是从声明的下一行开始生效</p>
<p>3、Length&#x3D;&#x3D; 5表示局部变量剩余有效行数，main方法字节码指令总共有16行，从11行开始生效，那么剩下就是16-11 &#x3D;&#x3D;5。</p>
<p>4、<code>Ljava/lang/String</code>   前面的L表示引用类型</p>
<h3 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h3><ol>
<li>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</li>
<li>局部变量表，<strong>最基本的存储单元是Slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li>
<li>在局部变量表里，<strong>32位以内的类型只占用一个slot</strong>（包括returnAddress类型），<strong>64位的类型占用两个slot</strong>（1ong和double）。<ul>
<li>byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true</li>
<li>long和double则占据两个slot</li>
</ul>
</li>
<li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li>
<li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</li>
<li>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</li>
<li>如果<strong>当前帧是由构造方法或者实例方法创建的</strong>，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0014.png">

<h3 id="Slot代码示例"><a href="#Slot代码示例" class="headerlink" title="Slot代码示例"></a>Slot代码示例</h3><p><strong>this 存放在 index &#x3D; 0 的位置：</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.count++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>局部变量表：this 存放在 index &#x3D; 0 的位置</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0015.png">



<p><strong>64位的类型（1ong和double）占用两个slot</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(Date dateP, String name2)</span> &#123;</span><br><span class="line">      dateP = <span class="literal">null</span>;</span><br><span class="line">      name2 = <span class="string">&quot;songhongkang&quot;</span>;</span><br><span class="line">      <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">130.5</span>;<span class="comment">//占据两个slot</span></span><br><span class="line">      <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> dateP + name2;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>weight 为 double 类型，index 直接从 3 蹦到了 5</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0016.png">



<p><strong>static 无法调用 this</strong></p>
<p>this 不存在与 static 方法的局部变量表中，所以无法调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStatic</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class="line"><span class="comment">//        System.out.println(this.count);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        b = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部变量 c 重用了局部变量 b 的 slot 位置</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0017.png">



<h3 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">变量的分类：</span><br><span class="line"><span class="number">1</span>、按照数据类型分：① 基本数据类型  ② 引用数据类型</span><br><span class="line"><span class="number">2</span>、按照在类中声明的位置分：</span><br><span class="line">  <span class="number">2</span>-<span class="number">1</span>、成员变量：在使用前，都经历过默认初始化赋值</span><br><span class="line">       <span class="number">2</span>-<span class="number">1</span>-<span class="number">1</span>、类变量: linking的prepare阶段：给类变量默认赋值</span><br><span class="line">                ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值</span><br><span class="line">       <span class="number">2</span>-<span class="number">1</span>-<span class="number">2</span>、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</span><br><span class="line">  <span class="number">2</span>-<span class="number">2</span>、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</span><br></pre></td></tr></table></figure>



<ol>
<li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li>
<li>我们知道成员变量有两次初始化的机会<strong>，</strong>第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li>
<li>和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li>
</ol>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ol>
<li><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p>
</li>
<li><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
</li>
</ol>
<h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><h3 id="操作数栈的特点"><a href="#操作数栈的特点" class="headerlink" title="操作数栈的特点"></a>操作数栈的特点</h3><ol>
<li><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</p>
</li>
<li><p>操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）</p>
</li>
</ol>
<ul>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，</li>
<li>比如：执行复制、交换、求和等操作</li>
</ul>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0018.png">





<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0019.png">



<h3 id="操作数栈的作用"><a href="#操作数栈的作用" class="headerlink" title="操作数栈的作用"></a>操作数栈的作用</h3><ol>
<li><p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</p>
</li>
<li><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。</p>
</li>
<li><p>每一个操作数栈都会<strong>拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了</strong>，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</p>
</li>
<li><p>栈中的任何一个元素都是可以任意的Java数据类型</p>
<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
</li>
<li><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></p>
</li>
<li><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并<strong>更新PC寄存器中下一条需要执行的字节码指令。</strong></p>
</li>
<li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p>
</li>
<li><p>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0020.jpg">

<p>局部变量表就相当于食材</p>
<p>操作数栈就相当于做法步骤</p>
<h2 id="操作数栈代码追踪"><a href="#操作数栈代码追踪" class="headerlink" title="操作数栈代码追踪"></a>操作数栈代码追踪</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//byte、short、char、boolean：都以int型来保存</span></span><br><span class="line">       <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// int m = 800;</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码指令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">15</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">8</span></span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> iload_1</span><br><span class="line"> <span class="number">7</span> iload_2</span><br><span class="line"> <span class="number">8</span> iadd</span><br><span class="line"> <span class="number">9</span> istore_3</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0021.png">

<h3 id="一步一步看流程"><a href="#一步一步看流程" class="headerlink" title="一步一步看流程"></a>一步一步看流程</h3><p>1、首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0022.png">

<p>2、执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），我们可以看到局部变量表的已经增加了一个元素。并且操作数栈为空了</p>
<ul>
<li>解释为什么局部变量表索引从 1 开始，因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this</li>
</ul>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0023.png">

<p>3、然后PC下移，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0024.png">



<p>4、然后从局部变量表中，依次将数据放在操作数栈中，等待执行 add 操作</p>
<p>iload_1：取出局部变量表中索引为1的数据入操作数栈</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0025.png">

<p>5、然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0026.png">



<h3 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h3><p><strong>关于类型转换的说明</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0027.png">



<ul>
<li>因为 8 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 8</li>
<li>但是存储在局部变量的时候，会转成 int 类型的变量：istore_4</li>
</ul>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0028.png">

<ul>
<li>m改成800之后，byte存储不了，就成了short型，sipush 800</li>
</ul>
<p><strong>如果被调用的方法带有返回值，返回值入操作数栈</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> m + n;</span><br><span class="line">      <span class="keyword">return</span> k;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetSum</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//获取上一个栈桢返回的结果，并保存在操作数栈中</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getSum();</span><br><span class="line">      <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>getSum() 方法字节码指令：最后带着个 ireturn</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0029.png">

<p>testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值()</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0030.png">





<h2 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h2><p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p>
<ol>
<li><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读&#x2F;写次数多，效率不高。</p>
</li>
<li><p>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</strong></p>
</li>
<li><p>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</p>
</li>
</ol>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p><strong>动态链接（或<code>指向运行时常量池的方法引用</code>）</strong></p>
<ol>
<li><p>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</p>
</li>
<li><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicLinkingTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodB()....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        methodA();</span><br><span class="line"></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter05/com/atguigu/java1/DynamicLinkingTest.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2020</span>-<span class="number">11</span>-<span class="number">10</span>; size <span class="number">712</span> bytes</span><br><span class="line">  MD5 checksum e56913c945f897c7ee6c0a608629bca8</span><br><span class="line">  Compiled from <span class="string">&quot;DynamicLinkingTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.atguigu.java1.DynamicLinkingTest</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">9.</span>#<span class="number">23</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">8.</span>#<span class="number">24</span>         <span class="comment">// com/atguigu/java1/DynamicLinkingTest.num:I</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">25.</span>#<span class="number">26</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">4</span> = String             #<span class="number">27</span>            <span class="comment">// methodA()....</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">28.</span>#<span class="number">29</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">6</span> = String             #<span class="number">30</span>            <span class="comment">// methodB()....</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">8.</span>#<span class="number">31</span>         <span class="comment">// com/atguigu/java1/DynamicLinkingTest.methodA:()V</span></span><br><span class="line">   #<span class="number">8</span> = Class              #<span class="number">32</span>            <span class="comment">// com/atguigu/java1/DynamicLinkingTest</span></span><br><span class="line">   #<span class="number">9</span> = Class              #<span class="number">33</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               num</span><br><span class="line">  #<span class="number">11</span> = Utf8               I</span><br><span class="line">  #<span class="number">12</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">13</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">14</span> = Utf8               Code</span><br><span class="line">  #<span class="number">15</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">16</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">17</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">18</span> = Utf8               Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line">  #<span class="number">19</span> = Utf8               methodA</span><br><span class="line">  #<span class="number">20</span> = Utf8               methodB</span><br><span class="line">  #<span class="number">21</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">22</span> = Utf8               DynamicLinkingTest.java</span><br><span class="line">  #<span class="number">23</span> = NameAndType        #<span class="number">12</span>:#<span class="number">13</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">24</span> = NameAndType        #<span class="number">10</span>:#<span class="number">11</span>        <span class="comment">// num:I</span></span><br><span class="line">  #<span class="number">25</span> = Class              #<span class="number">34</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">26</span> = NameAndType        #<span class="number">35</span>:#<span class="number">36</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">27</span> = Utf8               <span class="title function_">methodA</span><span class="params">()</span>....</span><br><span class="line">  #<span class="number">28</span> = Class              #<span class="number">37</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">29</span> = NameAndType        #<span class="number">38</span>:#<span class="number">39</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">30</span> = Utf8               <span class="title function_">methodB</span><span class="params">()</span>....</span><br><span class="line">  #<span class="number">31</span> = NameAndType        #<span class="number">19</span>:#<span class="number">13</span>        <span class="comment">// methodA:()V</span></span><br><span class="line">  #<span class="number">32</span> = Utf8               com/atguigu/java1/DynamicLinkingTest</span><br><span class="line">  #<span class="number">33</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">34</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">35</span> = Utf8               out</span><br><span class="line">  #<span class="number">36</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">37</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">38</span> = Utf8               println</span><br><span class="line">  #<span class="number">39</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.DynamicLinkingTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">7</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String methodA()....</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String methodB()....</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: aload_0</span><br><span class="line">         <span class="number">9</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method methodA:()V</span></span><br><span class="line">        <span class="number">12</span>: aload_0</span><br><span class="line">        <span class="number">13</span>: dup</span><br><span class="line">        <span class="number">14</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">        <span class="number">17</span>: iconst_1</span><br><span class="line">        <span class="number">18</span>: iadd</span><br><span class="line">        <span class="number">19</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">16</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">22</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">23</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;DynamicLinkingTest.java&quot;</span></span><br></pre></td></tr></table></figure>



<p>1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？</p>
<p>2、往上面翻，找到常量池的定义：<code>#7 = Methodref #8.#31</code></p>
<ul>
<li>先找 #8 ：<ul>
<li><code>#8 = Class #32</code> ：去找 #32</li>
<li><code>#32 = Utf8 com/atguigu/java1/DynamicLinkingTest</code></li>
<li>结论：通过 #8 我们找到了 <code>DynamicLinkingTest</code> 这个类</li>
</ul>
</li>
<li>再来找 #31：<ul>
<li><code>#31 = NameAndType #19:#13</code> ：去找 #19 和 #13</li>
<li><code>#19 = Utf8 methodA</code> ：方法名为 methodA</li>
<li><code>#13 = Utf8 ()V</code> ：方法没有形参，返回值为 void</li>
</ul>
</li>
</ul>
<p>3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用</p>
<p>4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0031.png">



<p><strong>为什么要用常量池呢？</strong></p>
<ol>
<li><p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</p>
</li>
<li><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p>
</li>
</ol>
<h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><h3 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<ul>
<li><strong>静态链接</strong>：</li>
</ul>
<p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p>
<ul>
<li><strong>动态链接</strong>：</li>
</ul>
<p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p>
<h3 id="早期绑定与晚期绑定"><a href="#早期绑定与晚期绑定" class="headerlink" title="早期绑定与晚期绑定"></a>早期绑定与晚期绑定</h3><blockquote>
<p>静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。</p>
</blockquote>
<p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p>
<ul>
<li><strong>早期绑定</strong></li>
</ul>
<p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p>
<ul>
<li><strong>晚期绑定</strong></li>
</ul>
<p>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物进食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Huntable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Huntable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，多管闲事&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Huntable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.eat();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，天经地义&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAnimal</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        animal.eat();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showHunt</span><span class="params">(Huntable h)</span> &#123;</span><br><span class="line">        h.hunt();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>部分字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java2.AnimalTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">54</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAnimal</span><span class="params">(com.atguigu.java2.Animal)</span>;</span><br><span class="line">    descriptor: (Lcom/atguigu/java2/Animal;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         <span class="number">1</span>: invokevirtual #<span class="number">2</span>                  <span class="comment">// Method com/atguigu/java2/Animal.eat:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">56</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">57</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">1</span> animal   Lcom/atguigu/java2/Animal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showHunt</span><span class="params">(com.atguigu.java2.Huntable)</span>;</span><br><span class="line">    descriptor: (Lcom/atguigu/java2/Huntable;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         <span class="number">1</span>: invokeinterface #<span class="number">3</span>,  <span class="number">1</span>            <span class="comment">// InterfaceMethod com/atguigu/java2/Huntable.hunt:()V</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">60</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">61</span>: <span class="number">6</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">1</span>     h   Lcom/atguigu/java2/Huntable;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;AnimalTest.java&quot;</span></span><br></pre></td></tr></table></figure>



<p>invokevirtual 体现为晚期绑定</p>
<p>invokeinterface 也体现为晚期绑定</p>
<p>invokespecial 体现为早期绑定</p>
<h3 id="多态与绑定"><a href="#多态与绑定" class="headerlink" title="多态与绑定"></a>多态与绑定</h3><ol>
<li><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持<strong>封装、继承和多态等面向对象特性</strong>，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p>
</li>
<li><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p>
</li>
</ol>
<h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><p><strong>虚方法与非虚方法的区别</strong></p>
<ol>
<li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li>
<li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li>
<li>其他方法称为虚方法。</li>
</ol>
<p><strong>子类对象的多态的使用前提：</strong></p>
<ol>
<li>类的继承关系</li>
<li>方法的重写</li>
</ol>
<p><strong>虚拟机中调用方法的指令</strong></p>
<ul>
<li><strong>普通指令：</strong></li>
</ul>
<ol>
<li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li>
<li>invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ol>
<ul>
<li><strong>动态调用指令</strong></li>
</ul>
<p>invokedynamic：动态解析出需要调用的方法，然后执行</p>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p>
<h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">showFinal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father show final&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showCommon</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father 普通方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是重写的父类的静态方法，因为静态方法不能被重写！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showPrivate</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son private&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        showStatic(<span class="string">&quot;atguigu.com&quot;</span>);</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        <span class="built_in">super</span>.showStatic(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        showPrivate(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">super</span>.showCommon();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//invokevirtual</span></span><br><span class="line">        showFinal();<span class="comment">//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。</span></span><br><span class="line">        <span class="comment">//虚方法如下：</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        invokevirtual  你没有显示的加super.，编译器认为你可能调用子类的showCommon(即使son子类没有重写，也		  会认为)，所以编译期间确定不下来，就是虚方法。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        showCommon();</span><br><span class="line">        info();</span><br><span class="line"></span><br><span class="line">        <span class="type">MethodInterface</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//invokeinterface</span></span><br><span class="line">        in.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Father f)</span> &#123;</span><br><span class="line">        f.showCommon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">so</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        so.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MethodInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Son 类中 show() 方法的字节码指令如下</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0032.png">



<h4 id="关于-invokedynamic-指令"><a href="#关于-invokedynamic-指令" class="headerlink" title="关于 invokedynamic 指令"></a>关于 invokedynamic 指令</h4><ol>
<li><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。</p>
</li>
<li><p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p>
</li>
<li><p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Func</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">func</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">(Func func)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lambda</span> <span class="variable">lambda</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lambda</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Func</span> <span class="variable">func</span> <span class="operator">=</span> s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        lambda.lambda(func);</span><br><span class="line"></span><br><span class="line">        lambda.lambda(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0033.png">





<h3 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a>动态语言和静态语言</h3><ol>
<li><p>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</p>
</li>
<li><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p>
</li>
</ol>
<p>Java：String info &#x3D; “mogu blog”;             (Java是静态类型语言的，会先编译就进行类型检查)<br>    JS：var name &#x3D; “shkstart”;    var name &#x3D; 10;    （运行时才进行检查）</p>
<pre><code>Python: info = 130.5 (运行时才检查)
</code></pre>
<h3 id="Java语言中方法重写的本质"><a href="#Java语言中方法重写的本质" class="headerlink" title="Java语言中方法重写的本质"></a>Java语言中方法重写的本质</h3><ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。<ul>
<li>如果通过则返回这个方法的直接引用，查找过程结束</li>
<li>如果不通过，则返回java.lang.IllegalAccessError 异常</li>
</ul>
</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ol>
<blockquote>
<p>上面这个过程称为<strong>动态分派</strong></p>
</blockquote>
<p><strong>IllegalAccessError介绍</strong></p>
<ol>
<li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li>
<li>比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突</li>
</ol>
<h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><ol>
<li><p>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现</strong>，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</p>
</li>
<li><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p>
</li>
<li><p>虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</p>
</li>
</ol>
<p><strong>例子1</strong></p>
<p>如图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0034.png">

<p>1、比如说son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。</p>
<p>2、下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程。</p>
<p><strong>例子2</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0035.png">



<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0036.jpg">

<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0037.jpg">



<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0038.jpg">



<h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0039.png">

<blockquote>
<p>在一些帖子里，方法返回地址、动态链接、一些附加信息  也叫做帧数据区</p>
</blockquote>
<ol>
<li><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而<strong>通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</strong></p>
</li>
<li><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，<strong>需要恢复上层方法的局部变量表、操作数栈</strong>、<strong>将返回值压入调用者栈帧的操作数栈</strong>、设置PC寄存器值等，让调用者方法继续执行下去。</p>
</li>
<li><p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</strong>。</p>
</li>
</ol>
<p><strong>方法退出的两种方式</strong></p>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法，</p>
<p><strong>正常退出：</strong></p>
<ol>
<li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</li>
<li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含：<ul>
<li><p>ireturn：当返回值是boolean，byte，char，short和int类型时使用</p>
</li>
<li><p>lreturn：Long类型</p>
</li>
<li><p>freturn：Float类型</p>
</li>
<li><p>dreturn：Double类型</p>
</li>
<li><p>areturn：引用类型</p>
</li>
<li><p>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</p>
</li>
</ul>
</li>
</ol>
<p><strong>异常退出：</strong></p>
<ol>
<li><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong>。</p>
</li>
<li><p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0040.png">



<p>异常处理表：</p>
<ul>
<li>反编译字节码文件，可得到 Exception table</li>
<li>from ：字节码指令起始地址</li>
<li>to ：字节码指令结束地址</li>
<li>target ：出现异常跳转至地址为 11 的指令执行</li>
<li>type ：捕获异常的类型</li>
</ul>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_004/0041.png">



<h2 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p>
<h2 id="栈相关面试题"><a href="#栈相关面试题" class="headerlink" title="栈相关面试题"></a>栈相关面试题</h2><h3 id="举例栈溢出的情况？"><a href="#举例栈溢出的情况？" class="headerlink" title="举例栈溢出的情况？"></a>举例栈溢出的情况？</h3><p>SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM</p>
<h3 id="调整栈大小，就能保证不出现溢出么？"><a href="#调整栈大小，就能保证不出现溢出么？" class="headerlink" title="调整栈大小，就能保证不出现溢出么？"></a>调整栈大小，就能保证不出现溢出么？</h3><p>不能保证不溢出，只能保证SOF出现的几率小</p>
<h3 id="分配的栈内存越大越好么？"><a href="#分配的栈内存越大越好么？" class="headerlink" title="分配的栈内存越大越好么？"></a>分配的栈内存越大越好么？</h3><p>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p>
<h3 id="垃圾回收是否涉及到虚拟机栈？"><a href="#垃圾回收是否涉及到虚拟机栈？" class="headerlink" title="垃圾回收是否涉及到虚拟机栈？"></a>垃圾回收是否涉及到虚拟机栈？</h3><p>不会</p>
<table>
<thead>
<tr>
<th>位置</th>
<th>是否有Error</th>
<th>是否存在GC</th>
</tr>
</thead>
<tbody><tr>
<td>PC计数器</td>
<td>无</td>
<td>不存在</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>有，SOF</td>
<td>不存在</td>
</tr>
<tr>
<td>本地方法栈(在HotSpot的实现中和虚拟机栈一样)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>堆</td>
<td>有，OOM</td>
<td>存在</td>
</tr>
<tr>
<td>方法区</td>
<td>有</td>
<td>存在</td>
</tr>
</tbody></table>
<h3 id="方法中定义的局部变量是否线程安全？"><a href="#方法中定义的局部变量是否线程安全？" class="headerlink" title="方法中定义的局部变量是否线程安全？"></a>方法中定义的局部变量是否线程安全？</h3><p>具体问题具体分析</p>
<ol>
<li>如果只有一个线程才可以操作此数据，则必是线程安全的。</li>
<li>如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</li>
</ol>
<p><strong>具体问题具体分析：</strong></p>
<ul>
<li>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题：</span></span><br><span class="line"><span class="comment"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   何为线程安全？</span></span><br><span class="line"><span class="comment"> *      如果只有一个线程才可以操作此数据，则必是线程安全的。</span></span><br><span class="line"><span class="comment"> *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s1的声明方式是线程安全的（只在方法内部用了）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//StringBuilder:线程不安全</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sBuilder的操作过程：是线程不安全的（作为参数传进来，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder sBuilder)</span>&#123;</span><br><span class="line">        sBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        sBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程不安全的（有返回值，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程安全的（s1自己消亡了，最后返回的只是s1.toString的一个新对象）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        method2(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>运行时数据区</title>
    <url>/2021/12/05/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    <content><![CDATA[<blockquote>
<p>此章把运行时数据区里比较少的地方讲一下。虚拟机栈，堆，方法区这些地方后续再讲。</p>
</blockquote>
<h1 id="运行时数据区概述及线程"><a href="#运行时数据区概述及线程" class="headerlink" title="运行时数据区概述及线程"></a>运行时数据区概述及线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_003/0001.png">

<p>当我们通过前面的：类的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_003/0002.png">

<p>类比一下也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品。</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_003/0003.png">



<h2 id="运行时数据区结构"><a href="#运行时数据区结构" class="headerlink" title="运行时数据区结构"></a>运行时数据区结构</h2><h3 id="运行时数据区与内存"><a href="#运行时数据区与内存" class="headerlink" title="运行时数据区与内存"></a>运行时数据区与内存</h3><ol>
<li><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>
</li>
<li><p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p>
</li>
</ol>
<blockquote>
<p>下图来自阿里巴巴手册JDK8</p>
</blockquote>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_003/0004.jpg">



<h3 id="线程的内存空间"><a href="#线程的内存空间" class="headerlink" title="线程的内存空间"></a>线程的内存空间</h3><ol>
<li><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区：其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与<strong>线程</strong>一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p>
</li>
<li><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p>
<ul>
<li>线程独有：独立包括程序计数器、栈、本地方法栈</li>
<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li>
</ul>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_003/0005.png">



<h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h3><p><strong>每个JVM只有一个Runtime实例</strong>。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_003/0006.png">



<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="JVM-线程"><a href="#JVM-线程" class="headerlink" title="JVM 线程"></a>JVM 线程</h3><ol>
<li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程<strong>并行</strong>的执行</li>
<li><strong>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射</strong><ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li>
</ul>
</li>
<li><strong>操作系统</strong>负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li>
</ol>
<blockquote>
<p>关于线程，并发可以看笔者的Java并发系列</p>
</blockquote>
<h3 id="JVM-系统线程"><a href="#JVM-系统线程" class="headerlink" title="JVM 系统线程"></a>JVM 系统线程</h3><ul>
<li><p>如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[])</code>的main线程以及所有这个main线程自己创建的线程。</p>
</li>
<li><p>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p>
</li>
</ul>
<ol>
<li><strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li>
<li><strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li>
<li><strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li>
<li><strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码</li>
<li><strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li>
</ol>
<h1 id="程序计数器-PC寄存器"><a href="#程序计数器-PC寄存器" class="headerlink" title="程序计数器(PC寄存器)"></a>程序计数器(PC寄存器)</h1><h2 id="PC寄存器介绍"><a href="#PC寄存器介绍" class="headerlink" title="PC寄存器介绍"></a>PC寄存器介绍</h2><blockquote>
<p>官方文档网址：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p>
</blockquote>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_003/0007.png">

<ol>
<li>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，<strong>寄存器存储指令相关的现场信息</strong>。CPU只有把数据装载到寄存器才能够运行。</li>
<li>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong>。</li>
<li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li>
<li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li>
<li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</li>
<li>它是<strong>程序控制流</strong>的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li>
<li>它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</li>
</ol>
<h2 id="PC寄存器的作用"><a href="#PC寄存器的作用" class="headerlink" title="PC寄存器的作用"></a>PC寄存器的作用</h2><p><strong>PC寄存器用来存储指向下一条指令的地址</strong>，也即将要执行的指令代码。<strong>由执行引擎读取下一条指令</strong>，并执行该指令。</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_003/0008.png">



<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PCRegisterTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看字节码</p>
<blockquote>
<p>看字节码的方法：<a href="https://blog.csdn.net/21aspnet/article/details/88351875">https://blog.csdn.net/21aspnet/article/details/88351875</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter04/com/atguigu/java/PCRegisterTest.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2020</span>-<span class="number">11</span>-<span class="number">2</span>; size <span class="number">675</span> bytes</span><br><span class="line">  MD5 checksum 53b3ef104479ec9e9b7ce5319e5881d3</span><br><span class="line">  Compiled from <span class="string">&quot;PCRegisterTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.atguigu.java.PCRegisterTest</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">6.</span>#<span class="number">26</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = String             #<span class="number">27</span>            <span class="comment">// abc</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">28.</span>#<span class="number">29</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">30.</span>#<span class="number">31</span>        <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">32</span>            <span class="comment">// com/atguigu/java/PCRegisterTest</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">33</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">12</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               Lcom/atguigu/java/PCRegisterTest;</span><br><span class="line">  #<span class="number">14</span> = Utf8               main</span><br><span class="line">  #<span class="number">15</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">16</span> = Utf8               args</span><br><span class="line">  #<span class="number">17</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">18</span> = Utf8               i</span><br><span class="line">  #<span class="number">19</span> = Utf8               I</span><br><span class="line">  #<span class="number">20</span> = Utf8               j</span><br><span class="line">  #<span class="number">21</span> = Utf8               k</span><br><span class="line">  #<span class="number">22</span> = Utf8               s</span><br><span class="line">  #<span class="number">23</span> = Utf8               Ljava/lang/String;</span><br><span class="line">  #<span class="number">24</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">25</span> = Utf8               PCRegisterTest.java</span><br><span class="line">  #<span class="number">26</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">27</span> = Utf8               abc</span><br><span class="line">  #<span class="number">28</span> = Class              #<span class="number">34</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">29</span> = NameAndType        #<span class="number">35</span>:#<span class="number">36</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">30</span> = Class              #<span class="number">37</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">31</span> = NameAndType        #<span class="number">38</span>:#<span class="number">39</span>        <span class="comment">// println:(I)V</span></span><br><span class="line">  #<span class="number">32</span> = Utf8               com/atguigu/java/PCRegisterTest</span><br><span class="line">  #<span class="number">33</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">34</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">35</span> = Utf8               out</span><br><span class="line">  #<span class="number">36</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">37</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">38</span> = Utf8               println</span><br><span class="line">  #<span class="number">39</span> = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java.PCRegisterTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java/PCRegisterTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">5</span>: istore_2</span><br><span class="line">         <span class="number">6</span>: iload_1</span><br><span class="line">         <span class="number">7</span>: iload_2</span><br><span class="line">         <span class="number">8</span>: iadd</span><br><span class="line">         <span class="number">9</span>: istore_3</span><br><span class="line">        <span class="number">10</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String abc</span></span><br><span class="line">        <span class="number">12</span>: astore        <span class="number">4</span></span><br><span class="line">        <span class="number">14</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">17</span>: iload_1</span><br><span class="line">        <span class="number">18</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">21</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">24</span>: iload_3</span><br><span class="line">        <span class="number">25</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">14</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">21</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span>     i   I</span><br><span class="line">            <span class="number">6</span>      <span class="number">23</span>     <span class="number">2</span>     j   I</span><br><span class="line">           <span class="number">10</span>      <span class="number">19</span>     <span class="number">3</span>     k   I</span><br><span class="line">           <span class="number">14</span>      <span class="number">15</span>     <span class="number">4</span>     s   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;PCRegisterTest.java&quot;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>左边的数字代表<strong>指令地址（指令偏移）</strong>，即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令</li>
</ul>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_003/0009.png">



<h2 id="两个面试题"><a href="#两个面试题" class="headerlink" title="两个面试题"></a>两个面试题</h2><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？</strong>或者问<strong>为什么使用 PC 寄存器来记录当前线程的执行地址呢？</strong></p>
<ol>
<li><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</p>
</li>
<li><p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_003/0010.png">



<p><strong>PC寄存器为什么被设定为私有的？</strong></p>
<ol>
<li>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li>
<li>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li>
<li>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</li>
</ol>
<h2 id="CPU-时间片"><a href="#CPU-时间片" class="headerlink" title="CPU 时间片"></a>CPU 时间片</h2><ol>
<li><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p>
</li>
<li><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p>
</li>
<li><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，<strong>每个程序轮流执行</strong>。</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_003/0011.png">



<h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><h2 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h2><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_003/0012.png">



<ol>
<li>简单地讲，<strong>一个Native Method是一个Java调用非Java代码的接囗</strong>一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern 告知C++编译器去调用一个C的函数。</li>
<li>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</li>
<li>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</li>
<li>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C&#x2F;C++程序。</li>
</ol>
<h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><p>需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IHaveNatives</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">Native1</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">Native2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="type">float</span> <span class="title function_">Native3</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">Native4</span><span class="params">(<span class="type">int</span>[] ary)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="为什么要使用-Native-Method？"><a href="#为什么要使用-Native-Method？" class="headerlink" title="为什么要使用 Native Method？"></a>为什么要使用 Native Method？</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<h3 id="与Java环境外交互"><a href="#与Java环境外交互" class="headerlink" title="与Java环境外交互"></a>与Java环境外交互</h3><p><strong>有时Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因</strong>。你可以想想Java需要与一些<strong>底层系统</strong>，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p>
<h3 id="与操作系统的交互"><a href="#与操作系统的交互" class="headerlink" title="与操作系统的交互"></a>与操作系统的交互</h3><ol>
<li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。</li>
<li>然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。</li>
<li><strong>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的</strong>。</li>
<li>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li>
</ol>
<h3 id="Sun’s-Java"><a href="#Sun’s-Java" class="headerlink" title="Sun’s Java"></a>Sun’s Java</h3><ol>
<li>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。</li>
<li>例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li>
</ol>
<h3 id="本地方法的现状"><a href="#本地方法的现状" class="headerlink" title="本地方法的现状"></a>本地方法的现状</h3><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p>
<h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><ol>
<li><strong>Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</li>
<li>本地方法栈，也是线程私有的。</li>
<li>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li>
</ul>
</li>
<li>本地方法一般是使用C语言或C++语言实现的。</li>
<li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_003/0013.png">



<p><strong>注意事项</strong></p>
<ol>
<li>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。<ul>
<li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存</li>
</ul>
</li>
<li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li>
<li>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>堆</title>
    <url>/2021/12/05/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC5%E7%AB%A0-%E5%A0%86/</url>
    <content><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的核心概述"><a href="#堆的核心概述" class="headerlink" title="堆的核心概述"></a>堆的核心概述</h2><h3 id="堆与进程"><a href="#堆与进程" class="headerlink" title="堆与进程"></a>堆与进程</h3><ol>
<li>堆针对一个JVM进程来说是唯一的。也就是<strong>一个进程只有一个JVM实例</strong>，一个JVM实例中就有一个运行时数据区，一个运行时数据区只有一个堆和一个方法区。</li>
<li>但是<strong>进程包含多个线程，他们是共享同一堆空间的</strong>。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0001.png">



<ol>
<li><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p>
</li>
<li><p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大一块内存空间，并且堆内存的大小是可以调节的。</p>
</li>
<li><p>《Java虚拟机规范》规定，堆可以处于<strong>物理上不连续的内存空间</strong>中，但在<strong>逻辑上它应该被视为连续</strong>的。</p>
</li>
<li><p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，<strong>TLAB</strong>）。</p>
</li>
<li><p>《Java虚拟机规范》中对Java堆的描述是：<strong>所有的对象实例以及数组都应当在运行时分配在堆上</strong>。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p>
<ul>
<li>从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</li>
</ul>
</li>
<li><p>数组和对象可能永远不会存储在栈上（<strong>不一定</strong>(栈上分配)），因为栈帧中保存<strong>引用</strong>，这个引用指向对象或者数组在堆中的位置。</p>
</li>
<li><p>在方法结束后，<strong>堆</strong>中的对象不会马上被移除，<strong>仅仅在垃圾收集</strong>的时候才会被移除。</p>
<ul>
<li>也就是触发了GC的时候，才会进行回收</li>
<li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li>
</ul>
</li>
<li><p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p>
</li>
</ol>
<blockquote>
<p>随着JVM的迭代升级，原来一些绝对的事情，在后续版本中也开始有了特例，变的不再那么绝对。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHeap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//属性、成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleHeap</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;My ID is &quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleHeap</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHeap</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">SimpleHeap</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHeap</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        Object[] arr1 = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0002.png">

<blockquote>
<p><strong>局部变量表定义为一个数字数组</strong>，主要用于<strong>存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用(reference) ，以及returnAddress（返回值）。</p>
</blockquote>
<h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p>
<ol>
<li>Java7 及之前堆内存逻辑上分为三部分：新生区+养老区+<strong>永久区</strong><ul>
<li>Young Generation Space    新生区      Young&#x2F;New<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Old generation space    养老区           Old&#x2F;Tenure</li>
<li>Permanent Space   永久区                   Perm</li>
</ul>
</li>
<li>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+<strong>元空间</strong><ul>
<li>Young Generation Space 新生区，又被划分为<strong>Eden区</strong>和<strong>Survivor区</strong></li>
<li>Old generation space 养老区</li>
<li>Meta Space 元空间 Meta</li>
</ul>
</li>
</ol>
<p>约定：新生区 &lt;–&gt; 新生代 &lt;–&gt; 年轻代 、 养老区 &lt;–&gt; 老年区 &lt;–&gt; 老年代、 永久区 &lt;–&gt; 永久代</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0003.png">



<ol start="2">
<li>堆空间内部结构，JDK1.8之前从<strong>永久代</strong> 替换成 <strong>元空间</strong></li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0004.png">



<h2 id="JVisualVM可视化查看堆内存"><a href="#JVisualVM可视化查看堆内存" class="headerlink" title="JVisualVM可视化查看堆内存"></a>JVisualVM可视化查看堆内存</h2><p>运行下面代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MINUTES.sleep(<span class="number">30</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>1、双击jdk目录下的这个文件</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0005.png">



<p>2、工具 -&gt; 插件 -&gt; 安装Visual GC插件</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0006.png">

<p>3、运行上面的代码</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0007.png">



<h2 id="设置堆内存大小与-OOM"><a href="#设置堆内存大小与-OOM" class="headerlink" title="设置堆内存大小与 OOM"></a>设置堆内存大小与 OOM</h2><h3 id="设置堆内存"><a href="#设置堆内存" class="headerlink" title="设置堆内存"></a>设置堆内存</h3><ol>
<li><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xms”和”-Xmx”来进行设置。</p>
<ul>
<li><strong>-Xms</strong>用于表示堆区的起始内存，等价于**-XX:InitialHeapSize**</li>
<li><strong>-Xmx</strong>则用于表示堆区的最大内存，等价于**-XX:MaxHeapSize**</li>
</ul>
</li>
<li><p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError异常。</p>
</li>
<li><p>通常会将-Xms和-Xmx两个参数配置相同的值</p>
</li>
</ol>
<ul>
<li>原因：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。</li>
<li>如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM</li>
</ul>
<ol start="4">
<li><p>默认情况下:</p>
<ul>
<li>初始内存大小：物理电脑内存大小&#x2F;64</li>
<li>最大内存大小：物理电脑内存大小&#x2F;4</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 设置堆空间大小的参数</span></span><br><span class="line"><span class="comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span></span><br><span class="line"><span class="comment"> *      -X 是jvm的运行参数</span></span><br><span class="line"><span class="comment"> *      ms 是memory start</span></span><br><span class="line"><span class="comment"> * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 默认堆空间的大小</span></span><br><span class="line"><span class="comment"> *    初始内存大小：物理电脑内存大小 / 64</span></span><br><span class="line"><span class="comment"> *             最大内存大小：物理电脑内存大小 / 4</span></span><br><span class="line"><span class="comment"> * 3. 手动设置：-Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id</span></span><br><span class="line"><span class="comment"> *                  方式二：-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSpaceInitial</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + initialMemory * <span class="number">64.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + maxMemory * <span class="number">4.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms : 123M</span><br><span class="line">-Xmx : 1794M</span><br><span class="line">系统内存大小为：<span class="number">7.</span>6875G</span><br><span class="line">系统内存大小为：<span class="number">7.</span>0078125G</span><br></pre></td></tr></table></figure>

<p>1、笔者电脑内存大小是8G，不足8G的原因是操作系统自身还占据了一些。</p>
<p>2、两个不一样的原因待会再说</p>
<p>设置下参数再看</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0008.png">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSpaceInitial</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms : 575M</span><br><span class="line">-Xmx : 575M</span><br></pre></td></tr></table></figure>

<p>为什么会少25M</p>
<p><strong>方式一： jps   &#x2F;  jstat -gc 进程id</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0009.png">

<blockquote>
<p>jps：查看java进程</p>
<p>jstat：查看某进程内存使用情况</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SOC: S0区总共容量</span><br><span class="line">S1C: S1区总共容量</span><br><span class="line">S0U: S0区使用的量</span><br><span class="line">S1U: S1区使用的量</span><br><span class="line">EC: 伊甸园区总共容量</span><br><span class="line">EU: 伊甸园区使用的量</span><br><span class="line">OC: 老年代总共容量</span><br><span class="line">OU: 老年代使用的量</span><br></pre></td></tr></table></figure>

<p>1、</p>
<p>25600+25600+153600+409600 &#x3D; 614400K</p>
<p>614400 &#x2F;1024 &#x3D; 600M</p>
<p>2、</p>
<p>25600+153600+409600 &#x3D; 588800K</p>
<p>588800 &#x2F;1024 &#x3D; 575M</p>
<p>3、</p>
<p>并非巧合，<strong>S0区和S1区两个只有一个能使用，另一个用不了,用于复制</strong>（后面会详解）</p>
<p> <strong>方式二：-XX:+PrintGCDetails</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0010.png">



<h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Picture</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Picture</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] pixels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Picture</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pixels = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、设置虚拟机参数</p>
<p><code>-Xms600m -Xmx600m</code></p>
<p>最终输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.atguigu.java.Picture.&lt;init&gt;(OOMTest.java:<span class="number">29</span>)</span><br><span class="line">	at com.atguigu.java.OOMTest.main(OOMTest.java:<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>2、堆内存变化图</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0011.png">

<p>3、原因：大对象导致堆内存溢出</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0012.png">



<h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p>1、存储在JVM中的Java对象可以被划分为两类：</p>
<pre><code>- 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
- 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致
</code></pre>
<p>2、Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p>
<p>3、其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p>
<p>​    Eden和S0，S1一般是<strong>8:1:1</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0013.png">

<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0014.png">

<ul>
<li><p>配置新生代与老年代在堆结构的占比</p>
<ul>
<li><p>默认**-XX:NewRatio**&#x3D;2，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3</p>
</li>
<li><p>可以修改**-XX:NewRatio**&#x3D;4，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</p>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1，</p>
</li>
<li><p>当然开发人员可以通过选项**-XX:SurvivorRatio**调整这个空间比例。比如-XX:SurvivorRatio&#x3D;8,<strong>但是这个值只有显式声明了才能起到效果，因为JVM可以动态调整</strong></p>
</li>
<li><p><strong>几乎所有的Java对象都是在Eden区被new出来的。</strong></p>
</li>
<li><p>绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p>
</li>
<li><p>可以使用选项”-Xmn”设置新生代最大内存大小，但这个参数一般使用默认值就可以了。</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0015.png">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -XX:NewRatio ： 设置新生代与老年代的比例。默认值是2.</span></span><br><span class="line"><span class="comment"> * -XX:SurvivorRatio ：设置新生代中Eden区与Survivor区的比例。默认值是8</span></span><br><span class="line"><span class="comment"> * -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）</span></span><br><span class="line"><span class="comment"> * -Xmn:设置新生代的空间的大小。 （一般不设置）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  17:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EdenSurvivorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我只是来打个酱油~&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<p><strong>具体过程</strong></p>
<ol>
<li>new的对象先放伊甸园区。此区有大小限制。</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（<strong>MinorGC</strong>），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</li>
<li>然后将伊甸园中的<strong>剩余对象移动到幸存者0区。</strong></li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li>
<li>啥时候能去养老区呢？可以设置次数。<strong>默认是15次</strong>。可以设置新生区进入养老区的年龄限制，设置 JVM 参数：**-XX:MaxTenuringThreshold**&#x3D;N 进行设置</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li>
<li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li>
</ol>
<h3 id="图解对象分配（一般情况）"><a href="#图解对象分配（一般情况）" class="headerlink" title="图解对象分配（一般情况）"></a>图解对象分配（一般情况）</h3><p>1、我们创建的对象，一般都是存放在Eden区的，<strong>当我们Eden区满了后，就会触发GC操作</strong>，一般被称为 <strong>YGC &#x2F; Minor GC</strong>操作</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0016.png">

<p>2、当我们进行一次垃圾收集后，红色的对象将会被回收，而绿色的独享还被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，经过一次回收后还存在的对象，将其年龄加 1。</p>
<p>3、同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象进行一次垃圾收集，把存活的对象放到 Survivor To（S1）区，同时让存活的对象年龄 + 1</p>
<blockquote>
<p>下一次再进行GC的时候，</p>
<p>1、这一次的s0区为空，所以成为下一次GC的S1区</p>
<p>2、这一次的s1区则成为下一次GC的S0区</p>
<p>3、也就是说s0区和s1区在互相转换。</p>
</blockquote>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0017.png">

<p>4、我们继续不断的进行对象生成和垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion 晋升的操作，也就是将年轻代中的对象晋升到老年代中</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0018.png">

<p>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区&#x2F;元空间收集。</p>
<h3 id="特殊情况说明"><a href="#特殊情况说明" class="headerlink" title="特殊情况说明"></a>特殊情况说明</h3><p><strong>对象分配的特殊情况</strong></p>
<ol>
<li>如果来了一个新对象，先看看 Eden 是否放的下？<ul>
<li>如果 Eden 放得下，则直接放到 Eden 区</li>
<li>如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？</li>
</ul>
</li>
<li>将对象放到老年区又有两种情况：<ul>
<li>如果 Eden <strong>执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代</strong></li>
<li>那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下 ，那只能报 OOM</li>
</ul>
</li>
<li><strong>如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区</strong></li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0019.png">

<h3 id="常用调优工具"><a href="#常用调优工具" class="headerlink" title="常用调优工具"></a>常用调优工具</h3><ol>
<li>JDK命令行</li>
<li>Eclipse：Memory Analyzer Tool</li>
<li>Jconsole</li>
<li>Visual VM（实时监控，推荐）</li>
<li>Jprofiler（IDEA插件）</li>
<li>Java Flight Recorder（实时监控）</li>
<li>GCViewer</li>
<li>GCEasy</li>
</ol>
<h2 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h2><ol>
<li><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，<strong>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</strong></p>
</li>
<li><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p>
</li>
</ol>
<ul>
<li><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>
<ul>
<li><strong>新生代收集</strong>（<strong>Minor GC&#x2F;Young GC</strong>）：只是新生代（Eden，s0，s1）的垃圾收集</li>
<li><strong>老年代收集</strong>（<strong>Major</strong> GC&#x2F;**Full **GC）：只是老年代的圾收集。</li>
<li>目前，只有<code>CMS GC</code>会有单独收集老年代的行为。</li>
<li><code>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</code></li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有<code>G1 GC</code>会有这种行为</li>
</ul>
</li>
<li><p><strong>整堆收集</strong>（Full GC）：收集整个<strong>java堆和方法区</strong>的垃圾收集。</p>
</li>
</ul>
<blockquote>
<p>由于历史原因，外界各种解读，majorGC和Full GC有些混淆。</p>
</blockquote>
<h3 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h3><p><strong>年轻代 GC（Minor GC）触发机制</strong></p>
<ol>
<li><p>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满。Survivor满不会主动引发GC，在Eden区满的时候，会顺带触发s0区的GC，也就是被动触发GC（每次Minor GC会清理年轻代的内存）</p>
</li>
<li><p>因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p>
</li>
<li><p>Minor GC<strong>会引发STW（Stop The World）</strong>，<strong>暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</strong></p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0020.png">



<h3 id="Major-x2F-Full-GC"><a href="#Major-x2F-Full-GC" class="headerlink" title="Major&#x2F;Full GC"></a>Major&#x2F;Full GC</h3><blockquote>
<p>Full GC有争议，后续详解两者区别，暂时先看着</p>
</blockquote>
<p><strong>老年代GC（MajorGC）触发机制</strong></p>
<ol>
<li><p><strong>指发生在老年代的GC</strong>，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p>
</li>
<li><p>出现了Major GC，经常会伴随至少一次的Minor GC。（但<strong>非绝对</strong>的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p>
<ul>
<li><p>也就是在老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC。</p>
<blockquote>
<p>在老年代空间不足之前，是因为年轻代放不下了，年轻代放不下的时候会进行Minor GC，所以在Major GC之前会产生Minor GC</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Major GC的速度一般会比Minor GC慢10倍以上，STW(Stop-the-World)的时间更长。所以调优也是尽量不要产生Minor GC</p>
</li>
<li><p>如果Major GC后，内存还不足，就报OOM了</p>
</li>
</ol>
<p><strong>Full GC 触发机制（后面细讲）</strong></p>
<p><strong>触发Full GC执行的情况有如下五种：</strong></p>
<ol>
<li>调用<code>System.gc()</code>时，系统建议执行<strong>Full</strong> GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后<strong>进入老年代的平均大小大于老年代的可用内存</strong></li>
<li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ol>
<blockquote>
<p>说明：Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些</p>
</blockquote>
<h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试MinorGC 、 MajorGC、FullGC</span></span><br><span class="line"><span class="comment"> * -Xms9m -Xmx9m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  14:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历次数为：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2037K-&gt;504K(2560K)] 2037K-&gt;728K(9728K), <span class="number">0.0455865</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.06</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2246K-&gt;496K(2560K)] 2470K-&gt;1506K(9728K), <span class="number">0.0009094</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2294K-&gt;488K(2560K)] 3305K-&gt;2210K(9728K), <span class="number">0.0009568</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1231K-&gt;488K(2560K)] 7177K-&gt;6434K(9728K), <span class="number">0.0005594</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 488K-&gt;472K(2560K)] 6434K-&gt;6418K(9728K), <span class="number">0.0005890</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 472K-&gt;0K(2560K)] [ParOldGen: 5946K-&gt;4944K(7168K)] 6418K-&gt;4944K(9728K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="number">0.0045270</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 4944K-&gt;4944K(8704K), <span class="number">0.0004954</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Allocation Failure)</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:<span class="number">3332</span>)</span><br><span class="line">	at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:<span class="number">124</span>)</span><br><span class="line">	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:<span class="number">448</span>)</span><br><span class="line">	at java.lang.StringBuilder.append(StringBuilder.java:<span class="number">136</span>)</span><br><span class="line">	at com.atguigu.java1.GCTest.main(GCTest.java:<span class="number">20</span>)</span><br><span class="line">[PSYoungGen: 0K-&gt;0K(1536K)] [ParOldGen: 4944K-&gt;4877K(7168K)] 4944K-&gt;4877K(8704K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="number">0.0076061</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.02</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">遍历次数为：<span class="number">16</span></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 1536K, used 60K [<span class="number">0x00000000ffd00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 1024K, <span class="number">5</span>% used [<span class="number">0x00000000ffd00000</span>,<span class="number">0x00000000ffd0f058</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">  from space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line"> ParOldGen       total 7168K, used 4877K [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffd00000</span>, <span class="number">0x00000000ffd00000</span>)</span><br><span class="line">  object space 7168K, <span class="number">68</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffac3408</span>,<span class="number">0x00000000ffd00000</span>)</span><br><span class="line"> Metaspace       used 3525K, capacity 4502K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 391K, capacity 394K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2037K-&gt;504K(2560K)] 2037K-&gt;728K(9728K), <span class="number">0.0455865</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.06</span> secs] </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><p>[PSYoungGen: 2037K-&gt;504K(2560K)]：年轻代总空间为 2560K ，当前占用 2037K ，经过垃圾回收后剩余504K</p>
</li>
<li><p>2037K-&gt;728K(9728K)：堆内存总空间为 9728K ，当前占用2037K ，经过垃圾回收后剩余728K</p>
</li>
</ul>
<h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h2><p>为什么要把Java堆分代？不分代就不能正常工作了吗？也能正常工作，但是为了效率（优化GC性能），经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>
<ul>
<li>新生代：有Eden、两块大小相同的survivor（又称为from&#x2F;to或s0&#x2F;s1）构成，to总为空。</li>
<li>老年代：存放新生代中经历多次GC仍然存活的对象。</li>
</ul>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0021.png">



<p>其实不分代完全可以，分代的唯一理由就是<strong>优化GC性能</strong>。</p>
<ul>
<li>如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。（性能低）</li>
</ul>
<ul>
<li>而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。（多回收新生代，少回收老年代，性能会提高很多）</li>
</ul>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0022.png">



<h2 id="对象内存分配策略"><a href="#对象内存分配策略" class="headerlink" title="对象内存分配策略"></a>对象内存分配策略</h2><ol>
<li>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。</li>
<li>对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</li>
<li>对象晋升老年代的年龄阀值，可以通过选项**-XX:MaxTenuringThreshold**来设置</li>
</ol>
<p><strong>针对不同年龄段的对象分配原则如下所示：</strong></p>
<ol>
<li><strong>优先分配到Eden</strong>：开发中<strong>比较长的字符串或者数组</strong>，会直接存在<strong>老年代</strong>，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li>
<li><strong>大对象直接分配到老年代</strong>：尽量避免程序中出现过多的大对象</li>
<li><strong>长期存活的对象分配到老年代</strong></li>
<li><strong>动态对象年龄判断</strong>：如果Survivor区中<strong>相同年龄的所有对象大小的总和</strong>大于<strong>Survivor空间的一半</strong>，年龄<strong>大于或等于</strong>该年龄的对象可以直接进入老年代，无须等到（阈值）MaxTenuringThreshold中要求的年龄。</li>
<li><strong>空间分配担保</strong>： -XX:HandlePromotionFailure 。</li>
</ol>
<blockquote>
<p>一些细节放在后面说</p>
</blockquote>
<h2 id="TLAB为对象分配内存（保证线程安全）"><a href="#TLAB为对象分配内存（保证线程安全）" class="headerlink" title="TLAB为对象分配内存（保证线程安全）"></a>TLAB为对象分配内存（保证线程安全）</h2><h3 id="为什么有-TLAB"><a href="#为什么有-TLAB" class="headerlink" title="为什么有 TLAB"></a>为什么有 TLAB</h3><ol start="2">
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的<code>共享数据</code></li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li><strong>为避免多个线程操作同一地址</strong>，需要使用<strong>加锁等机制</strong>，进而影响分配速度。</li>
</ol>
<h3 id="什么是-TLAB"><a href="#什么是-TLAB" class="headerlink" title="什么是 TLAB"></a>什么是 TLAB</h3><p>TLAB（Thread Local Allocation Buffer）</p>
<ol>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，<strong>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</strong>。</li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li>
<li>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0023.png">

<p>1、每个线程都有一个TLAB空间</p>
<p>2、当一个线程的TLAB存满时，可以使用公共区域（蓝色）的</p>
<h3 id="TLAB再说明"><a href="#TLAB再说明" class="headerlink" title="TLAB再说明"></a>TLAB再说明</h3><ol>
<li><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分配的首选</strong>。</p>
</li>
<li><p>在程序中，开发人员可以通过选项“**-XX:UseTLAB**”设置是否开启TLAB空间。</p>
</li>
<li><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“**-XX:TLABWasteTargetPercent**”设置TLAB空间所占用Eden空间的百分比大小。</p>
</li>
<li><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制确保数据操作的原子性</strong>，从而直接在Eden空间中分配内存。</p>
</li>
</ol>
<blockquote>
<p>1、哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，<strong>分配新的缓存区时才需要同步锁定</strong>                   —-这是《深入理解JVM》–第三版里说的</p>
</blockquote>
<p><strong>TLAB 分配过程</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_005/0024.png">



<h2 id="堆空间参数设置"><a href="#堆空间参数设置" class="headerlink" title="堆空间参数设置"></a>堆空间参数设置</h2><h3 id="常用参数设置"><a href="#常用参数设置" class="headerlink" title="常用参数设置"></a>常用参数设置</h3><blockquote>
<p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p>
<p>我们只说常用的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试堆空间常用的jvm参数：</span></span><br><span class="line"><span class="comment"> * -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值</span></span><br><span class="line"><span class="comment"> * -XX:+PrintFlagsFinal  ：查看所有的参数的最终值（可能会存在修改，不再是初始值）</span></span><br><span class="line"><span class="comment"> *      具体查看某个参数的指令： jps：查看当前运行中的进程</span></span><br><span class="line"><span class="comment"> *                             jinfo -flag SurvivorRatio 进程id</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -Xms：初始堆空间内存 （默认为物理内存的1/64）</span></span><br><span class="line"><span class="comment"> * -Xmx：最大堆空间内存（默认为物理内存的1/4）</span></span><br><span class="line"><span class="comment"> * -Xmn：设置新生代的大小。(初始值及最大值)</span></span><br><span class="line"><span class="comment"> * -XX:NewRatio：配置新生代与老年代在堆结构的占比</span></span><br><span class="line"><span class="comment"> * -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</span></span><br><span class="line"><span class="comment"> * -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails：输出详细的GC处理日志</span></span><br><span class="line"><span class="comment"> * 打印gc简要信息：① -XX:+PrintGC   ② -verbose:gc</span></span><br><span class="line"><span class="comment"> * -XX:HandlePromotionFailure：是否设置空间分配担保</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>1、在发生Minor GC之前，虚拟机会检查老年代<strong>最大可用的连续空间</strong>是否大于<strong>新生代所有对象的总空间</strong>。(因为Minor GC可能将新生代中的很多实例都移动到老年代中)</p>
<ul>
<li>如果大于，则此次Minor GC是安全的</li>
<li>如果小于，则虚拟机会查看**-XX:HandlePromotionFailure**设置值是否允担保失败。现在一般默认都是允许<ul>
<li>如果HandlePromotionFailure&#x3D;true，那么会继续检查<strong>老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong>。<ul>
<li>如果大于，则<strong>尝试进行一次Minor GC</strong>，但这次Minor GC依然是<strong>有风险</strong>的；</li>
<li>如果小于，则进行一次Full GC。</li>
</ul>
</li>
<li>如果HandlePromotionFailure&#x3D;false，则进行一次Full GC。</li>
</ul>
</li>
</ul>
<p><strong>历史版本</strong></p>
<ol>
<li>在JDK6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。</li>
<li>JDK6 Update 24之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC</strong>，否则将进行Full GC。即 HandlePromotionFailure&#x3D;true</li>
</ol>
<h2 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h2><p><strong>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</strong></p>
<ol>
<li><p>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换</strong>优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
</li>
<li><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
</li>
<li><p>此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
</li>
</ol>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><ol>
<li>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</li>
<li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</li>
<li>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li>
<li>逃逸分析的基本行为就是分析对象动态作用域：<ul>
<li>当一个对象在方法中被定义后，对象只在<strong>方法内部使用</strong>，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它<strong>被外部方法所引用</strong>，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li>
</ul>
</li>
</ol>
<p><strong>逃逸分析举例</strong></p>
<p>1、没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">my_method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">V</span>();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2、下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3、如果想要StringBuffer sb不发生逃逸，可以这样写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeAnalysis</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">obj</span> <span class="operator">=</span>= <span class="literal">null</span>? <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>() : obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> getInstance();</span><br><span class="line">        <span class="comment">//getInstance().xxx()同样会发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>逃逸分析参数设置</strong></p>
<ol>
<li><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p>
</li>
<li><p>如果使用的是较早的版本，开发人员则可以通过：</p>
<ul>
<li>选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析</li>
<li>通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p>开发中能使用局部变量的，就不要使用在方法外定义。</p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ol>
<li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li>
<li><strong>同步省略</strong>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>
<li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li>
</ol>
<h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><ol>
<li>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。<strong>这样就无须进行垃圾回收了。</strong></li>
<li>常见的栈上分配的场景：在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。</li>
</ol>
<p><strong>栈上分配举例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配测试</span></span><br><span class="line"><span class="comment"> * -Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackAllocation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 33280K-&gt;808K(38400K)] 33280K-&gt;816K(125952K), 0.0483350 secs] [Times: user=0.00 sys=0.00, real=0.06 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34088K-&gt;808K(38400K)] 34096K-&gt;816K(125952K), 0.0008411 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34088K-&gt;792K(38400K)] 34096K-&gt;800K(125952K), 0.0008427 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34072K-&gt;808K(38400K)] 34080K-&gt;816K(125952K), 0.0012223 secs] [Times: user=0.08 sys=0.00, real=0.00 secs] </span><br><span class="line">花费的时间为： 114 ms</span><br></pre></td></tr></table></figure>





<p>1、JVM 参数设置</p>
<p>-Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</p>
<p>2、日志打印：发生了 GC ，耗时 114ms</p>
<p><strong>开启逃逸分析的情况</strong></p>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">花费的时间为： 5 ms</span><br></pre></td></tr></table></figure>

<p>1、参数设置</p>
<p>-Xmx128m -Xms128m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</p>
<p>2、日志打印：并没有发生 GC ，耗时5ms 。</p>
<h3 id="同步省略（同步消除）"><a href="#同步省略（同步消除）" class="headerlink" title="同步省略（同步消除）"></a>同步省略（同步消除）</h3><ol>
<li><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>
</li>
<li><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong>。</p>
</li>
<li><p>如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个<strong>取消同步的过程就叫同步省略，也叫锁消除</strong>。</p>
</li>
</ol>
<p>例如下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">hollis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span>(hollis) &#123;</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>代码中对hollis这个对象加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">hellis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	System.out.println(hellis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>字节码分析</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SynchronizedTest &#123;</span><br><span class="line">    public void f() &#123;</span><br><span class="line">        Object hollis = new Object();</span><br><span class="line">        synchronized(hollis) &#123;</span><br><span class="line">            System.out.println(hollis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/Object&gt;</span><br><span class="line"> <span class="number">3</span> dup</span><br><span class="line"> <span class="number">4</span> invokespecial #<span class="number">1</span> &lt;java/lang/Object.&lt;init&gt;&gt;</span><br><span class="line"> <span class="number">7</span> astore_1</span><br><span class="line"> <span class="number">8</span> aload_1</span><br><span class="line"> <span class="number">9</span> dup</span><br><span class="line"><span class="number">10</span> astore_2</span><br><span class="line"><span class="number">11</span> monitorenter</span><br><span class="line"><span class="number">12</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">15</span> aload_1</span><br><span class="line"><span class="number">16</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">19</span> aload_2</span><br><span class="line"><span class="number">20</span> monitorexit</span><br><span class="line"><span class="number">21</span> goto <span class="number">29</span> (+<span class="number">8</span>)</span><br><span class="line"><span class="number">24</span> astore_3</span><br><span class="line"><span class="number">25</span> aload_2</span><br><span class="line"><span class="number">26</span> monitorexit</span><br><span class="line"><span class="number">27</span> aload_3</span><br><span class="line"><span class="number">28</span> athrow</span><br><span class="line"><span class="number">29</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>注意：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，<strong>同步省略操作是在解释运行时发生的</strong></p>
<h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p><strong>分离对象或标量替换</strong></p>
<ol>
<li><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>
</li>
<li><p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
</li>
<li><p>在JIT阶段，如果经过<strong>逃逸分析</strong>，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>
</li>
</ol>
<p><strong>标量替换举例</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上代码，经过标量替换后，就会变成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。</li>
<li>那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</li>
<li>标量替换为栈上分配提供了很好的基础。</li>
</ol>
<p><strong>标量替换参数设置</strong></p>
<p>参数 -XX:+ElimilnateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上。</p>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标量替换测试</span></span><br><span class="line"><span class="comment"> *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  12:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScalarReplace</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//未发生逃逸</span></span><br><span class="line">        u.id = <span class="number">5</span>;</span><br><span class="line">        u.name = <span class="string">&quot;www.atguigu.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>未开启标量替换</strong></p>
<p>1、JVM 参数</p>
<p>-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</p>
<p>2、日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure)  25600K-&gt;880K(98304K), <span class="number">0.0012658</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26480K-&gt;832K(98304K), <span class="number">0.0012124</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26432K-&gt;784K(98304K), <span class="number">0.0009719</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26384K-&gt;832K(98304K), <span class="number">0.0009071</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26432K-&gt;768K(98304K), <span class="number">0.0010643</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26368K-&gt;824K(101376K), <span class="number">0.0012354</span> secs]</span><br><span class="line">[GC (Allocation Failure)  32568K-&gt;712K(100864K), <span class="number">0.0011291</span> secs]</span><br><span class="line">[GC (Allocation Failure)  32456K-&gt;712K(100864K), <span class="number">0.0006368</span> secs]</span><br><span class="line">花费的时间为： <span class="number">99</span> ms</span><br></pre></td></tr></table></figure>



<p><strong>开启标量替换</strong></p>
<p>1、JVM 参数</p>
<p>-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</p>
<p>2、日志：时间减少很多，且无GC</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">花费的时间为： 6 ms</span><br></pre></td></tr></table></figure>





<p>上述代码在主函数中调用了1亿次alloc()方法，进行对象创建由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p>
<p><code>-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</code></p>
<p>这里设置参数如下：</p>
<ol>
<li>参数 -server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li>
<li>参数 -XX:+DoEscapeAnalysis：启用逃逸分析</li>
<li>参数 -Xmx10m：指定了堆空间最大为10MB</li>
<li>参数 -XX:+PrintGC：将打印GC日志。</li>
<li>参数 -XX:+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li>
</ol>
<h3 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h3><ol>
<li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li>
<li>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</li>
<li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li>
<li>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</li>
<li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，<strong>Oracle Hotspot JVM中并未这么做</strong>（刚刚演示的效果，是因为HotSpot实现了标量替换），这一点在逃逸分析相关的文档里已经说明，<strong>所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上</strong>。</li>
<li>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是<strong>intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配</strong>，<strong>所以这一点同样符合前面一点的结论：对象实例都是分配在堆上</strong>。</li>
</ol>
<blockquote>
<p><strong>堆是分配对象的唯一选择么？</strong></p>
</blockquote>
<p>综上：<strong>对象实例都是分配在堆上</strong>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>
</li>
<li><p>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。</p>
</li>
<li><p>当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上；</p>
</li>
<li><p>如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上；</p>
</li>
<li><p>如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</p>
</li>
<li><p>当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。</p>
</li>
<li><p>当GC发生在老年代时则被称为Major GC或者Full GC。</p>
</li>
<li><p>一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>方法区</title>
    <url>/2021/12/05/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC6%E7%AB%A0-%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><p><strong>从线程共享与否的角度来看</strong></p>
<p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型场景就是数据库连接管理，以及会话管理。</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0001.png">

<p><strong>栈、堆、方法区的交互关系</strong></p>
<p><strong>下面涉及了对象的访问定位</strong></p>
<ol>
<li>Person 类的 .class 信息存放在方法区中</li>
<li>person 变量存放在 Java 栈的局部变量表中</li>
<li>真正的 person 对象存放在 Java 堆中</li>
<li>在 person 对象中，有个指针指向方法区中的 person 类型数据，表明这个 person 对象是用方法区中的 Person 类 new 出来的</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0002.png">

<h2 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h2><blockquote>
<p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4</a></p>
</blockquote>
<h3 id="方法区在哪里？"><a href="#方法区在哪里？" class="headerlink" title="方法区在哪里？"></a>方法区在哪里？</h3><ol>
<li>《Java虚拟机规范》中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</li>
<li>所以，<strong>方法区可以看作是一块独立于Java堆的内存空间</strong>。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0003.png">



<h3 id="方法区的基本理解"><a href="#方法区的基本理解" class="headerlink" title="方法区的基本理解"></a>方法区的基本理解</h3><p><strong>方法区主要存放的是 Class，而堆中主要存放的是实例化的对象</strong></p>
<ol>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即类只能加载一次。</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutofMemoryError:PermGen space</code>或者<code>java.lang.OutOfMemoryError:Metaspace</code><ul>
<li>加载大量的第三方的jar包</li>
<li>Tomcat部署的工程过多（30~50个）</li>
<li>大量动态的生成反射类</li>
</ul>
</li>
<li>关闭JVM就会释放这个区域的内存。</li>
</ol>
<p><strong>代码举例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单的程序，加载了1600多个类</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0004.png">



<h3 id="HotSpot方法区演进"><a href="#HotSpot方法区演进" class="headerlink" title="HotSpot方法区演进"></a>HotSpot方法区演进</h3><ol>
<li>在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用<strong>元空间</strong>取代了<strong>永久代</strong>。我们可以将方法区类比为Java中的接口，将永久代或元空间类比为Java中具体的实现类</li>
<li>本质上，方法区和永久代并不等价。仅是对Hotspot而言的可以看作等价。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit &#x2F; IBM J9 中不存在永久代的概念。<ul>
<li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOm（超过-XX:MaxPermsize上限）</li>
</ul>
</li>
<li>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</li>
<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong>。</li>
<li>永久代、元空间二者并不只是名字变了，内部结构也调整了</li>
<li>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0005.png">



<h2 id="设置方法区大小与-OOM"><a href="#设置方法区大小与-OOM" class="headerlink" title="设置方法区大小与 OOM"></a>设置方法区大小与 OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p>
<h3 id="JDK7及以前-永久代"><a href="#JDK7及以前-永久代" class="headerlink" title="JDK7及以前(永久代)"></a>JDK7及以前(永久代)</h3><ol>
<li>通过-XX:Permsize来设置永久代初始分配空间。默认值是20.75M</li>
<li>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li>
<li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0006.png">

<h3 id="JDK8及以后-元空间"><a href="#JDK8及以后-元空间" class="headerlink" title="JDK8及以后(元空间)"></a>JDK8及以后(元空间)</h3><blockquote>
<p><strong>JDK8 版本设置元空间大小</strong></p>
</blockquote>
<ol>
<li><p>元数据区大小可以使用参数 <strong>-XX:MetaspaceSize</strong> 和 <strong>-XX:MaxMetaspaceSize</strong> 指定</p>
</li>
<li><p>默认值依赖于平台，Windows下，-XX:MetaspaceSize 约为21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</p>
</li>
<li><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p>
</li>
<li><p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个 64位 的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p>
</li>
<li><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p>
</li>
</ol>
<h3 id="方法区OOM"><a href="#方法区OOM" class="headerlink" title="方法区OOM"></a>方法区OOM</h3><p>举例：</p>
<p>代码：OOMTest 类继承 ClassLoader 类，获得 defineClass() 方法，可自己进行类的加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk6/7中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m -XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OOMTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OOMTest</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，修饰符，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="type">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//Class对象</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>不设置元空间的上限</strong></p>
<p>使用默认的 JVM 参数，元空间不设置上限</p>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure>



<p><strong>设置元空间的上限</strong></p>
<p>JVM 参数</p>
<p>-XX:MetaspaceSize&#x3D;10m -XX:MaxMetaspaceSize&#x3D;10m</p>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">8531</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">	at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">763</span>)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">642</span>)</span><br><span class="line">	at com.atguigu.java.OOMTest.main(OOMTest.java:<span class="number">29</span>)</span><br></pre></td></tr></table></figure>



<h3 id="如何解决OOM"><a href="#如何解决OOM" class="headerlink" title="如何解决OOM"></a>如何解决OOM</h3><blockquote>
<p>这个属于调优的问题，这里先简单的说一下</p>
</blockquote>
<ol>
<li>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</li>
<li><strong>内存泄漏</strong>就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li>
<li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li>
</ol>
<h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><h3 id="方法区存储什么？"><a href="#方法区存储什么？" class="headerlink" title="方法区存储什么？"></a>方法区存储什么？</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0007.png">

<p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0008.png">



<p><strong>类型信息</strong></p>
<p>对每个<strong>加载的类型（类class、接口interface、枚举enum、注解annotation）</strong>，JVM必须在方法区中存储以下类型信息：</p>
<ol>
<li>这个类型的<strong>完整有效名称</strong>（全名&#x3D;包名.类名）</li>
<li>这个类型<strong>直接父类的完整有效名</strong>（对于interface或是java.lang.Object，都没有父类）</li>
<li>这个类型的<strong>修饰符</strong>（public，abstract，final的某个子集）</li>
<li>这个类型<strong>直接接口的一个有序列表</strong>(可以继承多个接口)</li>
</ol>
<p><strong>域（Field）信息</strong></p>
<blockquote>
<p>也就是我们常说的成员变量，域信息是比较官方的称呼</p>
</blockquote>
<ol>
<li><p>JVM必须在方法区中保存类型的<strong>所有成员变量（域）的相关信息</strong>以及<strong>成员变量（域)的声明顺序</strong>。</p>
</li>
<li><p>域的相关信息包括：域名称，域类型，域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p>
</li>
</ol>
<p><strong>方法（Method）信息</strong></p>
<p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ol>
<li>方法名称</li>
<li>方法的返回类型（包括 void 返回类型），void 在 Java 中对应的为 void.class</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li>
<li><strong>方法的<code>字节码（bytecodes）</code>、操作数栈、局部变量表及大小（abstract和native方法除外） 理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</strong></li>
</ol>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * 测试方法区的内部构成</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;String&gt;,Serializable &#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;测试方法的内部结构&quot;</span>;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> cal)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">            result = value / cal;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>javap -v -p MethodInnerStrucTest.class &gt; test.txt</code></p>
<ul>
<li>反编译字节码文件，并输出值文本文件中，便于查看。参数 -p 确保能查看 private 权限类型的字段或方法</li>
</ul>
<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter09/com/atguigu/java/MethodInnerStrucTest.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2020</span>-<span class="number">11</span>-<span class="number">13</span>; size <span class="number">1626</span> bytes</span><br><span class="line">  MD5 checksum 0d0fcb54854d4ce183063df985141ad0</span><br><span class="line">  Compiled from <span class="string">&quot;MethodInnerStrucTest.java&quot;</span></span><br><span class="line"><span class="comment">//类型信息      </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.atguigu.java.MethodInnerStrucTest <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Object <span class="keyword">implements</span> <span class="title class_">java</span>.lang.Comparable&lt;java.lang.String&gt;, java.io.Serializable</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">18.</span>#<span class="number">52</span>        <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">17.</span>#<span class="number">53</span>        <span class="comment">// com/atguigu/java/MethodInnerStrucTest.num:I</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">54.</span>#<span class="number">55</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">56</span>            <span class="comment">// java/lang/StringBuilder</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">4.</span>#<span class="number">52</span>         <span class="comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">6</span> = String             #<span class="number">57</span>            <span class="comment">// count =</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">4.</span>#<span class="number">58</span>         <span class="comment">// java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">   #<span class="number">8</span> = Methodref          #<span class="number">4.</span>#<span class="number">59</span>         <span class="comment">// java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">   #<span class="number">9</span> = Methodref          #<span class="number">4.</span>#<span class="number">60</span>         <span class="comment">// java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">10</span> = Methodref          #<span class="number">61.</span>#<span class="number">62</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">11</span> = Class              #<span class="number">63</span>            <span class="comment">// java/lang/Exception</span></span><br><span class="line">  #<span class="number">12</span> = Methodref          #<span class="number">11.</span>#<span class="number">64</span>        <span class="comment">// java/lang/Exception.printStackTrace:()V</span></span><br><span class="line">  #<span class="number">13</span> = Class              #<span class="number">65</span>            <span class="comment">// java/lang/String</span></span><br><span class="line">  #<span class="number">14</span> = Methodref          #<span class="number">17.</span>#<span class="number">66</span>        <span class="comment">// com/atguigu/java/MethodInnerStrucTest.compareTo:(Ljava/lang/String;)I</span></span><br><span class="line">  #<span class="number">15</span> = String             #<span class="number">67</span>            <span class="comment">// 测试方法的内部结构</span></span><br><span class="line">  #<span class="number">16</span> = Fieldref           #<span class="number">17.</span>#<span class="number">68</span>        <span class="comment">// com/atguigu/java/MethodInnerStrucTest.str:Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">17</span> = Class              #<span class="number">69</span>            <span class="comment">// com/atguigu/java/MethodInnerStrucTest</span></span><br><span class="line">  #<span class="number">18</span> = Class              #<span class="number">70</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">19</span> = Class              #<span class="number">71</span>            <span class="comment">// java/lang/Comparable</span></span><br><span class="line">  #<span class="number">20</span> = Class              #<span class="number">72</span>            <span class="comment">// java/io/Serializable</span></span><br><span class="line">  #<span class="number">21</span> = Utf8               num</span><br><span class="line">  #<span class="number">22</span> = Utf8               I</span><br><span class="line">  #<span class="number">23</span> = Utf8               str</span><br><span class="line">  #<span class="number">24</span> = Utf8               Ljava/lang/String;</span><br><span class="line">  #<span class="number">25</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">26</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">27</span> = Utf8               Code</span><br><span class="line">  #<span class="number">28</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">29</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">30</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">31</span> = Utf8               Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line">  #<span class="number">32</span> = Utf8               test1</span><br><span class="line">  #<span class="number">33</span> = Utf8               count</span><br><span class="line">  #<span class="number">34</span> = Utf8               test2</span><br><span class="line">  #<span class="number">35</span> = Utf8               (I)I</span><br><span class="line">  #<span class="number">36</span> = Utf8               value</span><br><span class="line">  #<span class="number">37</span> = Utf8               e</span><br><span class="line">  #<span class="number">38</span> = Utf8               Ljava/lang/Exception;</span><br><span class="line">  #<span class="number">39</span> = Utf8               cal</span><br><span class="line">  #<span class="number">40</span> = Utf8               result</span><br><span class="line">  #<span class="number">41</span> = Utf8               StackMapTable</span><br><span class="line">  #<span class="number">42</span> = Class              #<span class="number">63</span>            <span class="comment">// java/lang/Exception</span></span><br><span class="line">  #<span class="number">43</span> = Utf8               compareTo</span><br><span class="line">  #<span class="number">44</span> = Utf8               (Ljava/lang/String;)I</span><br><span class="line">  #<span class="number">45</span> = Utf8               o</span><br><span class="line">  #<span class="number">46</span> = Utf8               (Ljava/lang/Object;)I</span><br><span class="line">  #<span class="number">47</span> = Utf8               &lt;clinit&gt;</span><br><span class="line">  #<span class="number">48</span> = Utf8               Signature</span><br><span class="line">  #<span class="number">49</span> = Utf8               Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span><br><span class="line">  #<span class="number">50</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">51</span> = Utf8               MethodInnerStrucTest.java</span><br><span class="line">  #<span class="number">52</span> = NameAndType        #<span class="number">25</span>:#<span class="number">26</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">53</span> = NameAndType        #<span class="number">21</span>:#<span class="number">22</span>        <span class="comment">// num:I</span></span><br><span class="line">  #<span class="number">54</span> = Class              #<span class="number">73</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">55</span> = NameAndType        #<span class="number">74</span>:#<span class="number">75</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">56</span> = Utf8               java/lang/StringBuilder</span><br><span class="line">  #<span class="number">57</span> = <span class="type">Utf8</span>               <span class="variable">count</span> <span class="operator">=</span></span><br><span class="line">  #<span class="number">58</span> = NameAndType        #<span class="number">76</span>:#<span class="number">77</span>        <span class="comment">// append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">59</span> = NameAndType        #<span class="number">76</span>:#<span class="number">78</span>        <span class="comment">// append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">60</span> = NameAndType        #<span class="number">79</span>:#<span class="number">80</span>        <span class="comment">// toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">61</span> = Class              #<span class="number">81</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">62</span> = NameAndType        #<span class="number">82</span>:#<span class="number">83</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">63</span> = Utf8               java/lang/Exception</span><br><span class="line">  #<span class="number">64</span> = NameAndType        #<span class="number">84</span>:#<span class="number">26</span>        <span class="comment">// printStackTrace:()V</span></span><br><span class="line">  #<span class="number">65</span> = Utf8               java/lang/String</span><br><span class="line">  #<span class="number">66</span> = NameAndType        #<span class="number">43</span>:#<span class="number">44</span>        <span class="comment">// compareTo:(Ljava/lang/String;)I</span></span><br><span class="line">  #<span class="number">67</span> = Utf8               测试方法的内部结构</span><br><span class="line">  #<span class="number">68</span> = NameAndType        #<span class="number">23</span>:#<span class="number">24</span>        <span class="comment">// str:Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">69</span> = Utf8               com/atguigu/java/MethodInnerStrucTest</span><br><span class="line">  #<span class="number">70</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">71</span> = Utf8               java/lang/Comparable</span><br><span class="line">  #<span class="number">72</span> = Utf8               java/io/Serializable</span><br><span class="line">  #<span class="number">73</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">74</span> = Utf8               out</span><br><span class="line">  #<span class="number">75</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">76</span> = Utf8               append</span><br><span class="line">  #<span class="number">77</span> = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #<span class="number">78</span> = Utf8               (I)Ljava/lang/StringBuilder;</span><br><span class="line">  #<span class="number">79</span> = Utf8               toString</span><br><span class="line">  #<span class="number">80</span> = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #<span class="number">81</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">82</span> = Utf8               println</span><br><span class="line">  #<span class="number">83</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">84</span> = Utf8               printStackTrace</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//域信息</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> java.lang.String str;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法信息</span></span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java.MethodInnerStrucTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">7</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        <span class="number">10</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">13</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String count =</span></span><br><span class="line">        <span class="number">15</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">18</span>: iload_1</span><br><span class="line">        <span class="number">19</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">22</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">25</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span> count   I</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    descriptor: (I)I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: bipush        <span class="number">30</span></span><br><span class="line">         <span class="number">4</span>: istore_2</span><br><span class="line">         <span class="number">5</span>: iload_2</span><br><span class="line">         <span class="number">6</span>: iload_0</span><br><span class="line">         <span class="number">7</span>: idiv</span><br><span class="line">         <span class="number">8</span>: istore_1</span><br><span class="line">         <span class="number">9</span>: goto          <span class="number">17</span></span><br><span class="line">        <span class="number">12</span>: astore_2</span><br><span class="line">        <span class="number">13</span>: aload_2</span><br><span class="line">        <span class="number">14</span>: invokevirtual #<span class="number">12</span>                 <span class="comment">// Method java/lang/Exception.printStackTrace:()V</span></span><br><span class="line">        <span class="number">17</span>: iload_1</span><br><span class="line">        <span class="number">18</span>: ireturn</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">2</span>     <span class="number">9</span>    <span class="number">12</span>   Class java/lang/Exception</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">21</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">23</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">24</span>: <span class="number">5</span></span><br><span class="line">        line <span class="number">27</span>: <span class="number">9</span></span><br><span class="line">        line <span class="number">25</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">26</span>: <span class="number">13</span></span><br><span class="line">        line <span class="number">28</span>: <span class="number">17</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">5</span>       <span class="number">4</span>     <span class="number">2</span> value   I</span><br><span class="line">           <span class="number">13</span>       <span class="number">4</span>     <span class="number">2</span>     e   Ljava/lang/Exception;</span><br><span class="line">            <span class="number">0</span>      <span class="number">19</span>     <span class="number">0</span>   cal   I</span><br><span class="line">            <span class="number">2</span>      <span class="number">17</span>     <span class="number">1</span> result   I</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">          offset_delta = <span class="number">12</span></span><br><span class="line">          locals = [ <span class="type">int</span>, <span class="type">int</span> ]</span><br><span class="line">          stack = [ <span class="keyword">class</span> <span class="title class_">java</span>/lang/Exception ]</span><br><span class="line">        frame_type = <span class="number">4</span> <span class="comment">/* same */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">    descriptor: (Ljava/lang/String;)I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">33</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">2</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">2</span>     <span class="number">1</span>     o   Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(java.lang.Object)</span>;</span><br><span class="line">    descriptor: (Ljava/lang/Object;)I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: aload_1</span><br><span class="line">         <span class="number">2</span>: checkcast     #<span class="number">13</span>                 <span class="comment">// class java/lang/String</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">14</span>                 <span class="comment">// Method compareTo:(Ljava/lang/String;)I</span></span><br><span class="line">         <span class="number">8</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">15</span>                 <span class="comment">// String 测试方法的内部结构</span></span><br><span class="line">         <span class="number">2</span>: putstatic     #<span class="number">16</span>                 <span class="comment">// Field str:Ljava/lang/String;</span></span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">Signature: #<span class="number">49</span>                          <span class="comment">// Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span></span><br><span class="line">SourceFile: <span class="string">&quot;MethodInnerStrucTest.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>类型信息</strong></p>
<p>在运行时方法区中，<strong>类信息中记录了哪个加载器加载了该类，同时类加载器也记录了它加载了哪些类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型信息      </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.atguigu.java.MethodInnerStrucTest <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Object <span class="keyword">implements</span> <span class="title class_">java</span>.lang.Comparable&lt;java.lang.String&gt;, java.io.Serializable</span><br></pre></td></tr></table></figure>

<p><strong>域信息</strong></p>
<ol>
<li>descriptor: I 表示字段类型为 Integer</li>
<li>flags: ACC_PUBLIC 表示字段权限修饰符为 public</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//域信息</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> java.lang.String str;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC</span><br></pre></td></tr></table></figure>

<p><strong>方法信息</strong></p>
<ol>
<li>descriptor: ()V 表示方法返回值类型为 void</li>
<li>flags: ACC_PUBLIC 表示方法权限修饰符为 public</li>
<li>stack&#x3D;3 表示操作数栈深度为 3</li>
<li>locals&#x3D;2 表示局部变量个数为 2 个（实例方法包含 this）</li>
<li>test1() 方法虽然没有参数，但是其 args_size&#x3D;1 ，这时因为将 this 作为了参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        <span class="number">10</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">13</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String count =</span></span><br><span class="line">        <span class="number">15</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">18</span>: iload_1</span><br><span class="line">        <span class="number">19</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">22</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">25</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span> count   I</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="non-final-类型的类变量"><a href="#non-final-类型的类变量" class="headerlink" title="non-final 类型的类变量"></a>non-final 类型的类变量</h3><ol>
<li><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p>
</li>
<li><p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p>
</li>
</ol>
<p><strong>举例</strong></p>
<ol>
<li>如下代码所示，即使我们把order设置为null，也不会出现空指针异常</li>
<li>这更加表明了 static 类型的字段和方法随着类的加载而加载，并不属于特定的类实例</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello!</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="全局常量：static-final"><a href="#全局常量：static-final" class="headerlink" title="全局常量：static final"></a>全局常量：static final</h4><ol>
<li><p>全局常量就是使用 static final 进行修饰</p>
</li>
<li><p>被声明为final的类变量的处理方法则不同，每个全局常量在<strong>编译</strong>的时候就会被分配了。</p>
</li>
</ol>
<p>查看上面代码，这部分的字节码指令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> number;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="type">int</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>可以发现 staitc和final同时修饰的number 的值在<strong>编译上的时候已经写死在字节码文件中了</strong>。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><h4 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h4><blockquote>
<p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p>
<p>后面会细讲常量池，这里为了讲清楚方法区，简单带一下。</p>
</blockquote>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0009.png">

<ol>
<li>方法区，内部包含了<strong>运行时常量池</strong></li>
<li>字节码文件，内部包含了<strong>常量池</strong>。（之前的字节码文件中已经看到了很多Constant pool的东西，这个就是常量池）</li>
<li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li>
<li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</li>
</ol>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><table>
<thead>
<tr>
<th><strong>版本信息、字段、方法以及接口等描述符信息</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>常量池表</strong></td>
</tr>
</tbody></table>
<hr>
<ol>
<li>一个有效的字节码文件中除了包含类的<code>版本信息、字段、方法以及接口等描述符信息外</code>。还包含一项信息就是<strong>常量池表</strong>（<strong>Constant Pool Table</strong>），包括各种字面量和对类型、域和方法的符号引用。</li>
<li>字面量： 10 ， “我是某某”这种数字和字符串都是字面量</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0010.png">

<p><strong>为什么需要常量池？</strong></p>
<ol>
<li>一个java源文件中的类、接口，编译后产生一个字节码文件。<strong>而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池。这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍</strong></li>
</ol>
<p>比如：如下的代码：</p>
<pre><code>public class SimpleClass &#123;
    public void sayHello() &#123;
        System.out.println(&quot;hello&quot;);
    &#125;
&#125;
</code></pre>
<ol>
<li><p>虽然上述代码只有194字节，但是里面却使用了<code>String、System、PrintStream及Object</code>等结构。</p>
</li>
<li><p>比如说我们这个文件中有6个地方用到了”hello”这个字符串，如果不用常量池，就需要在6个地方全写一遍，造成臃肿。我们可以将”hello”等所需用到的结构信息记录在常量池中，并通过<strong>引用的方式</strong>，来加载、调用所需的结构</p>
<p><strong><code>#3 -&gt; ....</code></strong></p>
</li>
<li><p>这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0011.png">

<p><strong>常量池中有啥？</strong></p>
<ol>
<li><strong>数量值</strong></li>
<li><strong>字符串值</strong></li>
<li><strong>类引用</strong></li>
<li><strong>字段引用</strong></li>
<li><strong>方法引用</strong></li>
</ol>
<p>MethodInnerStrucTest 的 test1方法的字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">20</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"> <span class="number">6</span> <span class="keyword">new</span> #<span class="number">4</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"> <span class="number">9</span> dup</span><br><span class="line"><span class="number">10</span> invokespecial #<span class="number">5</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">13</span> ldc #<span class="number">6</span> &lt;count = &gt;</span><br><span class="line"><span class="number">15</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">18</span> iload_1</span><br><span class="line"><span class="number">19</span> invokevirtual #<span class="number">8</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">22</span> invokevirtual #<span class="number">9</span> &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">25</span> invokevirtual #<span class="number">10</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">28</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>1、**#3，#5等等这些带# 的，都是引用了常量池。**</p>
<p><strong>常量池总结</strong></p>
<p>常量池、可以看做是一张表，**<code>虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</code>**</p>
<h4 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><blockquote>
<p>同时符号地址就变成真实地址了</p>
</blockquote>
<ol>
<li><strong>运行时常量池（Runtime Constant Pool）是方法区的一部分。</strong></li>
<li><strong>常量池表（Constant Pool Table）是Class字节码文件的一部分</strong>，用于存放编译期生成的各种字面量与符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。（运行时常量池就是常量池在程序运行时的称呼）</li>
<li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li>
<li>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过<strong>索引访问</strong>的。</li>
<li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号地址了，这里换为真实地址</strong>。</li>
</ol>
<ul>
<li>运行时常量池，相对于Class文件常量池的另一重要特征是：<strong>具备动态性</strong>。</li>
</ul>
<ol start="6">
<li>运行时常量池类似于传统编程语言中的<strong>符号表</strong>（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutofMemoryError异常。</li>
</ol>
<h2 id="方法区的使用举例"><a href="#方法区的使用举例" class="headerlink" title="方法区的使用举例"></a>方法区的使用举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.atguigu.java1.MethodAreaDemo</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">51</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">5.</span>#<span class="number">24</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">25.</span>#<span class="number">26</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = Methodref          #<span class="number">27.</span>#<span class="number">28</span>        <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">29</span>            <span class="comment">// com/atguigu/java1/MethodAreaDemo</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">30</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">6</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">7</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">8</span> = Utf8               Code</span><br><span class="line">   #<span class="number">9</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">10</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">12</span> = Utf8               Lcom/atguigu/java1/MethodAreaDemo;</span><br><span class="line">  #<span class="number">13</span> = Utf8               main</span><br><span class="line">  #<span class="number">14</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">15</span> = Utf8               args</span><br><span class="line">  #<span class="number">16</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">17</span> = Utf8               x</span><br><span class="line">  #<span class="number">18</span> = Utf8               I</span><br><span class="line">  #<span class="number">19</span> = Utf8               y</span><br><span class="line">  #<span class="number">20</span> = Utf8               a</span><br><span class="line">  #<span class="number">21</span> = Utf8               b</span><br><span class="line">  #<span class="number">22</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">23</span> = Utf8               MethodAreaDemo.java</span><br><span class="line">  #<span class="number">24</span> = NameAndType        #<span class="number">6</span>:#<span class="number">7</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">25</span> = Class              #<span class="number">31</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">26</span> = NameAndType        #<span class="number">32</span>:#<span class="number">33</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">27</span> = Class              #<span class="number">34</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">28</span> = NameAndType        #<span class="number">35</span>:#<span class="number">36</span>        <span class="comment">// println:(I)V</span></span><br><span class="line">  #<span class="number">29</span> = Utf8               com/atguigu/java1/MethodAreaDemo</span><br><span class="line">  #<span class="number">30</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">31</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">32</span> = Utf8               out</span><br><span class="line">  #<span class="number">33</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">34</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">35</span> = Utf8               println</span><br><span class="line">  #<span class="number">36</span> = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java1.MethodAreaDemo();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java1/MethodAreaDemo;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: sipush        <span class="number">500</span></span><br><span class="line">         <span class="number">3</span>: istore_1</span><br><span class="line">         <span class="number">4</span>: bipush        <span class="number">100</span></span><br><span class="line">         <span class="number">6</span>: istore_2</span><br><span class="line">         <span class="number">7</span>: iload_1</span><br><span class="line">         <span class="number">8</span>: iload_2</span><br><span class="line">         <span class="number">9</span>: idiv</span><br><span class="line">        <span class="number">10</span>: istore_3</span><br><span class="line">        <span class="number">11</span>: bipush        <span class="number">50</span></span><br><span class="line">        <span class="number">13</span>: istore        <span class="number">4</span></span><br><span class="line">        <span class="number">15</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">18</span>: iload_3</span><br><span class="line">        <span class="number">19</span>: iload         <span class="number">4</span></span><br><span class="line">        <span class="number">21</span>: iadd</span><br><span class="line">        <span class="number">22</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">25</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">9</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">7</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">15</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">25</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">26</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">4</span>      <span class="number">22</span>     <span class="number">1</span>     x   I</span><br><span class="line">            <span class="number">7</span>      <span class="number">19</span>     <span class="number">2</span>     y   I</span><br><span class="line">           <span class="number">11</span>      <span class="number">15</span>     <span class="number">3</span>     a   I</span><br><span class="line">           <span class="number">15</span>      <span class="number">11</span>     <span class="number">4</span>     b   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;MethodAreaDemo.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="图解字节码指令执行流程"><a href="#图解字节码指令执行流程" class="headerlink" title="图解字节码指令执行流程"></a>图解字节码指令执行流程</h4><p>1、初始状态</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0012.png">

<p>2、首先将操作数500压入操作数栈中</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0013.png">

<p>3、然后操作数 500 从操作数栈中取出，存储到局部变量表中索引为 1 的位置</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0014.png">

<p>4、</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0015.png">

<p>5、</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0016.png">



<p>6、</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0017.png">

<p>7、</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0018.png">

<p>8、</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0019.png">

<p>9、</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0020.png">

<p>10、</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0021.png">

<p>11、图片写错了是#25和#26（获得System类）</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0022.png">

<p>12、</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0023.png">

<p>13、</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0024.png">

<p>15、执行加法运算后，将计算结果放在操作数栈顶</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0025.png">

<p>16、就是真正的打印</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0026.png">

<p>17、</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0027.png">

<p><strong>符号引用 –&gt; 直接饮用</strong></p>
<ol>
<li>上面代码调用 System.out.println() 方法时，首先需要看看 System 类有没有加载，再看看 PrintStream 类有没有加载</li>
<li>如果没有加载，则执行加载，执行时，<strong>将常量池中的符号引用（字面量）转换为运行时常量池的直接引用（真正的地址值）</strong></li>
</ol>
<h2 id="方法区演进细节"><a href="#方法区演进细节" class="headerlink" title="方法区演进细节"></a>方法区演进细节</h2><h3 id="永久代演进过程"><a href="#永久代演进过程" class="headerlink" title="永久代演进过程"></a>永久代演进过程</h3><ol>
<li><p>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p>
</li>
<li><p>Hotspot中方法区的变化：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>JDK1.6及以前</th>
<th>有永久代（permanent generation），静态变量存储在永久代上</th>
</tr>
</thead>
<tbody><tr>
<td>JDK1.7</td>
<td>有永久代，但已经逐步 “去永久代”，<strong>字符串常量池（运行时常量池当中的），静态变量移除，保存在堆中</strong></td>
</tr>
<tr>
<td>JDK1.8</td>
<td>无永久代，类型信息，字段，方法，<strong>常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</strong></td>
</tr>
</tbody></table>
<p><strong>JDK6</strong></p>
<p>方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存）</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0028.png">



<p><strong>JDK7</strong></p>
<p>方法区由永久代实现，使用 JVM 虚拟机内存</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0029.png">



<p><strong>JDK8</strong></p>
<p>方法区由元空间实现，<strong>使用物理机本地内存，没有再用虚拟机内存</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0030.png">





<h3 id="永久代为什么要被元空间替代？"><a href="#永久代为什么要被元空间替代？" class="headerlink" title="永久代为什么要被元空间替代？"></a>永久代为什么要被元空间替代？</h3><blockquote>
<p><strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p>
</blockquote>
<ol>
<li>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</li>
<li>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</li>
<li>这项改动是很有必要的，原因有：<ol>
<li><strong>因为永久代设置空间大小是很难确定的。</strong>在某些场景下，如果<code>动态加载类过多</code>，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。<code>Exception in thread &#39;dubbo client x.x connector&#39; java.lang.OutOfMemoryError:PermGen space</code>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</li>
<li><strong>对永久代进行调优是很困难的。</strong>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法区的调优主要是为了降低<strong>Full GC</strong><ol>
<li>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</li>
<li><code>一般来说这个区域的回收效果比较难令人满意</code>，尤其是<strong>类型的卸载</strong>，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p><strong>字符串常量池 StringTable 为什么要调整位置？</strong></p>
<ul>
<li><p>JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而<strong>Full GC</strong>是<strong>老年代的空间不足、永久代不足</strong>时才会触发。</p>
</li>
<li><p>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。<strong>放到堆里，能及时回收内存。</strong></p>
</li>
</ul>
<h3 id="静态变量放在哪里"><a href="#静态变量放在哪里" class="headerlink" title="静态变量放在哪里"></a>静态变量放在哪里</h3><h4 id="对象实体在哪里放着？"><a href="#对象实体在哪里放着？" class="headerlink" title="对象实体在哪里放着？"></a>对象实体在哪里放着？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结论：</span></span><br><span class="line"><span class="comment"> * 1、静态引用对应的对象实体(也就是这个new byte[1024 * 1024 * 100])始终都存在堆空间，</span></span><br><span class="line"><span class="comment"> * 2、只是那个变量(相当于下面的arr变量名)在JDK6,JDK7,JDK8存放位置中有所变化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk7：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * jdk 8：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFieldTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];<span class="comment">//100MB</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(StaticFieldTest.arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK6环境下</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0031.png" alt="image-20201113224231761" />

<p>JDK7环境下</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0032.png">

<p>JDK8环境</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0033.png">

<blockquote>
<p>byte[] arr &#x3D; new byte[1024 * 1024 * 100]</p>
<p><strong>静态引用对应的对象实体</strong>(也就是这个<strong>new byte[1024 * 1024 * 100]</strong>)始终都存在堆空间</p>
<p>只是<strong>那个变量</strong>(相当于下面的arr变量名)在JDK6,JDK7,JDK8存放位置中有所变化</p>
</blockquote>
<h4 id="变量-名-存放在哪里？"><a href="#变量-名-存放在哪里？" class="headerlink" title="变量(名)存放在哪里？"></a>变量(名)存放在哪里？</h4><p>这个问题需要用JHSDB工具来进行分析，这个工具是JDK9开始自带的(JDK9以前没有)，在bin目录下可以找到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 《深入理解Java虚拟机》中的案例：</span></span><br><span class="line"><span class="comment"> * staticObj、instanceObj、localObj存放在哪里？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticObjTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">ObjectHolder</span> <span class="variable">staticObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line">        <span class="type">ObjectHolder</span> <span class="variable">instanceObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">ObjectHolder</span> <span class="variable">localObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ObjectHolder</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticObjTest</span>.Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>JDK6环境下</strong></p>
<p>1、staticObj随着Test的类型信息存放在<strong>方法区</strong></p>
<p>2、instanceObj随着<strong>Test的对象实例存放在Java堆</strong></p>
<p>3、localObject则是<strong>存放在foo()方法栈帧的局部变量表中。对象引用存在局部变量表当中，实例还是在堆</strong></p>
<p>4、测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：<strong>只要是对象实例必然会在Java堆中分配</strong>。</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0034.png">

<blockquote>
<p>1、0x00007f32c7800000(Eden区的起始地址)    —-   0x00007f32c7b50000(Eden区的终止地址)  </p>
<p>2、可以发现三个变量都在这个范围内</p>
<p>3、所以可以得到上面结论</p>
</blockquote>
<p>5、接着，找到了一个引用该staticObj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0035.png">

<p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起，<strong>存储于Java堆之中</strong>，从我们的实验中也明确验证了这一点</p>
<h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><ol>
<li><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区<strong>类型卸载</strong>的收集器存在（如<strong>JDK11时期的ZGC收集器就不支持类卸载</strong>）。</p>
</li>
<li><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
</li>
<li><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p>
</li>
<li><p>先来说说<strong>方法区内常量池</strong>之中主要存放的<strong>两大类常量：字面量和符号引用。</strong>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>
<ul>
<li><strong>类和接口的全限定名</strong></li>
<li><strong>字段的名称和描述符</strong></li>
<li><strong>方法的名称和描述符</strong></li>
</ul>
</li>
<li><p>HotSpot虚拟机对常量池的回收策略是很明确的，<strong>只要常量池中的常量没有被任何地方引用，就可以被回收。</strong></p>
</li>
<li><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p>
</li>
</ol>
<p>&#96;</p>
<p>下面也称作<strong>类卸载</strong></p>
<p>1、判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于<strong>“不再被使用的类”</strong>的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li><p>该类<strong>所有的实例</strong>都已经被回收，也就是Java堆中不存在<strong>该类及其任何派生子类的实例</strong>。</p>
</li>
<li><p>加载该类的<strong>类加载器</strong>已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</p>
</li>
<li><p>该类<strong>对应的java.lang.Class对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</p>
</li>
</ul>
<p>2、Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code> 以及 <code>-XX：+TraceClass-Loading</code>、<code>-XX：+TraceClassUnLoading</code>查看类加载和卸载信息</p>
<p>3、在大量使用<code>反射、动态代理、CGLib</code>等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
<h2 id="运行时数据区总结"><a href="#运行时数据区总结" class="headerlink" title="运行时数据区总结"></a>运行时数据区总结</h2><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0036.png">



<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><h3 id="直接内存概述"><a href="#直接内存概述" class="headerlink" title="直接内存概述"></a>直接内存概述</h3><ol>
<li><p><strong>不是虚拟机运行时数据区的一部分</strong>，也不是《Java虚拟机规范》中定义的内存区域。</p>
</li>
<li><p><strong>直接内存是在Java堆外的</strong>、直接向系统申请的内存区间。</p>
</li>
<li><p>来源于<strong>NIO</strong>，通过存在堆中的DirectByteBuffer操作Native内存</p>
</li>
<li><p>通常，访问直接内存的速度会优于Java堆。即<strong>读写性能高</strong>。</p>
</li>
<li><p>因此出于性能考虑，<strong>读写频繁的场合可能会考虑使用直接内存。</strong></p>
</li>
<li><p><strong>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  IO                  NIO (New IO / Non-Blocking IO)</span></span><br><span class="line"><span class="comment"> *  byte[] / char[]     Buffer</span></span><br><span class="line"><span class="comment"> *  Stream              Channel</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 查看直接内存的占用与释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//1GB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//直接分配本地内存空间</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存分配完毕，请求指示！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        scanner.next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存开始释放！&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>直接占用了 1G 的本地内存</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0037.jpg">

<h3 id="BIO-与-NIO"><a href="#BIO-与-NIO" class="headerlink" title="BIO 与 NIO"></a>BIO 与 NIO</h3><p><strong>非直接缓存区（BIO）</strong></p>
<p>原来采用BIO的架构，在读写本地文件时，我们需要从<strong>用户态切换成内核态</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0038.png">

<p><strong>直接缓冲区（NIO）</strong></p>
<p>NIO 直接操作物理磁盘，省去了中间过程</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0039.png">

<h3 id="直接内存与-OOM"><a href="#直接内存与-OOM" class="headerlink" title="直接内存与 OOM"></a>直接内存与 OOM</h3><ol>
<li><p>直接内存也可能导致OutofMemoryError异常</p>
</li>
<li><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p>
</li>
<li><p>直接内存的缺点为：</p>
<ul>
<li>分配回收成本较高</li>
<li>不受JVM内存回收管理</li>
</ul>
</li>
<li><p>直接内存大小可以通过MaxDirectMemorySize设置</p>
</li>
<li><p>如果不指定，默认与堆的最大值-Xmx参数值一致</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 本地内存的OOM:  OutOfMemoryError: Direct buffer memory</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BufferTest2 &#123;</span><br><span class="line">    private static final int BUFFER = 1024 * 1024 * 20;//20MB</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;ByteBuffer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        int count = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line">                list.add(byteBuffer);</span><br><span class="line">                count++;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">	at java.nio.Bits.reserveMemory(Bits.java:<span class="number">694</span>)</span><br><span class="line">	at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:<span class="number">123</span>)</span><br><span class="line">	at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:<span class="number">311</span>)</span><br><span class="line">	at com.atguigu.java.BufferTest2.main(BufferTest2.java:<span class="number">21</span>)</span><br></pre></td></tr></table></figure>

<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_006/0040.jpg">

<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><ol>
<li>百度<ul>
<li>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</li>
</ul>
</li>
<li>蚂蚁金服：<ul>
<li>Java8的内存分代改进</li>
<li>JVM内存分哪几个区，每个区的作用是什么？</li>
<li>一面：JVM内存分布&#x2F;内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？</li>
<li>二面：Eden和survior的比例分配</li>
</ul>
</li>
<li>小米：<ul>
<li>jvm内存分区，为什么要有新生代和老年代</li>
</ul>
</li>
<li>字节跳动：<ul>
<li>二面：Java的内存分区</li>
<li>二面：讲讲vm运行时数据库区</li>
<li>什么时候对象会进入老年代？</li>
</ul>
</li>
<li>京东：<ul>
<li>JVM的内存结构，Eden和Survivor比例。</li>
<li>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</li>
</ul>
</li>
<li>天猫：<ul>
<li>一面：Jvm内存模型以及分区，需要详细到每个区放什么。</li>
<li>一面：JVM的内存模型，Java8做了什么改</li>
</ul>
</li>
<li>拼多多：<ul>
<li>JVM内存分哪几个区，每个区的作用是什么？</li>
</ul>
</li>
<li>美团：<ul>
<li>java内存分配</li>
<li>jvm的永久代中会发生垃圾回收吗？</li>
<li>一面：jvm内存分区，为什么要有新生代和老年代？</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>对象的实例化内存布局与访问定位</title>
    <url>/2021/12/05/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC7%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="对象的实例化-内存布局与访问定位"><a href="#对象的实例化-内存布局与访问定位" class="headerlink" title="对象的实例化 内存布局与访问定位"></a>对象的实例化 内存布局与访问定位</h1><h2 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h2><p><strong>大厂面试题</strong></p>
<p>美团：</p>
<ol>
<li>对象在<code>JVM</code>中是怎么存储的？</li>
<li>对象头信息里面有哪些东西？</li>
</ol>
<p>蚂蚁金服：</p>
<p>二面：**<code>java</code>对象头**里有什么</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_007/0001.png">

<h3 id="对象创建的方式"><a href="#对象创建的方式" class="headerlink" title="对象创建的方式"></a>对象创建的方式</h3><ol>
<li>new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</li>
<li>Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器，并且权限必须为 public</li>
<li>Constructor的newInstance(Xxxx)：反射的方式，可以调用空参的，或者带参的构造器</li>
<li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone方法</li>
<li>使用序列化：从文件中，从网络中获取一个对象的二进制流，序列化一般用于Socket的网络传输</li>
<li>第三方库 Objenesis</li>
</ol>
<h3 id="对象创建的步骤"><a href="#对象创建的步骤" class="headerlink" title="对象创建的步骤"></a>对象创建的步骤</h3><blockquote>
<p><strong>从字节码看待对象的创建过程</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=1</span><br><span class="line">         0: new           #2                  // class java/lang/Object</span><br><span class="line">         3: dup           </span><br><span class="line">         4: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br><span class="line">        line 10: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">            8       1     1   obj   Ljava/lang/Object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1、判断对象对应的类是否加载、链接、初始化"><a href="#1、判断对象对应的类是否加载、链接、初始化" class="headerlink" title="1、判断对象对应的类是否加载、链接、初始化"></a><strong>1、判断对象对应的类是否加载、链接、初始化</strong></h4><ol>
<li>虚拟机遇到一条new指令，首先去<strong>检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用</strong>，并且<strong>检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。</strong></li>
<li>如果该类没有加载，那么<strong>在双亲委派模式下</strong>，使用<code>当前类加载器以ClassLoader + 包名 + 类名</code>为<code>key</code>进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</li>
</ol>
<h4 id="2、为对象分配内存"><a href="#2、为对象分配内存" class="headerlink" title="2、为对象分配内存"></a><strong>2、为对象分配内存</strong></h4><ol>
<li><p>首先计算对象占用空间的大小，<strong>接着在堆中划分一块内存给新对象</strong>。<strong>如果实例成员变量是引用变量，仅分配<code>引用变量空间</code>即可，即4个字节大小</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Arr</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arr</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>关于引用变量的内存，如果该引用变量<code>定义在方法内</code>，那么该<strong>引用变量</strong><code>就存储在方法所在的栈空间内</code>.</li>
</ul>
</li>
<li><p>如果内存规整：采用指针碰撞分配内存</p>
<ul>
<li>如果内存是<strong>规整</strong>的，那么虚拟机将采用的是<strong>指针碰撞法</strong>（Bump The Point）来为对象分配内存。</li>
<li><strong>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，</strong>分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。</li>
<li>如果垃圾收集器选择的是<strong>Serial</strong> ，<strong>ParNew</strong>这种基于<strong>压缩算法</strong>的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</li>
<li><strong>标记压缩（整理）算法</strong>会整理内存碎片，堆内存一存对象，另一边为空闲区域</li>
</ul>
</li>
<li><p>如果<strong>内存不规整</strong> -&gt; 像操作系统管理内存的位图(0101010000111)链表(记录空闲位置)方式</p>
<ul>
<li>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是<strong>空闲列表来为对象分配内存</strong>。</li>
<li>意思是虚拟机<strong>维护了一个列表，记录上哪些内存块是可用的</strong>，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “<strong>空闲列表</strong>（Free List）”</li>
<li>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</li>
<li><strong>标记清除算法</strong>清理过后的堆内存，就会存在很多<code>内存碎片</code>。</li>
</ul>
</li>
</ol>
<h4 id="3、处理并发问题"><a href="#3、处理并发问题" class="headerlink" title="3、处理并发问题"></a><strong>3、处理并发问题</strong></h4><ol>
<li>采用CAS+失败重试保证更新的原子性(总线锁)</li>
<li>每个线程预先分配TLAB(就是Eden区) - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）</li>
<li>在Eden区给每个线程分配一块区域</li>
</ol>
<h4 id="4、初始化分配到的空间"><a href="#4、初始化分配到的空间" class="headerlink" title="4、初始化分配到的空间"></a><strong>4、初始化分配到的空间</strong></h4><ul>
<li>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</li>
<li>给对象属性赋值的顺序：<ol>
<li>属性的默认值初始化</li>
<li>显示初始化&#x2F;代码块初始化（并列关系，谁先谁后看代码编写的顺序）</li>
<li>构造器初始化 <code>&lt;init&gt;</code></li>
</ol>
</li>
</ul>
<h4 id="5、设置对象的对象头"><a href="#5、设置对象的对象头" class="headerlink" title="5、设置对象的对象头"></a><strong>5、设置对象的对象头</strong></h4><p><code>Mark Word</code></p>
<p><img src="https://gitee.com/gu_chun_bo/picture/raw/master/image/20200308151311-525787.png" alt="1583651590160"></p>
<p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
<h4 id="6、执行init方法进行初始化"><a href="#6、执行init方法进行初始化" class="headerlink" title="6、执行init方法进行初始化"></a><strong>6、执行init方法进行初始化</strong></h4><ol>
<li><p>在Java程序的视角看来，<strong>初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</strong></p>
</li>
<li><p>因此一般来说（由字节码中跟随<strong>invokespecial</strong>指令所决定），<strong>new指令之后会接着就是执行init方法</strong>，把对象按照程序员的意愿进行初始化，<strong>这样一个真正可用的对象才算完成创建出来。</strong></p>
</li>
</ol>
<blockquote>
<p><strong>从字节码角度看 init 方法</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试对象实例化的过程</span></span><br><span class="line"><span class="comment"> *  ① 加载类元信息 - ② 为对象分配内存 - ③ 处理并发问题  - ④ 属性的默认初始化（零值初始化）</span></span><br><span class="line"><span class="comment"> *  - ⑤ 设置对象头的信息 - ⑥ 属性的显式初始化、代码块中初始化、构造器中初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  给对象的属性赋值的操作：</span></span><br><span class="line"><span class="comment"> *  ① 属性的默认初始化 - ② 显式初始化 / ③ 代码块中初始化 - ④ 构造器中初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;匿名客户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span>&#123;</span><br><span class="line">        acct = <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Customer类的字节码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> aload_0</span><br><span class="line"> <span class="number">1</span> invokespecial #<span class="number">1</span> &lt;java/lang/Object.&lt;init&gt;&gt;</span><br><span class="line"> <span class="number">4</span> aload_0</span><br><span class="line"> <span class="number">5</span> sipush <span class="number">1001</span></span><br><span class="line"> <span class="number">8</span> putfield #<span class="number">2</span> &lt;com/atguigu/java/Customer.id&gt;</span><br><span class="line"><span class="number">11</span> aload_0</span><br><span class="line"><span class="number">12</span> ldc #<span class="number">3</span> &lt;匿名客户&gt;</span><br><span class="line"><span class="number">14</span> putfield #<span class="number">4</span> &lt;com/atguigu/java/Customer.name&gt;</span><br><span class="line"><span class="number">17</span> aload_0</span><br><span class="line"><span class="number">18</span> <span class="keyword">new</span> #<span class="number">5</span> &lt;com/atguigu/java/Account&gt;</span><br><span class="line"><span class="number">21</span> dup</span><br><span class="line"><span class="number">22</span> invokespecial #<span class="number">6</span> &lt;com/atguigu/java/Account.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">25</span> putfield #<span class="number">7</span> &lt;com/atguigu/java/Customer.acct&gt;</span><br><span class="line"><span class="number">28</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<ul>
<li>init() 方法的字节码指令：<ul>
<li>属性的默认值初始化：<code>id = 1001;</code></li>
<li>显示初始化&#x2F;代码块初始化：<code>name = &quot;匿名客户&quot;;</code></li>
<li>构造器初始化：<code>acct = new Account();</code></li>
</ul>
</li>
</ul>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_007/0002.png">



<blockquote>
<p><strong>内存布局总结</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;匿名客户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span>&#123;</span><br><span class="line">        acct = <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">cust</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图解内存布局</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_007/0003.png">

<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p><strong>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_007/0004.png">

<p>定位，通过栈上reference访问</p>
<p><strong>对象的两种访问方式：句柄访问和直接指针</strong></p>
<p><strong>1、句柄访问</strong></p>
<ol>
<li>缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低</li>
<li>优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_007/0005.png">

<p><strong>2、直接指针（HotSpot采用）</strong></p>
<ol>
<li>优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</li>
<li>缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_007/0006.png">

]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>执行引擎</title>
    <url>/2021/12/05/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC8%E7%AB%A0-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><h2 id="执行引擎概述"><a href="#执行引擎概述" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h2><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_008/0001.png">

<h3 id="执行引擎概述-1"><a href="#执行引擎概述-1" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h3><ol>
<li>执行引擎是Java虚拟机核心的组成部分之一。</li>
<li>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<strong>虚拟机的执行引擎则是由软件自行实现的</strong>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<strong>能够执行那些不被硬件直接支持的指令集格式</strong>。</li>
<li>JVM的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</li>
<li>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是<strong>将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以</strong>。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_008/0002.png">

<p>1、前端编译：从Java程序员-字节码文件的这个过程叫前端编译</p>
<p>2、执行引擎这里有两种行为：一种是解释执行，一种是编译执行（这里的是后端编译）。</p>
<h3 id="执行引擎工作过程"><a href="#执行引擎工作过程" class="headerlink" title="执行引擎工作过程"></a>执行引擎工作过程</h3><blockquote>
<p><strong>执行引擎工作过程</strong></p>
</blockquote>
<ol>
<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li>
<li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li>
<li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li>
<li>从外观上来看，所有的Java虚拟机的执行引擎输入、处理、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行、即时编译的等效过程，输出的是执行过程。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_008/0003.png">



<h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><h3 id="解释执行和即时编译"><a href="#解释执行和即时编译" class="headerlink" title="解释执行和即时编译"></a>解释执行和即时编译</h3><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤：</p>
<ol>
<li><p>前面橙色部分是编译生成生成字节码文件的过程（javac编译器来完成，也就是前端编译器），和JVM没有关系。</p>
</li>
<li><p>后面绿色（解释执行）和蓝色（即时编译）才是JVM需要考虑的过程</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_008/0004.png">
    

<ol start="3">
<li><p>javac编译器（前端编译器）流程图如下所示：</p>
 <img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_008/0005.png">

 
</li>
<li><p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示</p>
 <img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_008/0006.png"></li>
</ol>
<h3 id="什么是解释器？什么是JIT编译器？"><a href="#什么是解释器？什么是JIT编译器？" class="headerlink" title="什么是解释器？什么是JIT编译器？"></a>什么是解释器？什么是JIT编译器？</h3><ol>
<li>解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用<strong>逐行</strong>解释的方式<strong>执行</strong>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li>
<li>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码<strong>一次性直接</strong>编译成和本地机器平台相关的机器语言，<strong>但并不是马上执行</strong>。</li>
</ol>
<p><strong>为什么Java是半编译半解释型语言？</strong></p>
<ol>
<li>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</li>
<li>现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</li>
<li>JIT编译器将字节码翻译成本地代码后，就可以做一个缓存操作，存储在方法区的JIT 代码缓存中（执行效率更高了），并且在翻译成本地代码的过程中可以做优化。</li>
</ol>
<p><strong>用图总结一下</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_008/0007.png">

<h2 id="机器码-指令-汇编语言"><a href="#机器码-指令-汇编语言" class="headerlink" title="机器码 指令 汇编语言"></a>机器码 指令 汇编语言</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><ol>
<li>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</li>
<li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li>
<li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li>
<li>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li>
</ol>
<h3 id="指令和指令集"><a href="#指令和指令集" class="headerlink" title="指令和指令集"></a>指令和指令集</h3><p><strong>指令</strong></p>
<ol>
<li><p>由于机器码是由0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</p>
</li>
<li><p>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</p>
</li>
<li><p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</p>
</li>
</ol>
<p><strong>指令集</strong></p>
<p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。如常见的</p>
<ol>
<li>x86指令集，对应的是x86架构的平台</li>
<li>ARM指令集，对应的是ARM架构的平台</li>
</ol>
<h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><ol>
<li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li>
<li>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。</li>
<li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</li>
<li>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译（汇编）成机器指令码，计算机才能识别和执行。</li>
</ol>
<h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><ol>
<li><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</p>
</li>
<li><p>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_008/0008.png">



<h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><ol>
<li><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p>
</li>
<li><p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p>
</li>
<li><p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p>
</li>
<li><p>字节码典型的应用为：Java bytecode</p>
</li>
</ol>
<h3 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h3><p><strong>编译过程又可以分成两个阶段：编译和汇编。</strong></p>
<ol>
<li><p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p>
</li>
<li><p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_008/0009.png">



<h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><h3 id="为什么要有解释器"><a href="#为什么要有解释器" class="headerlink" title="为什么要有解释器"></a>为什么要有解释器</h3><ol>
<li><p>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式由高级语言直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法（也就是产生了一个中间产品<strong>字节码</strong>）。</p>
</li>
<li><p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
</li>
<li><p>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_008/0010.png">



<h3 id="解释器的分类"><a href="#解释器的分类" class="headerlink" title="解释器的分类"></a>解释器的分类</h3><ol>
<li>在Java的发展历史里，一共有两套解释执行器，即古老的<strong>字节码解释器</strong>、现在普遍使用的<strong>模板解释器</strong>。<ul>
<li>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</li>
<li>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</li>
</ul>
</li>
<li>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。<ul>
<li>Interpreter模块：实现了解释器的核心功能</li>
<li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li>
</ul>
</li>
</ol>
<h3 id="解释器的现状"><a href="#解释器的现状" class="headerlink" title="解释器的现状"></a>解释器的现状</h3><ol>
<li><p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C&#x2F;C++程序员所调侃。</p>
</li>
<li><p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</p>
</li>
<li><p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p>
</li>
</ol>
<h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><h3 id="Java-代码执行的分类"><a href="#Java-代码执行的分类" class="headerlink" title="Java 代码执行的分类"></a>Java 代码执行的分类</h3><ol>
<li><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p>
</li>
<li><p>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p>
</li>
<li><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。<strong>它采用解释器与即时编译器并存的架构</strong>。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p>
</li>
<li><p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++ 程序一较高下的地步。</p>
</li>
</ol>
<h3 id="为啥我们还需要解释器呢？"><a href="#为啥我们还需要解释器呢？" class="headerlink" title="为啥我们还需要解释器呢？"></a>为啥我们还需要解释器呢？</h3><ol>
<li><p>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p>
</li>
<li><p>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</p>
</li>
</ol>
<p><strong>首先明确两点：</strong></p>
<ol>
<li>当程序启动后，解释器可以马上发挥作用，<strong>响应速度快</strong>，省去编译的时间，立即执行。</li>
<li>编译器要想发挥作用，把代码编译成本地代码，<strong>需要一定的执行时间</strong>，但编译为本地代码后，执行效率高。</li>
</ol>
<p><strong>所以：</strong></p>
<ol>
<li>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</li>
<li>在此模式下，在Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</li>
<li>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）。</li>
</ol>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul>
<li>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</li>
</ul>
<ol>
<li><p>注意解释执行与编译执行在线上环境微妙的辩证关系。<strong>机器在热机状态（已经运行了一段时间叫热机状态）可以承受的负载要大于冷机状态（刚启动的时候叫冷机状态）</strong>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p>
</li>
<li><p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1&#x2F;8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1&#x2F;2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—<strong>阿里团队</strong></p>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_008/0011.png">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JITTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="string">&quot;让天下没有难学的技术&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过 JVisualVM 查看 JIT 编译器执行的编译次数</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_008/0012.png">



<h3 id="JIT编译器相关概念"><a href="#JIT编译器相关概念" class="headerlink" title="JIT编译器相关概念"></a>JIT编译器相关概念</h3><ol>
<li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程。</li>
<li>也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。</li>
<li>还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。（可能是后续发展的趋势）</li>
</ol>
<p><strong>典型的编译器：</strong></p>
<ol>
<li>前端编译器：Sun的javac、Eclipse JDT中的增量式编译器（ECJ）。</li>
<li>JIT编译器：HotSpot VM的C1、C2编译器。</li>
<li>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</li>
</ol>
<h3 id="热点代码及探测方式"><a href="#热点代码及探测方式" class="headerlink" title="热点代码及探测方式"></a>热点代码及探测方式</h3><ol>
<li>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用<strong>执行的频率</strong>而定。</li>
<li>关于那些需要被编译为本地代码的字节码，也被称之为<strong>“热点代码”</strong>，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出<strong>深度优化</strong>，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</li>
<li>一个被多次调用的方法，或者是<strong>一-个方法体内部循环次数较多的循环体</strong>都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR (On StackReplacement)编译。</li>
<li>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</li>
<li><strong>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</strong>。</li>
<li>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。<ol>
<li>方法调用计数器用于统计方法的调用次数</li>
<li>回边计数器则用于统计循环体执行的循环次数</li>
</ol>
</li>
</ol>
<h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><ol>
<li><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</p>
</li>
<li><p>这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</p>
</li>
<li><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本</p>
<ul>
<li>如果存在，则优先使用编译后的本地代码来执行</li>
<li>如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。<ul>
<li>如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</li>
<li>如果未超过阈值，则使用解释器对字节码文件解释执行</li>
</ul>
</li>
</ul>
</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_008/0013.png">



<h4 id="热度衰减"><a href="#热度衰减" class="headerlink" title="热度衰减"></a>热度衰减</h4><ol>
<li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<strong>一段时间之内方法被调用的次数</strong>。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）（半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄）</li>
<li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li>
<li>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</li>
</ol>
<h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_008/0014.png">



<h3 id="HotSpotVM可以设置程序执行方法"><a href="#HotSpotVM可以设置程序执行方法" class="headerlink" title="HotSpotVM可以设置程序执行方法"></a>HotSpotVM可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p>
<ol>
<li>-Xint：完全采用解释器模式执行程序；</li>
<li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li>
<li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_008/0015.png">



<p><strong>代码测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试解释器模式和JIT编译模式</span></span><br><span class="line"><span class="comment"> *  -Xint  : 6520ms</span></span><br><span class="line"><span class="comment"> *  -Xcomp : 950ms</span></span><br><span class="line"><span class="comment"> *  -Xmixed : 936ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntCompTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        testPrimeNumber(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPrimeNumber</span><span class="params">(<span class="type">int</span> count)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">//计算100以内的质数</span></span><br><span class="line">            label:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt;= <span class="number">100</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>;k &lt;= Math.sqrt(j);k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j % k == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span> label;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//System.out.println(j);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结论：只用解释器执行是真的慢</p>
<h3 id="HotSpotVM-JIT编译器-分类"><a href="#HotSpotVM-JIT编译器-分类" class="headerlink" title="HotSpotVM JIT编译器 分类"></a>HotSpotVM JIT编译器 分类</h3><p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p>
<ol>
<li>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；<ul>
<li>C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。</li>
</ul>
</li>
<li>-server：指定Java虚拟机运行在server模式下，并使用C2编译器。<ul>
<li>C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。（使用C++）</li>
</ul>
</li>
</ol>
<h4 id="C1和C2编译器不同的优化策略"><a href="#C1和C2编译器不同的优化策略" class="headerlink" title="C1和C2编译器不同的优化策略"></a>C1和C2编译器不同的优化策略</h4><ol>
<li>在不同的编译器上有不同的<strong>优化策略</strong>，C1编译器上主要有方法内联，去虚拟化、元余消除。<ul>
<li><strong>方法内联</strong>：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li>
<li><strong>去虚拟化</strong>：对唯一的实现樊进行内联</li>
<li><strong>冗余消除</strong>：在运行期间把一些不会执行的代码折叠掉</li>
</ul>
</li>
<li>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：<ul>
<li><strong>标量替换</strong>：用标量值代替聚合对象的属性值</li>
<li><strong>栈上分配</strong>：对于未逃逸的对象分配对象在栈而不是堆</li>
<li><strong>同步消除</strong>：清除同步操作，通常指synchronized</li>
</ul>
</li>
</ol>
<blockquote>
<p>也就是说之前的逃逸分析，只有在C2（server模式下）才会触发。那是否说明C1就用不了了？</p>
</blockquote>
<h4 id="分层编译策略"><a href="#分层编译策略" class="headerlink" title="分层编译策略"></a>分层编译策略</h4><ol>
<li>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</li>
<li>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</li>
<li>一般来讲，JIT编译出来的机器码性能比解释器解释执行的性能高</li>
<li><strong>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</strong></li>
</ol>
<h4 id="Graal-编译器"><a href="#Graal-编译器" class="headerlink" title="Graal 编译器"></a>Graal 编译器</h4><ul>
<li><p>自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器</p>
</li>
<li><p>编译效果短短几年时间就追平了G2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的）</p>
</li>
<li><p>目前，带着实验状态标签，需要使用开关参数去激活才能使用</p>
<p>-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</p>
</li>
</ul>
<p>AOT编译器</p>
<ol>
<li><p>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）</p>
</li>
<li><p>Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p>
</li>
<li><p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是<strong>在程序的运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，<strong>在程序运行之前</strong>，便将字节码转换为机器码的过程。</p>
<p> .java -&gt; .class -&gt; (使用jaotc) -&gt; .so</p>
</li>
</ol>
<p><strong>AOT编译器编译器的优缺点</strong></p>
<p><strong>最大的好处：</strong></p>
<ol>
<li>Java虚拟机加载已经预编译成二进制库，可以直接执行。</li>
<li>不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li>
<li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li>
<li>还需要继续优化中，最初只支持Linux X64 java base</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>字符串常量池</title>
    <url>/2021/12/05/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC9%E7%AB%A0-StringTable(%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0)/</url>
    <content><![CDATA[<h1 id="StringTable（字符串常量池）"><a href="#StringTable（字符串常量池）" class="headerlink" title="StringTable（字符串常量池）"></a>StringTable（字符串常量池）</h1><h2 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h2><blockquote>
<p>new String(“hello”);不入常量池</p>
</blockquote>
<ol>
<li>String：字符串，使用一对 “” 引起来表示</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;atguigu&quot;</span> ;   			<span class="comment">// 字面量的定义方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// new 对象的方式</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>String被声明为final的，不可被继承</li>
<li>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小</li>
<li>String<ul>
<li><strong>jdk8</strong>及以前内部定义了<code>final char value[]</code>用于存储字符串数据。</li>
<li><strong>JDK9</strong>时改为<code>byte[]</code></li>
</ul>
</li>
</ol>
<h2 id="为什么-JDK9-改变了-String-的结构"><a href="#为什么-JDK9-改变了-String-的结构" class="headerlink" title="为什么 JDK9 改变了 String 的结构"></a>为什么 JDK9 改变了 String 的结构</h2><blockquote>
<p> <strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/254">http://openjdk.java.net/jeps/254</a></p>
</blockquote>
<p><strong>为什么改为 byte[] 存储？</strong></p>
<ol>
<li>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。</li>
<li>从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数字符串对象只包含拉丁字符（Latin-1）。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用，产生了大量浪费。</li>
<li>之前 String 类使用 UTF-16 的 char[] 数组存储，现在改为 byte[] 数组 外加一个编码标识存储。该编码表示如果你的字符是ISO-8859-1或者Latin-1，那么只需要一个字节存。如果你是其它字符集，比如UTF-8，你仍然用两个字节存</li>
<li>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</li>
<li>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value</span><br></pre></td></tr></table></figure>

<h3 id="String-的基本特性"><a href="#String-的基本特性" class="headerlink" title="String 的基本特性"></a>String 的基本特性</h3><ul>
<li>String：代表不可变的字符序列。简称：<strong>不可变性</strong>。</li>
</ul>
<ol>
<li><strong>当对字符串重新赋值时，需要重写指定内存区域赋值</strong>，不能使用原有的value进行赋值。</li>
<li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li><strong>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</strong></li>
</ol>
<ul>
<li><strong>通过<code>字面量</code>的方式<code>（区别于new）</code>给一个字符串赋值，此时的字符串值<code>声明在字符串常量池</code>中</strong>。</li>
</ul>
<p><strong>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量定义的方式，&quot;abc&quot;存储在字符串常量池中</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">       s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">       System.out.println(s1 == s2);<span class="comment">//判断地址：true  --&gt; false</span></span><br><span class="line"></span><br><span class="line">       System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">       System.out.println(s2);<span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令</p>
<ul>
<li>取字符串 “abc” 时，使用的是同一个符号引用：**#2**</li>
<li>取字符串 “hello” 时，使用的是另一个符号引用：**#3**</li>
</ul>
<p><strong>当对<code>现有的字符串</code>进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">       s2 += <span class="string">&quot;def&quot;</span>;  <span class="comment">// StringBuilder.append()-&gt;toString()-&gt;return new String();</span></span><br><span class="line">       System.out.println(s2);<span class="comment">//abcdef</span></span><br><span class="line">       System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>当调用string的<code>replace()</code>方法修改指定字符或字符串时，也需要<code>重新指定内存区域赋值</code>，不能使用原有的value进行赋值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">    System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">    System.out.println(s2);<span class="comment">//mbc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一道笔试题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringExer</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringExer</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);<span class="comment">//good</span></span><br><span class="line">        System.out.println(ex.ch);<span class="comment">//best</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>str 的内容并没有变：“test ok” 位于<strong>字符串常量池中的另一个区域（地址）</strong>，进行赋值操作并没有修改原来 str 指向的引用的内容</p>
<h3 id="String-的底层结构"><a href="#String-的底层结构" class="headerlink" title="String 的底层结构"></a>String 的底层结构</h3><p><strong>字符串常量池是不会存储相同内容的字符串的</strong></p>
<ol>
<li>String的<strong>String Pool</strong>（字符串常量池）是一个<strong>固定大小的Hashtable</strong>，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern()方法时性能会大幅下降。</li>
<li>使用-XX:StringTablesize可设置StringTable的长度</li>
<li>在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，StringTablesize设置没有要求</li>
<li>在JDK7中，StringTable的长度默认值是60013，StringTablesize设置没有要求</li>
<li>在JDK8中，StringTable的长度默认值是60013，StringTable可以设置的最小值为1009</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0001.png">



<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0002.png">



<p><strong>测试不同 StringTable 长度下，程序的性能</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产生10万个长度不超过10的字符串，包含a-z,A-Z</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenerateString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;words.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//1 - 10</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * (<span class="number">10</span> - <span class="number">1</span> + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">            fw.write(getString(length) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">//65 - 90, 97-122</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * (<span class="number">90</span> - <span class="number">65</span> + <span class="number">1</span>) + <span class="number">65</span>) + (<span class="type">int</span>)(Math.random() * <span class="number">2</span>) * <span class="number">32</span>;</span><br><span class="line">            str += (<span class="type">char</span>)num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;words.txt&quot;</span>));</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            String data;</span><br><span class="line">            <span class="keyword">while</span>((data = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                data.intern(); <span class="comment">//如果字符串常量池中没有对应data的字符串的话，则在常量池中生成</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1009:143ms  100009:47ms</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(br != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><p>-XX:StringTableSize&#x3D;1009 ：程序耗时 143ms</p>
</li>
<li><p>-XX:StringTableSize&#x3D;100009 ：程序耗时 47ms</p>
</li>
</ul>
<h2 id="String-的内存分配"><a href="#String-的内存分配" class="headerlink" title="String 的内存分配"></a>String 的内存分配</h2><ol>
<li><p>在Java语言中有<strong>8种基本数据类型</strong>和<strong>一种比较特殊的类型String</strong>。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种<strong>常量池</strong>的概念。**<code>享元模式</code>**</p>
</li>
<li><p><strong>常量池就类似一个Java系统级别提供的缓存</strong>。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。</p>
</li>
</ol>
<ul>
<li>直接使用双引号声明出来的String对象会直接存储在常量池中。比如：<code>String info=&quot;atguigu.com&quot;;</code><br>*   如果<strong>不是用双引号声明的String对象，可以使用String提供的intern()方法。</strong>这个后面重点谈</li>
</ul>
<h3 id="不同JDK版本下字符串常量池所在的位置不同"><a href="#不同JDK版本下字符串常量池所在的位置不同" class="headerlink" title="不同JDK版本下字符串常量池所在的位置不同"></a>不同JDK版本下字符串常量池所在的位置不同</h3><ol>
<li>Java 6及以前，字符串常量池存放在<strong>永久代</strong></li>
<li>Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到<strong>Java堆</strong>内<ul>
<li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li>
<li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。</li>
</ul>
</li>
<li>Java8元空间，字符串常量在<strong>堆</strong></li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0003.png">



<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0004.png">



<h3 id="StringTable-为什么要调整？"><a href="#StringTable-为什么要调整？" class="headerlink" title="StringTable 为什么要调整？"></a>StringTable 为什么要调整？</h3><blockquote>
<p><strong>官方文档</strong>:<a href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes</a></p>
</blockquote>
<ol>
<li>为什么要调整位置？<ul>
<li>永久代的<strong>默认空间大小比较小</strong></li>
<li>永久代<strong>垃圾回收频率低</strong>，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM：PermGen Space</li>
<li><strong>堆中空间足够大，字符串可被及时回收</strong></li>
</ul>
</li>
<li>在JDK 7中，interned字符串不再在Java堆的永久代中分配，而是在Java堆的主要部分（称为年轻代和年老代）中分配，与应用程序创建的其他对象一起分配。</li>
<li>此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。</li>
</ol>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk6中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=6m -XX:MaxPermSize=6m -Xms6m -Xmx6m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=6m -Xms6m -Xmx6m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用Set保持着常量池引用，避免full gc回收常量池行为</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//在short可以取值的范围内足以让6MB的PermSize或heap产生OOM了。</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：我真没骗你，字符串真的在堆中（JDK8）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.HashMap.resize(HashMap.java:<span class="number">703</span>)</span><br><span class="line">	at java.util.HashMap.putVal(HashMap.java:<span class="number">662</span>)</span><br><span class="line">	at java.util.HashMap.put(HashMap.java:<span class="number">611</span>)</span><br><span class="line">	at java.util.HashSet.add(HashSet.java:<span class="number">219</span>)</span><br><span class="line">	at com.atguigu.java.StringTest3.main(StringTest3.java:<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="String-的基本操作"><a href="#String-的基本操作" class="headerlink" title="String 的基本操作"></a>String 的基本操作</h2><p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p>
<h3 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println();<span class="comment">//2293</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);<span class="comment">//2294</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);<span class="comment">//2303</span></span><br><span class="line">        <span class="comment">//如下的字符串&quot;1&quot; 到 &quot;10&quot;不会再次加载</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);<span class="comment">//2304</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);<span class="comment">//2304</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);<span class="comment">//2304</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方示例代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;<span class="comment">//line 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//line 2</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//line 3</span></span><br><span class="line">        <span class="type">Memory</span> <span class="variable">mem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Memory</span>();<span class="comment">//line 4</span></span><br><span class="line">        mem.foo(obj);<span class="comment">//line 5</span></span><br><span class="line">    &#125;<span class="comment">//line 9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object param)</span> &#123;<span class="comment">//line 6</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> param.toString();<span class="comment">//line 7</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;<span class="comment">//line 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析运行时内存（foo() 方法是实例方法，其实图中少了一个 this 局部变量）</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0010.png">



<h2 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h2><h3 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h3><ol>
<li><strong>常量与常量的拼接结果在常量池，原理是编译期优化</strong></li>
<li>常量池中<strong>不会存在相同内容的变量</strong></li>
<li>拼接前后，<strong>只要其中有一个是变量</strong>，结果就在堆中。**<code>变量拼接的原理是StringBuilder</code>**</li>
<li>如果<strong>拼接的结果调用intern()方法，根据该字符串是否在常量池中存在</strong>，分为：<ul>
<li>如果存在，则返回字符串在常量池中的地址</li>
<li>如果字符串常量池中不存在该字符串，则在常量池中创建一份，并返回此对象的地址</li>
</ul>
</li>
</ol>
<blockquote>
<p>String c &#x3D; new String(“a”)+new String(“b”);</p>
<p>这种创建的<strong>ab不在字符串常量池当中</strong>，而是在<strong>堆中常量池之外给对象c分配的内存空间中</strong>，<strong>即使这个时候常量池当中已经有了“ab“</strong></p>
<p><strong>StringBuilder</strong>最后调用<strong>toString()<strong>返回，但是这个toString是</strong>不会把ab加入常量池当中的</strong></p>
</blockquote>
<p><strong>1、常量与常量的拼接结果在常量池，原理是编译期优化</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">//编译期优化：等同于&quot;abc&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 最终.java编译成.class,再执行.class</span></span><br><span class="line"><span class="comment">         * String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">         * String s2 = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>从字节码指令看出：编译器做了优化，将 “a” + “b” + “c” 优化成了 “abc”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> ldc #<span class="number">2</span> &lt;abc&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line"><span class="number">3</span> ldc #<span class="number">2</span> &lt;abc&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line"><span class="number">6</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">9</span> aload_1</span><br><span class="line"><span class="number">10</span> aload_2</span><br><span class="line"><span class="number">11</span> if_acmpne <span class="number">18</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">14</span> iconst_1</span><br><span class="line"><span class="number">15</span> goto <span class="number">19</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">18</span> iconst_0</span><br><span class="line"><span class="number">19</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">22</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">25</span> aload_1</span><br><span class="line"><span class="number">26</span> aload_2</span><br><span class="line"><span class="number">27</span> invokevirtual #<span class="number">5</span> &lt;java/lang/String.equals&gt;</span><br><span class="line"><span class="number">30</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">33</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<p>IDEA 反编译 class 文件后，来看这个问题</p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0011.png">



<p><strong>2、拼接前后，只要其中有一个是变量，结果就在堆中</strong></p>
<p><strong>调用 intern() 方法，则主动将字符串对象存入字符串常量池中，并将其地址返回</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;<span class="comment">//编译期优化</span></span><br><span class="line">        <span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line">        <span class="comment">//intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span></span><br><span class="line">        <span class="comment">//如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6 “javaEEhadoop” .intern();</span><br><span class="line">        System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从字节码角度来看：拼接前后有变量，都会使用到 StringBuilder 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> ldc #<span class="number">6</span> &lt;javaEE&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line"><span class="number">3</span> ldc #<span class="number">7</span> &lt;hadoop&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line"><span class="number">6</span> ldc #<span class="number">8</span> &lt;javaEEhadoop&gt;</span><br><span class="line"><span class="number">8</span> astore_3</span><br><span class="line"><span class="number">9</span> ldc #<span class="number">8</span> &lt;javaEEhadoop&gt;</span><br><span class="line"><span class="number">11</span> astore <span class="number">4</span></span><br><span class="line"><span class="number">13</span> <span class="keyword">new</span> #<span class="number">9</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">16</span> dup</span><br><span class="line"><span class="number">17</span> invokespecial #<span class="number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">20</span> aload_1</span><br><span class="line"><span class="number">21</span> invokevirtual #<span class="number">11</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">24</span> ldc #<span class="number">7</span> &lt;hadoop&gt;</span><br><span class="line"><span class="number">26</span> invokevirtual #<span class="number">11</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">29</span> invokevirtual #<span class="number">12</span> &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">32</span> astore <span class="number">5</span></span><br><span class="line"><span class="number">34</span> <span class="keyword">new</span> #<span class="number">9</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">37</span> dup</span><br><span class="line"><span class="number">38</span> invokespecial #<span class="number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">41</span> ldc #<span class="number">6</span> &lt;javaEE&gt;</span><br><span class="line"><span class="number">43</span> invokevirtual #<span class="number">11</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">46</span> aload_2</span><br><span class="line"><span class="number">47</span> invokevirtual #<span class="number">11</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">50</span> invokevirtual #<span class="number">12</span> &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">53</span> astore <span class="number">6</span></span><br><span class="line"><span class="number">55</span> <span class="keyword">new</span> #<span class="number">9</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">58</span> dup</span><br><span class="line"><span class="number">59</span> invokespecial #<span class="number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">62</span> aload_1</span><br><span class="line"><span class="number">63</span> invokevirtual #<span class="number">11</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">66</span> aload_2</span><br><span class="line"><span class="number">67</span> invokevirtual #<span class="number">11</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">70</span> invokevirtual #<span class="number">12</span> &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">73</span> astore <span class="number">7</span></span><br><span class="line"><span class="number">75</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">78</span> aload_3</span><br><span class="line"><span class="number">79</span> aload <span class="number">4</span></span><br><span class="line"><span class="number">81</span> if_acmpne <span class="number">88</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">84</span> iconst_1</span><br><span class="line"><span class="number">85</span> goto <span class="number">89</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">88</span> iconst_0</span><br><span class="line"><span class="number">89</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">92</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">95</span> aload_3</span><br><span class="line"><span class="number">96</span> aload <span class="number">5</span></span><br><span class="line"><span class="number">98</span> if_acmpne <span class="number">105</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">101</span> iconst_1</span><br><span class="line"><span class="number">102</span> goto <span class="number">106</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">105</span> iconst_0</span><br><span class="line"><span class="number">106</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">109</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">112</span> aload_3</span><br><span class="line"><span class="number">113</span> aload <span class="number">6</span></span><br><span class="line"><span class="number">115</span> if_acmpne <span class="number">122</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">118</span> iconst_1</span><br><span class="line"><span class="number">119</span> goto <span class="number">123</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">122</span> iconst_0</span><br><span class="line"><span class="number">123</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">126</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">129</span> aload_3</span><br><span class="line"><span class="number">130</span> aload <span class="number">7</span></span><br><span class="line"><span class="number">132</span> if_acmpne <span class="number">139</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">135</span> iconst_1</span><br><span class="line"><span class="number">136</span> goto <span class="number">140</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">139</span> iconst_0</span><br><span class="line"><span class="number">140</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">143</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">146</span> aload <span class="number">5</span></span><br><span class="line"><span class="number">148</span> aload <span class="number">6</span></span><br><span class="line"><span class="number">150</span> if_acmpne <span class="number">157</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">153</span> iconst_1</span><br><span class="line"><span class="number">154</span> goto <span class="number">158</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">157</span> iconst_0</span><br><span class="line"><span class="number">158</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">161</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">164</span> aload <span class="number">5</span></span><br><span class="line"><span class="number">166</span> aload <span class="number">7</span></span><br><span class="line"><span class="number">168</span> if_acmpne <span class="number">175</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">171</span> iconst_1</span><br><span class="line"><span class="number">172</span> goto <span class="number">176</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">175</span> iconst_0</span><br><span class="line"><span class="number">176</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">179</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">182</span> aload <span class="number">6</span></span><br><span class="line"><span class="number">184</span> aload <span class="number">7</span></span><br><span class="line"><span class="number">186</span> if_acmpne <span class="number">193</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">189</span> iconst_1</span><br><span class="line"><span class="number">190</span> goto <span class="number">194</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">193</span> iconst_0</span><br><span class="line"><span class="number">194</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">197</span> aload <span class="number">6</span></span><br><span class="line"><span class="number">199</span> invokevirtual #<span class="number">13</span> &lt;java/lang/String.intern&gt;</span><br><span class="line"><span class="number">202</span> astore <span class="number">8</span></span><br><span class="line"><span class="number">204</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">207</span> aload_3</span><br><span class="line"><span class="number">208</span> aload <span class="number">8</span></span><br><span class="line"><span class="number">210</span> if_acmpne <span class="number">217</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">213</span> iconst_1</span><br><span class="line"><span class="number">214</span> goto <span class="number">218</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">217</span> iconst_0</span><br><span class="line"><span class="number">218</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">221</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接的底层细节"><a href="#字符串拼接的底层细节" class="headerlink" title="字符串拼接的底层细节"></a>字符串拼接的底层细节</h3><p><strong>举例1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span></span><br><span class="line"><span class="comment">    ① StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">    ② s.append(&quot;a&quot;)</span></span><br><span class="line"><span class="comment">    ③ s.append(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">    ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)，但不等价</span></span><br><span class="line"><span class="comment">    补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;<span class="comment">//</span></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> ldc #<span class="number">14</span> &lt;a&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line"><span class="number">3</span> ldc #<span class="number">15</span> &lt;b&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line"><span class="number">6</span> ldc #<span class="number">16</span> &lt;ab&gt;</span><br><span class="line"><span class="number">8</span> astore_3</span><br><span class="line"><span class="number">9</span> <span class="keyword">new</span> #<span class="number">9</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">12</span> dup</span><br><span class="line"><span class="number">13</span> invokespecial #<span class="number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">16</span> aload_1</span><br><span class="line"><span class="number">17</span> invokevirtual #<span class="number">11</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">20</span> aload_2</span><br><span class="line"><span class="number">21</span> invokevirtual #<span class="number">11</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">24</span> invokevirtual #<span class="number">12</span> &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">27</span> astore <span class="number">4</span></span><br><span class="line"><span class="number">29</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">32</span> aload_3</span><br><span class="line"><span class="number">33</span> aload <span class="number">4</span></span><br><span class="line"><span class="number">35</span> if_acmpne <span class="number">42</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">38</span> iconst_1</span><br><span class="line"><span class="number">39</span> goto <span class="number">43</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">42</span> iconst_0</span><br><span class="line"><span class="number">43</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">46</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><strong>举例2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   1. 字符串拼接操作不一定使用的是StringBuilder!</span></span><br><span class="line"><span class="comment">      如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span></span><br><span class="line"><span class="comment">   2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">       System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>从字节码角度来看：为变量 s4 赋值时，直接使用 #16 符号引用，即字符串常量 “ab”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> ldc #<span class="number">14</span> &lt;a&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line"><span class="number">3</span> ldc #<span class="number">15</span> &lt;b&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line"><span class="number">6</span> ldc #<span class="number">16</span> &lt;ab&gt;</span><br><span class="line"><span class="number">8</span> astore_3</span><br><span class="line"><span class="number">9</span> ldc #<span class="number">16</span> &lt;ab&gt;</span><br><span class="line"><span class="number">11</span> astore <span class="number">4</span></span><br><span class="line"><span class="number">13</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">16</span> aload_3</span><br><span class="line"><span class="number">17</span> aload <span class="number">4</span></span><br><span class="line"><span class="number">19</span> if_acmpne <span class="number">26</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">22</span> iconst_1</span><br><span class="line"><span class="number">23</span> goto <span class="number">27</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">26</span> iconst_0</span><br><span class="line"><span class="number">27</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">30</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><strong>拼接操作与 append 操作的效率对比</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        method1(100000);//4014</span></span><br><span class="line">        method2(<span class="number">100000</span>);<span class="comment">//7</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> highLevel)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; highLevel;i++)&#123;</span><br><span class="line">            src = src + <span class="string">&quot;a&quot;</span>;<span class="comment">//每次循环都会创建一个StringBuilder、String</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(src);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span> highLevel)</span>&#123;</span><br><span class="line">        <span class="comment">//只需要创建一个StringBuilder</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">            src.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(src);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><p>体会执行效率：通过<strong>StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</strong></p>
</li>
<li><p>原因：</p>
<ol>
<li>StringBuilder的append()的方式：<ul>
<li>自始至终中只创建过一个StringBuilder的对象</li>
</ul>
</li>
<li>使用String的字符串拼接方式：<ul>
<li>创建过多个StringBuilder和String（调的toString方法）的对象，内存占用更大；</li>
<li>如果进行GC，需要花费额外的时间（在拼接的过程中产生的一些中间字符串可能永远也用不到，会产生大量垃圾字符串）。</li>
</ul>
</li>
</ol>
</li>
<li><p>改进的空间：</p>
<ul>
<li>在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下，建议使用构造器实例化：</li>
<li><code>StringBuilder s = new StringBuilder(highLevel); //new char[highLevel]</code></li>
<li>这样可以避免频繁扩容</li>
</ul>
</li>
</ol>
<h2 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern() 的使用"></a>intern() 的使用</h2><h3 id="intern-方法的说明"><a href="#intern-方法的说明" class="headerlink" title="intern() 方法的说明"></a>intern() 方法的说明</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<ol>
<li><p>intern是一个<strong>native</strong>方法，调用的是底层C的方法</p>
</li>
<li><p>字符串常量池池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的<strong>与该字符串内容相等的字符串，则返回池中的字符串地址</strong>。否则，<strong>该字符串对象将被添加到池中，并返回对该字符串对象的地址</strong>。</p>
</li>
<li><p>如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。比如：</p>
<pre><code>String myInfo = new string(&quot;I love atguigu&quot;).intern();
</code></pre>
</li>
<li><p>也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p>
<pre><code>(&quot;a&quot;+&quot;b&quot;+&quot;c&quot;).intern()==&quot;abc&quot;
</code></pre>
</li>
<li><p>通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p>
</li>
</ol>
<h3 id="new-String-的说明"><a href="#new-String-的说明" class="headerlink" title="new String() 的说明"></a>new String() 的说明</h3><h4 id="new-String-“ab”-会创建几个对象？"><a href="#new-String-“ab”-会创建几个对象？" class="headerlink" title="new String(“ab”)会创建几个对象？"></a>new String(“ab”)会创建几个对象？</h4><ul>
<li><pre><code>一个对象是：new关键字在**堆空间**创建的
</code></pre>
</li>
<li><pre><code>另一个对象是：**字符串常量池中的对象&quot;ab&quot;**。 字节码指令：ldc
</code></pre>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：</span></span><br><span class="line"><span class="comment"> * new String(&quot;ab&quot;)会创建几个对象？看字节码，就知道是两个。</span></span><br><span class="line"><span class="comment"> *     一个对象是：new关键字在堆空间创建的</span></span><br><span class="line"><span class="comment"> *     另一个对象是：字符串常量池中的对象&quot;ab&quot;。 字节码指令：ldc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        <span class="comment">//str是堆中的对象，这个堆中的对象会指向字符串常量池中ab的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/String&gt;</span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line"><span class="number">4</span> ldc #<span class="number">3</span> &lt;ab&gt;</span><br><span class="line"><span class="number">6</span> invokespecial #<span class="number">4</span> &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">9</span> astore_1</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><code>0 new #2 &lt;java/lang/String&gt;</code>：在堆中创建了一个 String 对象</p>
<p><code>4 ldc #3 &lt;ab&gt;</code> ：在字符串常量池中放入 “ab”（如果之前字符串常量池中没有 “ab” 的话）</p>
<h4 id="new-String-“a”-new-String-“b”-会创建几个对象？"><a href="#new-String-“a”-new-String-“b”-会创建几个对象？" class="headerlink" title="new String(“a”) + new String(“b”) 会创建几个对象？"></a>new String(“a”) + new String(“b”) 会创建几个对象？</h4><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思考：</span></span><br><span class="line"><span class="comment"> * new String(&quot;a&quot;) + new String(&quot;b&quot;)呢？</span></span><br><span class="line"><span class="comment"> *  对象1： new StringBuilder()</span></span><br><span class="line"><span class="comment"> *  对象2： new String(&quot;a&quot;)</span></span><br><span class="line"><span class="comment"> *  对象3： 常量池中的&quot;a&quot;</span></span><br><span class="line"><span class="comment"> *  对象4： new String(&quot;b&quot;)</span></span><br><span class="line"><span class="comment"> *  对象5： 常量池中的&quot;b&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  深入剖析： StringBuilder的toString():</span></span><br><span class="line"><span class="comment"> *      对象6 ：new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment"> *       强调一下，toString()的调用，在字符串常量池中，没有生成&quot;ab&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line"><span class="number">4</span> invokespecial #<span class="number">3</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">7</span> <span class="keyword">new</span> #<span class="number">4</span> &lt;java/lang/String&gt;</span><br><span class="line"><span class="number">10</span> dup</span><br><span class="line"><span class="number">11</span> ldc #<span class="number">5</span> &lt;a&gt;</span><br><span class="line"><span class="number">13</span> invokespecial #<span class="number">6</span> &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">16</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">19</span> <span class="keyword">new</span> #<span class="number">4</span> &lt;java/lang/String&gt;</span><br><span class="line"><span class="number">22</span> dup</span><br><span class="line"><span class="number">23</span> ldc #<span class="number">8</span> &lt;b&gt;</span><br><span class="line"><span class="number">25</span> invokespecial #<span class="number">6</span> &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">28</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">31</span> invokevirtual #<span class="number">9</span> &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">34</span> astore_1</span><br><span class="line"><span class="number">35</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><strong>答案是4个或5个或6个</strong></p>
<p>字节码指令分析：</p>
<ol>
<li><code>0 new #2 &lt;java/lang/StringBuilder&gt;</code> ：拼接字符串会创建一个 <strong>StringBuilder</strong> 对象</li>
<li><code>7 new #4 &lt;java/lang/String&gt;</code> ：创建 String 对象，对应于 new String(“a”)</li>
<li><code>11 ldc #5 &lt;a&gt;</code> ：在字符串常量池中放入 “a”（如果之前字符串常量池中没有 “a” 的话）</li>
<li><code>19 new #4 &lt;java/lang/String&gt;</code> ：创建 String 对象，对应于 new String(“b”)</li>
<li><code>23 ldc #8 &lt;b&gt;</code> ：在字符串常量池中放入 “b”（如果之前字符串常量池中没有 “b” 的话）</li>
<li><code>31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;</code> ：调用 StringBuilder 的 toString() 方法，会生成一个 String 对象</li>
</ol>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0012.png">





<h3 id="有点难的面试题"><a href="#有点难的面试题" class="headerlink" title="有点难的面试题"></a>有点难的面试题</h3><h4 id="JDK6-JDK7，8中intern-的不同"><a href="#JDK6-JDK7，8中intern-的不同" class="headerlink" title="JDK6 JDK7，8中intern()的不同"></a>JDK6 JDK7，8中intern()的不同</h4><p><a href="#intern_jdk678"><strong><code>intern() 方法的练习_练习 1</code>跳转</strong></a></p>
<blockquote>
<p><strong>有点难的面试题</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * 如何保证变量s指向的是字符串常量池中的数据呢？</span><br><span class="line"> * 有两种方式：</span><br><span class="line"> * 方式一： <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;shkstart&quot;</span>;<span class="comment">//字面量定义的方式</span></span><br><span class="line"> * 方式二： 调用intern()</span><br><span class="line"> *         <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;shkstart&quot;</span>).intern();</span><br><span class="line"> *         <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;shkstart&quot;</span>).toString().intern();</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 	<span class="title class_">StringIntern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        s.intern();<span class="comment">//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        System.out.println(s == s2);<span class="comment">//jdk6：false   jdk7/8：false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         1、s3变量记录的地址为：new String(&quot;11&quot;)</span></span><br><span class="line"><span class="comment">         2、经过上面的分析，我们已经知道执行完pos_1的代码，在堆中有了一个new String(&quot;11&quot;)</span></span><br><span class="line"><span class="comment">         这样的String对象。但是在字符串常量池中没有&quot;11&quot;</span></span><br><span class="line"><span class="comment">         3、接着执行s3.intern()，在字符串常量池中生成&quot;11&quot;</span></span><br><span class="line"><span class="comment">           3-1、在JDK6的版本中，字符串常量池还在永久代，所以直接在永久代生成&quot;11&quot;,也就有了新的地址</span></span><br><span class="line"><span class="comment">           3-2、而在JDK7的后续版本中，字符串常量池被移动到了堆中，此时堆里已经有new String（&quot;11&quot;）了</span></span><br><span class="line"><span class="comment">           出于节省空间的目的，直接将堆中的那个字符串的引用地址储存在字符串常量池中。没错，字符串常量池</span></span><br><span class="line"><span class="comment">           中存的是new String（&quot;11&quot;）在堆中的地址</span></span><br><span class="line"><span class="comment">         4、所以在JDK7后续版本中，s3和s4指向的完全是同一个地址。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);<span class="comment">//pos_1</span></span><br><span class="line">        <span class="comment">//在jdk7，8中，这个s3指的是</span></span><br><span class="line">	    s3.intern();</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;<span class="comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//jdk6：false  jdk7/8：true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释的已经比较清楚了，下面看一下内存图</p>
<p><a href="#intern_jdk678"><strong><code>intern() 方法的练习_练习 1</code>跳转</strong></a></p>
<p><strong>内存分析</strong></p>
<p>JDK6 ：正常眼光判断即可</p>
<ul>
<li>new String() 即在堆中</li>
<li>str.intern() 则把字符串放入常量池中</li>
</ul>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0013.png">



<p>JDK7及后续版本，<strong>注意大坑</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0014.png">

<h4 id="面试题的拓展"><a href="#面试题的拓展" class="headerlink" title="面试题的拓展"></a>面试题的拓展</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * StringIntern.java中练习的拓展：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//执行完下一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);<span class="comment">//new String(&quot;11&quot;)</span></span><br><span class="line">        <span class="comment">//在字符串常量池中生成对象&quot;11&quot;，代码顺序换一下，实打实的在字符串常量池里有一个&quot;11&quot;对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s3 是堆中的 &quot;ab&quot; ，s4 是字符串常量池中的 &quot;ab&quot;</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s5 是从字符串常量池中取回来的引用，当然和 s4 相等</span></span><br><span class="line">        System.out.println(s5 == s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="intern-方法的练习"><a href="#intern-方法的练习" class="headerlink" title="intern() 方法的练习"></a>intern() 方法的练习</h3><p><span id='intern_jdk678'>JDK678 intern</span></p>
<p><strong>练习 1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		1、jdk6中：在字符串常量池（此时在永久代）中创建一个字符串&quot;ab&quot;</span></span><br><span class="line"><span class="comment">        2、jdk8中：字符串常量池（此时在堆中）中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，		  将此引用返回</span></span><br><span class="line"><span class="comment">        3、详解看上面</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK6</strong></p>
<p><img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0015.png" alt="image-20201116113423492"></p>
<p><strong>JDK7&#x2F;8</strong></p>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0016.png">





<p><strong>练习2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//加一行这个</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0017.png">

<p><strong>练习3</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);<span class="comment">//执行完以后，会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">        s1.intern();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>验证</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer2</span> &#123;</span><br><span class="line">    <span class="comment">// 对象内存地址可以使用System.identityHashCode(object)方法获取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//执行完以后，不会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line">        System.out.println(System.identityHashCode(s1));</span><br><span class="line">        s1.intern();</span><br><span class="line">        System.out.println(System.identityHashCode(s1));</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        System.out.println(System.identityHashCode(s2));</span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1836019240</span></span><br><span class="line"><span class="number">1836019240</span></span><br><span class="line"><span class="number">1836019240</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h3 id="intern-的效率测试（空间角度）"><a href="#intern-的效率测试（空间角度）" class="headerlink" title="intern() 的效率测试（空间角度）"></a>intern() 的效率测试（空间角度）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用intern()测试执行效率：空间使用上</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[MAX_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] data = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line"><span class="comment">//            arr[i] = new String(String.valueOf(data[i % data.length]));</span></span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length])).intern();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>1、直接 new String ：由于每个 String 对象都是 new 出来的，所以程序需要维护大量存放在堆空间中的 String 实例，程序内存占用也会变高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length]));</span><br></pre></td></tr></table></figure>

<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0018.png">



<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0019.png">

<p>2、使用 intern() 方法：由于数组中字符串的引用都指向字符串常量池中的字符串，所以程序需要维护的 String 对象更少，内存占用也更低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用了intern()方法使用了字符串常量池里的字符串，那么前面堆里的字符串便会被GC掉，这也是intern省内存的关键原因</span></span><br><span class="line">arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length])).intern();</span><br></pre></td></tr></table></figure>

<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0020.png" >



<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0021.png">



<p><strong>结论</strong>：</p>
<ol>
<li>对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用intern()方法能够节省很大的内存空间。</li>
<li>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern() 方法，就会很明显降低内存的大小。</li>
</ol>
<h2 id="StringTable-的垃圾回收"><a href="#StringTable-的垃圾回收" class="headerlink" title="StringTable 的垃圾回收"></a>StringTable 的垃圾回收</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的垃圾回收:</span></span><br><span class="line"><span class="comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringGCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">            String.valueOf(j).intern();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出结果：</p>
<ul>
<li>在 PSYoungGen 区发生了垃圾回收</li>
<li>Number of entries 和 Number of literals 明显没有 100000</li>
<li>以上两点均说明 StringTable 区发生了垃圾回收</li>
</ul>
<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0022.jpg">



<img src="https://unpkg.zhimg.com/youthlql@1.0.8/JVM/chapter_009/0023.jpg"/>



<h2 id="G1-中的-String-去重操作"><a href="#G1-中的-String-去重操作" class="headerlink" title="G1 中的 String 去重操作"></a>G1 中的 String 去重操作</h2><blockquote>
<p><strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/192">http://openjdk.java.net/jeps/192</a></p>
</blockquote>
<p>暂时了解一下，后面会详解垃圾回收器</p>
<p><strong>String去重操作的背景</strong></p>
<blockquote>
<p>注意不是字符串常量池的去重操作，字符串常量池本身就没有重复的</p>
</blockquote>
<ol>
<li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：<ul>
<li>堆存活数据集合里面String对象占了25%</li>
<li>堆存活数据集合里面重复的String对象有13.5%</li>
<li>String对象的平均长度是45</li>
</ul>
</li>
<li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，<strong>Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半String对象是重复(equals)的</strong>，重复的意思是说：**<code>str1.equals(str2)= true</code>**。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li>
</ol>
<p><strong>String 去重的的实现</strong></p>
<p><img src="/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC9%E7%AB%A0-StringTable(%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0)/image-20220220183950593.png" alt="image-20220220183950593"></p>
<blockquote>
<p>此时说的去重，是去除多个存在于<code>堆中的string对象</code>，当然也可以考虑用<code>intern()</code>进行去重，但是分析起来并不是那么容易，所以G1去重也出现了</p>
</blockquote>
<ol>
<li>当垃圾收集器工作的时候，<strong>会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象</strong>。</li>
<li>如果是，<strong>把这个对象的一个引用插入到队列中等待后续的处理。</strong>一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着<strong>从队列删除这个元素，然后尝试去重它引用的String对象。</strong></li>
<li>使用一个<strong>Hashtable</strong>来记录所有的<strong>被String对象使用的不重复的char数组</strong>。当去重的时候，会查这个Hashtable，来看堆上是否已经存在一个一模一样的char数组。</li>
<li>如果存在，String对象<strong>会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉</strong>。</li>
<li>如果<strong>查找失败，char数组会被插入到Hashtable，这样以后的时候就可以共享这个数组了</strong>。</li>
</ol>
<p><strong>命令行选项</strong></p>
<ol>
<li>UseStringDeduplication(bool) ：开启String去重，默认是不开启的，需要手动开启。</li>
<li>PrintStringDeduplicationStatistics(bool) ：打印详细的去重统计信息</li>
<li>stringDeduplicationAgeThreshold(uintx) ：达到这个年龄的String对象被认为是去重的候选对象</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>MVVC多版本并发控制</title>
    <url>/2021/06/16/MVVC/</url>
    <content><![CDATA[<h1 id="MVVC-多版本并发控制"><a href="#MVVC-多版本并发控制" class="headerlink" title="MVVC 多版本并发控制"></a>MVVC 多版本并发控制</h1><blockquote>
<p><strong>一致性读视图</strong>，即 <strong>consistent read view</strong>，用于支持 <strong>RC</strong>（Read Committed，读提交）和 <strong>RR</strong>（Repeatable Read，可重复读）隔离级别的实现。</p>
</blockquote>
<p><strong>RU</strong>：<strong>没有视图</strong>的概念，直接返回最小行数据。</p>
<p><strong>RC</strong>级别下，**<code>MVCC视图</code>会在每一个语句前创建一个**，所以在RC级别下，一个事务是可以看到另外一个事务已经提交的内容，因为它在每一次查询之前都会重新给予最新的数据创建一个新的MVCC视图。 </p>
<p><strong>RR</strong>级别下，**<code>MVCC视图</code>是在开始事务的时候就创建好了**，这个视图会一直使用，直到该事务结束。 这里要注意不同的隔离级别他们的一致性事务视图创建的时间点是不同的。  </p>
<p><strong>Serial</strong>：<strong>通过锁来实现数据访问，每个事务实现串行化,没有视图的概念。</strong></p>
<blockquote>
<p><strong>RR-&gt;事务创建时</strong>：为第一条SELECT执行时，但是如果<code>start transaction with consistent snaptshot;</code>会直接创建read view</p>
<p>tips：<code>Oracle</code>默认隔离级别RC</p>
</blockquote>
<h2 id="“快照”在-MVCC-里是怎么工作的？"><a href="#“快照”在-MVCC-里是怎么工作的？" class="headerlink" title="“快照”在 MVCC 里是怎么工作的？"></a><strong>“快照”在 MVCC 里是怎么工作的？</strong></h2><p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 <strong>transaction id</strong>。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。每次事务更新数据的时候，都会生成一个新的数据版本，将<strong>transaction id -&gt; trx_id</strong></p>
<ul>
<li>transaction id更新数据的事务才会生成对应的数据版本</li>
<li>版本中包含本次数据的值,事务id,还有一个引用(指向上一个数据版本)</li>
</ul>
<blockquote>
<p>这个<strong>transaction id</strong>，是Mysql记录了一个全局变量，每次申请事务的时候会++，为8字节，到顶之后会重置从0开始，Mysql重启也会让该值从0开始，不过不用担心，<strong>因为Mysql重启之后就会用新的binlog去记录</strong>，不用担心一个binlog中出现重复的</p>
</blockquote>
<p><strong>只记录了V4版本，V1，V2，V3以前的版本都是通过当前V4版本通过回滚操作日志undo log计算生成的</strong></p>
<img src="https://static001.geekbang.org/resource/image/68/ed/68d08d277a6f7926a41cc5541d3dfced.png" alt="img" style="zoom:67%;" />

<p><strong><mark>InnoDB</mark></strong> 为每个事务构造了一个<strong>数组</strong>，用来保存这个<strong>事务启动瞬间</strong>，当前正在<strong>“活跃”</strong>的所有<strong>事务 ID</strong>。“活跃”指的就是，**<code>启动了但还没提交</code>。**</p>
<p><strong>低水位:</strong><code>数组</code>里面事务 ID 的最小值 <code>LW = MIN(Array)</code></p>
<p>**高水位:**当前<code>系统里面</code>已经创建过的事务 ID 的最大值加 1 。<code>HW = MAX(System)+1</code></p>
<img src="Mysql45/tmpAD2F.png" alt="tmpAD2F" style="zoom:50%;" />

<ul>
<li>&lt;&#x3D;低水位：可见</li>
<li>低水位&lt; now &lt;高水位：<ul>
<li>不在活跃数组：可见 <strong>事务晚开启，早提交</strong></li>
<li>在活跃数组：不可见</li>
</ul>
</li>
<li>&gt;高水位：不可见</li>
</ul>
<p>假如当前事务进来，访问的数据版本<strong>在高低水位中间，但是不在活跃数组中，说明已经提交了</strong>，是可见的直接返回，如果发现是<strong>在活跃数组中的，则不能访问</strong>，通过undo log向前推，直到发现<strong>不在活跃数组或者&lt;&#x3D;低水位</strong>，就可以访问该版本数据,在高水位和低水位之间的也有可能被看到，情况是：事务晚开启，早提交</p>
<blockquote>
<p>**<code>update</code><strong>和</strong><code>for update</code>**加锁的语句都会无视上面规则，统统”当前读”读取最新的版本数据</p>
</blockquote>
<p><strong>Update更新</strong>数据都是<strong>先读后写</strong>的，而这个读，只能读当前的值，称为“<strong>当前读</strong>”（current read）。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>first</title>
    <url>/2021/06/16/Mysql_log/</url>
    <content><![CDATA[<h1 id="Log-amp-执行状况查询"><a href="#Log-amp-执行状况查询" class="headerlink" title="Log &amp; 执行状况查询"></a>Log &amp; 执行状况查询</h1><p><strong><mark>WAL</mark><strong>的全称是</strong><code>Write-Ahead Logging</code><strong>，它的关键点就是</strong>先写日志，再写磁盘</strong></p>
<p>Binlog：粉板</p>
<p>Redo Log:记账板</p>
<h2 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h2><p>:point_right:<a href="#log%E5%8C%BA%E5%88%AB"><strong><code>和Redo log区别</code></strong></a></p>
<p>**<code>环形日志：更新追上写入之后需要等写入磁盘进度不能再写</code>**断电之后依旧存在</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> t <span class="comment">/*comment*/</span> <span class="keyword">where</span> a<span class="operator">&gt;=</span><span class="number">4</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;=</span><span class="string">&#x27;2018-11-10&#x27;</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>statement模式</strong></p>
<p>statement下直接就记录这条语句，甚至连注释都记录了</p>
<p>运行这条 delete 命令产生了一个 warning，原因是当前 binlog 设置的是 statement 格式，并且语句中有 limit，所以这个命令可能是 unsafe 的。</p>
<p>为什么这么说呢？这是因为 delete 带 limit，很可能会出现主备数据不一致的情况。比如上面这个例子：</p>
<ol>
<li>如果 delete 语句使用的是索引 a，那么会根据索引 a 找到第一个满足条件的行，也就是说删除的是 a&#x3D;4 这一行；</li>
<li>但如果使用的是索引 t_modified，那么删除的就是 t_modified&#x3D;’2018-11-09’也就是 a&#x3D;5 这一行。</li>
</ol>
<blockquote>
<p>到了从库上，不清楚用的是哪个<strong>索引</strong></p>
</blockquote>
<p><strong>row模式</strong></p>
<p>当 binlog_format 使用 <strong>row</strong> 格式的时候，binlog 里面记录了真实删除行的主键 id，这样 binlog 传到备库去的时候，就肯定会删除 id&#x3D;4 的行，不会有主备删除不同行的问题。</p>
<p>记录的信息很全-&gt;<code>id=4 and a=4 and t_modified=1541797288</code>全都记录下来了</p>
<p><strong>mixed模式</strong></p>
<p><img src="/Mysql45/tmp1165.png" alt="tmp1165"></p>
<p><strong>binlog的写入机制<a name="binlog写入机制"></a></strong></p>
<p><strong>binlog Cache</strong></p>
<img src="https://static001.geekbang.org/resource/image/9e/3e/9ed86644d5f39efb0efec595abb92e3e.png" alt="img" style="zoom: 82%;" />

<p><img src="/Mysql45/tmp9371.png" alt="tmp9371"></p>
<p><strong>每个线程有自己 binlog cache，但是共用同一份 binlog 文件。</strong></p>
<ul>
<li>图中的 <strong>write</strong>，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，</li>
<li>所以速度比较快。图中的 <strong>fsync</strong>，才是将数据持久化到磁盘的操作。一般情况下，我们认为 fsync 才占磁盘的 IOPS。</li>
</ul>
<h2 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h2><p><span name="log区别"><strong><mark>BinLog Redo Log区别</mark></strong></span></p>
<blockquote>
<ol>
<li><strong>redo log</strong> 是 **<code>InnoDB 引擎</code>**特有的；binlog 是 MySQL 的 <strong><code>Server</code></strong> 层实现的，所有引擎都可以使用。</li>
<li><strong>redo log</strong> 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑。</li>
<li><strong>redo log</strong> 是循环写的，空间固定会用完（4个文件，每个文件1Ｇ）；binlog 是可以追加写入的。“追加写”是指 binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
<li><strong>binlog</strong> 日志没有 <strong><code>crash-safe</code></strong> 的能力，只能用于**<code>归档</code>**。而 redo log 来实现 <strong><code>crash-safe</code></strong> 能力。</li>
<li><strong>redo log</strong> 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。</li>
<li>sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。</li>
<li>binlog有两种模式，statement 格式是记sql语句， row格式是记录行的内容，记两条，更新前和更新后都有。</li>
</ol>
</blockquote>
<blockquote>
<p>当有一条记录需要更新的时候，InnoDB引擎就会<strong>先把记录写到redo log 里面，并更新内存</strong>，<strong>这个时候更新就算完成了</strong>。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在**<code>系统比较空闲的时候做</code><strong>,如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程</strong>IO成本<strong>、</strong>查找成本**都很高。</p>
</blockquote>
<img src="Mysql45/image-20220320114603986.png" alt="image-20220320114603986" style="zoom:50%;" />





<p><strong>redo log buffer</strong>。事务在执行过程中，生成的 <strong>redo log 是要<code>先写到 redo log buffer</code> 的</strong>。</p>
<p><strong>redo log buffer</strong>里的内容<strong>不是每次生成后都要直接持久化到磁盘</strong></p>
<ul>
<li>如果事务执行期间 MySQL 发生异常重启，那这部分日志就丢了。由于事务并没有提交，所以这时日志丢了也不会有损失。</li>
</ul>
<p><strong><mark>刷脏页</mark></strong></p>
<blockquote>
<p>flush: 把内存里的数据写入磁盘的过程</p>
<p>连坐: 如果**<code>附近</code>**的也是脏页，会一块刷</p>
</blockquote>
<p>**<code>innodb_io_capacity</code>**磁盘读写能力</p>
<p>**<code>innodb_max_dirty_pages_pct</code>**脏页比例上限</p>
<p><strong><mark>Redo log写入机制</mark></strong><a name="redolog写入机制"></a></p>
<p><strong><code>nnodb_flush_log_at_trx_commit参数控制形式</code></strong>:</p>
<ul>
<li>设置为<strong>0</strong>的时候，表示每次事务提交时都<strong>只是把redo log留在redo log buffer中</strong></li>
<li>设置为<strong>1</strong>的时候，表示每次事务提交时都<strong>将redo log直接持久化到磁盘</strong></li>
<li>设置为<strong>2</strong>的时候，表示每次事务提交时都<strong>只是把redo log写到page cache</strong></li>
</ul>
<p>InnoDB有一个<strong>后台线程</strong>，每隔<strong>1</strong>秒，就会把redo log buffer中的日志，调用<strong>write</strong>写到文件系统的<strong>page cache</strong>，然后调用<strong>fsync</strong>持久化到磁盘。</p>
<p><strong><code>除此之外</code></strong>:</p>
<ul>
<li>一种是，<strong>redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。</strong>注意，由于这个事务并没有提交，所以这个写盘动作<strong>只是 write</strong>，而<strong>没有调用 fsync</strong>，也就是<strong>只留在了文件系统的 page cache</strong>。</li>
<li>另一种是，<strong>并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。</strong>假设一个事务 A 执行到一半，已经写了一些 redo log 到 buffer 中，这时候有另外一个线程的事务 B 提交，如果 <code>innodb_flush_log_at_trx_commit</code> 设置的是 1，那么按照这个参数的逻辑，事务 B 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，<strong>就会带上事务 A 在 redo log buffer 里的日志一起持久化到磁盘。</strong></li>
</ul>
<p><img src="/Mysql45/tmp9D83.png" alt="tmp9D83"></p>
<img src="Mysql45/tmpDE1D.png" alt="tmpDE1D" style="zoom:80%;" />



<blockquote>
<p>通常我们说 MySQL 的“<strong>双 1”配置</strong>，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。</p>
</blockquote>
<p><strong>组提交（group commit）</strong></p>
<blockquote>
<p><strong>LSN</strong>:<strong>日志逻辑序列号</strong>（log sequence number，LSN）。LSN 是单调递增的，<strong>用来对应 redo log 的一个个写入点。每次写入长度为 length 的 redo log， LSN 的值就会加上 length。</strong></p>
</blockquote>
<ol>
<li>trx1 是第一个到达的，会被选为这组的 leader；</li>
<li>等 trx1 要开始写盘的时候，这个组里面已经有了三个事务，这时候 LSN 也变成了 160；</li>
<li>trx1 去写盘的时候，带的就是 LSN&#x3D;160，因此等 trx1 返回时，所有 LSN 小于等于 160 的 redo log，都已经被持久化到磁盘；</li>
<li>这时候 trx2 和 trx3 就可以直接返回了。</li>
</ol>
<p><strong>所以一个组里面组员越好</strong></p>
<img src="Mysql45/933fdc052c6339de2aa3bf3f65b188cc.png" alt="img" style="zoom: 50%;" />

<p><strong>两阶段提交细化</strong></p>
<img src="https://static001.geekbang.org/resource/image/5a/28/5ae7d074c34bc5bd55c82781de670c28.png" alt="img" style="zoom: 50%;" />

<blockquote>
<p>MySQL 为了让<strong>组提交的效果更好</strong>，把 redo log 做 fsync 的时间拖到了步骤 1 之后。也就是说，上面的图变成了这样：binlog 也可以组提交了。在执行图 5 中第 4 步把 binlog fsync 到磁盘时，<strong>如果有多个事务的 binlog 已经写完了</strong>，也是一起持久化的，这样也可以减少 IOPS 的消耗。</p>
</blockquote>
<h2 id="崩溃时恢复流程"><a href="#崩溃时恢复流程" class="headerlink" title="崩溃时恢复流程"></a>崩溃时恢复流程</h2><p>崩溃恢复时的<strong>判断规则</strong>。</p>
<ol>
<li>如果**<mark>redo log</mark><strong>里面的事务是完整的，也就是已经有了</strong><code>commit标识</code>**，则直接提交；</li>
<li>如果**<mark>redo log</mark><strong>里面的事务</strong><code>只有完整的prepare</code><strong>，则判断对应的事务</strong><mark>binlog</mark><code>是否存在并完整</code><strong>：<br>a. 如果</strong><code>是</code><strong>，则</strong>提交**事务；<br>b. <strong><code>否则</code><strong>，</strong>回滚</strong>事务。</li>
</ol>
<h2 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h2><img src="https://static001.geekbang.org/resource/image/68/ed/68d08d277a6f7926a41cc5541d3dfced.png" alt="img" style="zoom:67%;" />

<p>Undog log就是指的<strong>V4到V3中间那条虚线</strong>：数据版本<strong>只存在V4</strong>，其余的版本都是<strong>通过Undo log推导</strong>出来的，Undo log中记录了该如何操作返回到<strong>上一个状态</strong></p>
<hr>
<h2 id="Slow-Log-慢查询日志"><a href="#Slow-Log-慢查询日志" class="headerlink" title="Slow Log 慢查询日志"></a>Slow Log 慢查询日志</h2><p>在MySQL中，会引发性能问题的**<code>慢查询</code>**，大体有以下三种可能：</p>
<ol>
<li><strong>索引没有设计好；</strong></li>
<li><strong>SQL语句没写好；</strong> 用了函数？varchar索引和数字对比？uft编码问题？</li>
<li><strong>MySQL选错了索引。</strong> <a href="#%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95"><strong>:point_right:<code>选错索引</code></strong></a></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> slow_query_log_file<span class="operator">=</span><span class="string">&#x27;/xxx/mysql-slow.log&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>MySQL慢查询日志是MySQL提供的一种日志记录，用来记录执行时长超过指定时长的查询语句，具体指运行时间超过 <code>long_query_time</code> 值的 SQL 语句，则会被记录到慢查询日志中。</p>
<p><code>long_query_time</code> 默认值是 <code>10</code> ，单位是 <code>s</code>，即默认是 10秒 。默认情况下，MySQL数据库并不会开启慢查询日志，需要手动设置这个参数。</p>
<p>通过慢查询日志，可以查找出哪些查询语句的执行效率很低，以便进行优化。一般建议开启，它对服务器性能的影响微乎其微，但是可以记录MySQL服务器上执行了很长时间的查询语句。慢查询日志可以帮助我们定位mysql性能问题所在。</p>
<p>内容：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="type">Time</span>: <span class="number">2017</span><span class="number">-11</span><span class="number">-22</span>T12:<span class="number">22</span>:<span class="number">32.554299</span>Z</span><br><span class="line"># <span class="keyword">User</span><span class="variable">@Host</span>: www[www] @  [<span class="number">192.168</span><span class="number">.10</span><span class="number">.2</span>]  Id: <span class="number">580785559</span></span><br><span class="line"># Query_time: <span class="number">24.354270</span>  Lock_time: <span class="number">0.000238</span> Rows_sent: <span class="number">1</span>  Rows_examined: <span class="number">511156</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">timestamp</span><span class="operator">=</span><span class="number">1511353352</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mo_user <span class="keyword">WHERE</span> email <span class="operator">=</span> <span class="string">&#x27;chxxx@hotmail.com&#x27;</span> LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>其中参数说明如下：</p>
<ul>
<li>log 记录的时间：# Time: 2017-11-22T12:22:32.554299Z</li>
<li>SQL 的执行主机：# User@Host: www[www] @ [192.168.10.2] Id: 580785559</li>
<li>SQL 的<strong>执行信息</strong>（执行时间(单位：s)，锁时间，返回结果行数，查询总行数）：# Query_time: 24.354270 Lock_time: 0.000238 Rows_sent: 1 Rows_examined: 511156;</li>
<li>SQL 执行发生的时间：SET timestamp&#x3D;1511353352;</li>
<li>SQL 的执行内容：SELECT * FROM mo_user WHERE email &#x3D; ‘<a href="mailto:&#99;&#x68;&#120;&#x78;&#120;&#x40;&#104;&#111;&#x74;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;">&#99;&#x68;&#120;&#x78;&#120;&#x40;&#104;&#111;&#x74;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;</a>‘ LIMIT 1;</li>
</ul>
<h2 id="mysqldumpslow-慢查询"><a href="#mysqldumpslow-慢查询" class="headerlink" title="mysqldumpslow 慢查询"></a>mysqldumpslow 慢查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldumpslow <span class="operator">-</span>s c <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>var<span class="operator">/</span>run<span class="operator">/</span>mysqld<span class="operator">/</span>mysqld<span class="operator">-</span>slow.log # 取出使用最多的<span class="number">10</span>条慢查询</span><br><span class="line"></span><br><span class="line">mysqldumpslow <span class="operator">-</span>s t <span class="operator">-</span>t <span class="number">3</span> <span class="operator">/</span>var<span class="operator">/</span>run<span class="operator">/</span>mysqld<span class="operator">/</span>mysqld<span class="operator">-</span>slow.log # 取出查询时间最慢的<span class="number">3</span>条慢查询</span><br><span class="line"></span><br><span class="line">mysqldumpslow <span class="operator">-</span>s t <span class="operator">-</span>t <span class="number">10</span> <span class="operator">-</span>g “<span class="keyword">left</span> <span class="keyword">join</span>” <span class="operator">/</span>database<span class="operator">/</span>mysql<span class="operator">/</span>slow<span class="operator">-</span>log # 得到按照时间排序的前<span class="number">10</span>条里面含有左连接的查询语句</span><br><span class="line"></span><br><span class="line">mysqldumpslow <span class="operator">-</span>s r <span class="operator">-</span>t <span class="number">10</span> <span class="operator">-</span>g <span class="string">&#x27;left join&#x27;</span> <span class="operator">/</span>var<span class="operator">/</span>run<span class="operator">/</span>mysqld<span class="operator">/</span>mysqld<span class="operator">-</span>slow.log # 按照扫描行数最多的</span><br></pre></td></tr></table></figure>

<p>显示信息：</p>
<blockquote>
<p>注意: 使用mysqldumpslow的分析结果不会显示具体完整的sql语句,<strong>只会显示sql的组成结构;</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Count: <span class="number">1</span>  <span class="type">Time</span><span class="operator">=</span><span class="number">1.91</span>s (<span class="number">1</span>s)  Lock<span class="operator">=</span><span class="number">0.00</span>s (<span class="number">0</span>s)  <span class="keyword">Rows</span><span class="operator">=</span><span class="number">1000.0</span> (<span class="number">1000</span>), vgos_dba[vgos_dba]@[<span class="number">10.130</span><span class="number">.229</span><span class="number">.196</span>]</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sms_send <span class="keyword">WHERE</span> service_id<span class="operator">=</span>N <span class="keyword">GROUP</span> <span class="keyword">BY</span> content LIMIT N, N;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><p>-v、–verbose : 在详细模式下运行，打印有关该程序的更多信息。</p>
</li>
<li><p>-d、–debug : 在调试模式下运行。</p>
</li>
<li><p>–help : 显示帮助信息并退出程序</p>
</li>
<li><p><strong>-s</strong> [sort_type] : sort_type 是信息排序的依据</p>
<blockquote>
<p>al：average lock time，按平均等待锁的时间排序<br>ar：average rows sent，按平均发给客户端的行总数排序<br>at：average query time，按平均查询时间排序<br>c：count，按出现总次数排序<br>l：lock time，按等待锁的时间排序<br>r：rows sent，按扫描的行总数排序<br>t：query time，按累计总耗费时间排序</p>
</blockquote>
</li>
<li><p><strong>-r</strong> : 倒序信息排序</p>
</li>
<li><p><strong>-t</strong> NUM: 只显示前 n 个查询，降序</p>
</li>
<li><p>-a : 不把数字抽象为’N’，不把字符串抽象为’S’</p>
</li>
<li><p>-n NUM : 「abstract numbers with at least n digits within names」</p>
</li>
<li><p><strong>-g</strong> PATTERN : 根据字符串筛选慢查询日志，可写正则匹配，大小写不敏感。</p>
</li>
<li><p>-h HOSTNAME : 根据服务器名称选择慢查询日志</p>
</li>
<li><p>-i NAME : 根据服务器 MySQL 实例名称选择慢查询日志</p>
</li>
<li><p>-l : 不要将总时间减去锁定时间</p>
</li>
</ul>
<p><code>mysqldumpslow</code> 分析的结果如下:</p>
<ul>
<li><strong>Count</strong> : 出现次数(Count)</li>
<li><strong>Time</strong> : 执行最长时间(Time) 和 累计总耗费时间(Time)</li>
<li><strong>Lock</strong> : 等待锁的时间(Lock)</li>
<li><strong>Rows</strong> : 发送给客户端的行总数(Rows) 和 扫描的行总数(Rows)</li>
<li>root[root]@localhost : 用户</li>
<li>SHOw FULL … : SQL语句本身(抽象了格式, 比如 limit 1, 20 用 limit N,N 表示。’N’表示数字，’S’表示字符串)。</li>
</ul>
<h2 id="show-processlist"><a href="#show-processlist" class="headerlink" title="show processlist"></a>show processlist</h2><blockquote>
<p>processlist命令的输出结果显示了有哪些线程在运行，不仅可以查看当前所有的连接数，还可以查看当前的连接状态帮助识别出有问题的查询语句等。</p>
<p>如果是root帐号，能看到所有用户的当前连接。如果是其他普通帐号，则只能看到自己占用的连接。<code>showprocesslist</code>只能列出当前100条。如果想全部列出，可以使用<code>SHOW FULL PROCESSLIST</code>命令</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> processlist;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------------------+------+---------+-------+-------+------------------+</span></span><br><span class="line"><span class="operator">|</span> Id <span class="operator">|</span> <span class="keyword">User</span> <span class="operator">|</span> Host               <span class="operator">|</span> db   <span class="operator">|</span> Command <span class="operator">|</span> <span class="type">Time</span>  <span class="operator">|</span> State <span class="operator">|</span> Info             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------------------+------+---------+-------+-------+------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> root <span class="operator">|</span> localhost          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> Sleep   <span class="operator">|</span>    <span class="number">12</span> <span class="operator">|</span>       <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> root <span class="operator">|</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.1</span>:<span class="number">7437</span> <span class="operator">|</span> test <span class="operator">|</span> Sleep   <span class="operator">|</span>  <span class="number">8035</span> <span class="operator">|</span>       <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> root <span class="operator">|</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.1</span>:<span class="number">7438</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> Sleep   <span class="operator">|</span> <span class="number">24348</span> <span class="operator">|</span>       <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> root <span class="operator">|</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.1</span>:<span class="number">7443</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> Sleep   <span class="operator">|</span> <span class="number">24317</span> <span class="operator">|</span>       <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span> root <span class="operator">|</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.1</span>:<span class="number">7450</span> <span class="operator">|</span> test <span class="operator">|</span> Sleep   <span class="operator">|</span> <span class="number">24272</span> <span class="operator">|</span>       <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span> root <span class="operator">|</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.1</span>:<span class="number">5152</span> <span class="operator">|</span> test <span class="operator">|</span> Query   <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> init  <span class="operator">|</span> <span class="keyword">show</span> processlist <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------------------+------+---------+-------+-------+------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">full</span> processlist;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------------------+------+---------+-------+-------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> Id <span class="operator">|</span> <span class="keyword">User</span> <span class="operator">|</span> Host               <span class="operator">|</span> db   <span class="operator">|</span> Command <span class="operator">|</span> <span class="type">Time</span>  <span class="operator">|</span> State <span class="operator">|</span> Info                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------------------+------+---------+-------+-------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> root <span class="operator">|</span> localhost          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> Sleep   <span class="operator">|</span>    <span class="number">19</span> <span class="operator">|</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> root <span class="operator">|</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.1</span>:<span class="number">7437</span> <span class="operator">|</span> test <span class="operator">|</span> Sleep   <span class="operator">|</span>  <span class="number">8042</span> <span class="operator">|</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> root <span class="operator">|</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.1</span>:<span class="number">7438</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> Sleep   <span class="operator">|</span> <span class="number">24355</span> <span class="operator">|</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> root <span class="operator">|</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.1</span>:<span class="number">7443</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> Sleep   <span class="operator">|</span> <span class="number">24324</span> <span class="operator">|</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span> root <span class="operator">|</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.1</span>:<span class="number">7450</span> <span class="operator">|</span> test <span class="operator">|</span> Sleep   <span class="operator">|</span> <span class="number">24279</span> <span class="operator">|</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span> root <span class="operator">|</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.1</span>:<span class="number">5152</span> <span class="operator">|</span> test <span class="operator">|</span> Query   <span class="operator">|</span>     <span class="number">0</span> <span class="operator">|</span> init  <span class="operator">|</span> <span class="keyword">show</span> <span class="keyword">full</span> processlist <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------------------+------+---------+-------+-------+-----------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span></span><br></pre></td></tr></table></figure>

<p><strong>各个列的含义：</strong></p>
<ol>
<li>id列，用户登录mysql时，系统分配的”connection_id”，可以使用函数connection_id()查看</li>
<li>user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句</li>
<li>host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户</li>
<li>db列，显示这个进程目前连接的是哪个数据库</li>
<li>command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等</li>
<li>time列，显示这个状态持续的时间，单位是秒</li>
<li>state列，显示使用当前连接的sql语句的状态，很重要的列。<strong>state描述的是语句执行中的某一个状态</strong>。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成</li>
<li>info列，显示这个sql语句，是判断问题语句的一个重要依据</li>
</ol>
<p><strong>输出结果：</strong></p>
<p><img src="/Mysql45/733013-20171027110047445-1395477548.png" alt="img"></p>
<p><img src="/Mysql45/733013-20171027110102180-539051494.png" alt="img"></p>
<h2 id="Row-log"><a href="#Row-log" class="headerlink" title="Row log"></a>Row log</h2><blockquote>
<p>Online DDL重建表中用来记录重建过程的新操作</p>
</blockquote>
<p><img src="/Mysql45/image-20220320120500550.png" alt="image-20220320120500550"></p>
<p><img src="/Mysql45/image-20220320120509022.png" alt="image-20220320120509022"></p>
]]></content>
      <categories>
        <category>Redis</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql主备相关</title>
    <url>/2021/06/16/Mysql%E4%B8%BB%E5%A4%87/</url>
    <content><![CDATA[<h1 id="主备一致"><a href="#主备一致" class="headerlink" title="主备一致"></a>主备一致<a name="主备一致"></a></h1><p>一般来说，备库**<code>只有read only</code><strong>没有写权限比较好，将一些</strong>写<strong>入的放到主库中，将一些</strong>分析的和读**的放到备库中去执行，可以提高数据库的并发度，同时也可以避免切换逻辑中出现双写，造成主备不一致，read only也可以用来区分主备数据库</p>
<p>但是备库需要更新，用<strong>super权限的用户</strong>去完成同步更新</p>
<h2 id="主备复制流程"><a href="#主备复制流程" class="headerlink" title="主备复制流程"></a><strong>主备复制流程</strong></h2><p><img src="https://static001.geekbang.org/resource/image/a6/a3/a66c154c1bc51e071dd2cc8c1d6ca6a3.png" alt="img"></p>
<p><strong>备库 B 跟主库 A 之间维持了一个长连接</strong>。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。一个事务日志同步的完整过程是这样的：</p>
<ol>
<li><p>在备库 B 上通过 change master 命令，设置主库 A 的 <code>IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量</code>。</p>
</li>
<li><p>在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 <strong>io_thread</strong> 和 <strong>sql_thread</strong>。其中 <strong>io_thread</strong> 负责与主库建立<strong>连接</strong>。</p>
</li>
<li><p>主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从<strong>本地读取 binlog</strong>，发给 B。</p>
</li>
<li><p>备库 B 拿到 <strong>binlog</strong> 后，写到本地文件，称为中转日志（<strong>relay log</strong>）。</p>
</li>
<li><p>sql_thread 读取中转日志，解析出日志里的命令，并执行。</p>
</li>
</ol>
<blockquote>
<ol>
<li>设置需要同步的数据库的ip，端口，用户，密码，从哪个位置开始同步</li>
<li>备库开启io和sql thread</li>
<li>主库读取binlog发送到备库</li>
<li>备库收到后称之为relay log</li>
<li>sql thread读取relay log执行</li>
</ol>
</blockquote>
<h2 id="避免循环复制"><a href="#避免循环复制" class="headerlink" title="避免循环复制"></a>避免循环复制</h2><p><img src="/Mysql45/image-20220320211013203.png" alt="image-20220320211013203"></p>
<p>如果是双M结构，业务逻辑在节点A上更新了一条语句，然后再把生成的binlog 发给节点B，节点B执行完这条更新语句后也会生成binlog。（我建议你把参数log_slave_updates设置为on，表示备库执行relay log后生成binlog）。那么，如果节点A同时是节点B的备库，相当于又把节点B新生成的binlog拿过来执行了一次，然后节点A和B间，会不断地循环执行这个更新语句，也就是循环复制了。</p>
<p>MySQL在binlog中记录了这个命令第一次执行时所在实例的server id，如果接受到的是自己生成的日志，直接丢弃这个日志</p>
<h2 id="备库并行复制策略"><a href="#备库并行复制策略" class="headerlink" title="备库并行复制策略"></a>备库并行复制策略</h2><p><img src="/Mysql45/image-20220320212959061.png" alt="image-20220320212959061"></p>
<p>为什么需要有并行复制策略？为什么需要并行呢？<strong>主要是为了解决主备延迟，主数据库修改数据后binlog会传输到备数据去执行，当中会产生延迟，而延迟的主要时间就是io thread获取到之后和sql thread执行完的延迟，为了提高sql thread，将原本的单线程复制改成多线程并行复制，达到跟主库逼近的数据写入效果(主库写入是可以多事务并发执行的)</strong></p>
<img src="https://static001.geekbang.org/resource/image/bc/45/bcf75aa3b0f496699fd7885426bc6245.png" alt="img" style="zoom:67%;" />

<blockquote>
<p><strong>coordinator</strong> 就是 <strong>sql_thread</strong>, 负责读取中转日志和分发事务。**<code>真正更新日志的 是 worker 线程</code>**。而 work 线程的个数，就是由参数 <strong>slave_parallel_workers</strong>（8~16最好） 决定的。</p>
</blockquote>
<p><strong>基本原则，也是并行策略的根本：</strong></p>
<blockquote>
<p><strong>coordinator</strong> 在<strong>分发</strong>的时候，需要满足以下这两个基本要求：</p>
<ul>
<li><strong>不能造成更新覆盖</strong>。这就要求<strong>更新同一行的两个事务，必须被分发到同一个 worker 中。</strong></li>
<li><strong>同一个事务不能被拆开</strong>，必须放到同一个 worker 中。</li>
</ul>
</blockquote>
<p><strong>Mysql5.5</strong></p>
<p><strong><mark>按表分发</mark></strong></p>
<blockquote>
<p>如果两个事务更新不同的表，那么他们就可以并行，如果有跨表的话，还是需要放在一起考虑，也就是一个worker中</p>
</blockquote>
<ol>
<li><p>如果跟所有worker都不冲突，coordinator线程就会把这个事务分配给最空闲的woker;</p>
</li>
<li><p>如果跟多于一个worker冲突，coordinator线程就进入等待状态，直到和这个事务存在冲突关<br>系的worker只剩下1个；</p>
</li>
<li><p>如果只跟一个worker冲突，coordinator线程就会把这个事务分配给这个存在冲突关系的<br>worker。</p>
</li>
</ol>
<p><strong><mark>按行分发</mark></strong></p>
<p><strong>Mysql5.6：按库并行</strong></p>
<blockquote>
<p>决定分发策略的hash表里，key就是数据库名，不要求binlog格式为row，statement也可以，因为sql语句很容易获得库名</p>
</blockquote>
<p><strong>MariaDB</strong></p>
<p>redo log 组提交 (<strong>group commit</strong>) 优化， 而 MariaDB 的并行复制策略利用的就是这个特性：</p>
<p>1.能够在一个组里提交的事务，肯定不会修改同一行</p>
<p>2.主库上可以并行执行的事务，在备库上也可以并行执行</p>
<blockquote>
<p>实现方式：</p>
<p>1.将<strong>一组一起提交的事务</strong>赋予同一个<strong>commit_id</strong>，下一组就是++</p>
<p>2.<strong>commit_id</strong>直接写入<strong>binlog</strong>里面</p>
<p>3.传到备库，如果<strong>commit_id</strong>相同，可以分配到不同的<strong>worker</strong>执行</p>
<p>4.等到上一组相同的<strong>commit_id</strong>的组执行完，<strong>coordinator</strong>才能去取下一组到<strong>worker</strong>中去执行</p>
</blockquote>
<p><strong>Mysql5.7</strong></p>
<p>只要能够到达redo log prepare阶段，就表示事务已经通过锁冲突的检验了。经过重重考验的不存在冲突的事务了，可以直接提交了</p>
<p>1.同时处于prepare状态的事务，在备库执行的时候是可以并行的</p>
<p>2.处于prepare和处于commit状态的事务之间，也是可以并行的</p>
<blockquote>
<p>**[prepare,commit]**是可以并行的</p>
</blockquote>
<p><img src="/Mysql45/image-20220320214453578.png" alt="image-20220320214453578"></p>
<h1 id="主备切换"><a href="#主备切换" class="headerlink" title="主备切换"></a>主备切换</h1><h2 id="一主多从切换策略"><a href="#一主多从切换策略" class="headerlink" title="一主多从切换策略"></a><strong>一主多从切换策略</strong></h2><p><img src="/Mysql45/image-20220320225057392.png" alt="image-20220320225057392"></p>
<blockquote>
<p>以A出问题了，主库从A库变成了A‘库为例    </p>
</blockquote>
<p>当一主多从的时候有两种方式</p>
<p><strong>一种是基于位点的主备切换</strong></p>
<hr>
<p>​    <strong><code>从库</code>执行change master命令将其<code>主库切换成A&#39;库</code><strong>，这个</strong><code>命令</code><strong>要经过</strong>验证</strong>阶段(将**<code>ip，端口，user，password，位置(文件名，日志偏移量)</code>**)传输给A’库。</p>
<p>​    但是这个<strong>日志偏移量</strong>是很难确定的，因为本来记录的是A库的位点，此时换成A’库了就不能再用之前的位点了，<strong>因为主备同步的时候主备复制是并行的，相同的日志可能位点是不一样的</strong>，这个时候从库就先要找到<strong>切换后主库</strong>的**<code>新同步位点</code><strong>，考虑到不能丢失数据，所以往往都是找</strong><code>稍微靠前的一个节点</code>**然后再通过判断跳过那些B已经执行过的事务。</p>
<p><strong>具体步骤</strong>如下：</p>
<blockquote>
<p>主要就是要找到原主库的故障时刻传输的文件在新主库中的位点,作为其他备库的验证阶段的请求位置</p>
</blockquote>
<ol>
<li>新主库把现有的<strong>relay log</strong>全部执行完之后（同步完）</li>
<li>A’上执行<code>show master statue</code>命令，得到A’上最新的<strong>File</strong>和<strong>Position</strong>(位点) &lt;- 这个就是验证的时候要传输的位置的两个参数</li>
<li>取原主库故障时刻T</li>
<li>用mysqlbinlog工具解析A’的File，得到**<code>T时刻的位点</code>**</li>
</ol>
<p><strong><code>但是切换的时候可能会产生错误</code></strong></p>
<blockquote>
<p>假设在 T 这个时刻，主库 A 已经执行完成了一个 insert 语句插入了一行数据 R，并且已经将 binlog 传给了 A’和 B，然后在传完的瞬间主库 A 的主机就掉电了。那么，这时候系统的状态是这样的：</p>
<p>在从库 <strong>B</strong> 上，由于同步了 <strong>binlog</strong>， R 这一行<strong>已经存在</strong>；</p>
<p>在新主库 <strong>A’</strong>上， <strong>R</strong> 这一行也已经存在，日志是写在 123 这个位置之后的；</p>
<p>我们在从库 B 上执行 change master 命令，指向 A’的 File 文件的 123 位置，就会把插入 R 这一行数据的 binlog 又同步到从库 B 去执行。</p>
</blockquote>
<p>**<code>解决方法</code>**是：</p>
<ol>
<li>主动跳过一个事务<code>start slave</code></li>
<li>设置跳过指定错误<code>slave_skip_errors</code>为“1032，1062”</li>
</ol>
<p>​    <strong>GTID</strong></p>
<hr>
<p>​    Mysql5.6只有引入的一种新方式，为了解决之前那种slave_skip_errors 1032,1062这种困难的方式</p>
<p><strong>GTID：全局事务ID，一个事务提交的时候生成，是这个事务的唯一标识，一个GTID就可以指明一个事务</strong></p>
<p><strong>GTID</strong>:{</p>
<p>​    <strong><mark>server_uuid</mark><strong>：</strong>标识一个数据库</strong>，一个实例第一次启动的时候自动生成，是一个<strong>全局唯一的值</strong></p>
<p>​    <strong><mark>gno</mark><strong>：</strong>标识一个事务</strong>，是一个整数，初始值是1，每次提交事务的时候分配个这个事务，并+1</p>
<p>}</p>
<p><strong>GTID</strong>&#x3D;<code>server_uuid</code>:<code>gno</code></p>
<p>transaction_id和gno区别：t_id是事务执行就会产生的一个id，会自增，所以就算产生了回滚，但是还是自增了，gno的话是事务提交的时候才产生的，也会自增，gno是代表执行成功的事务</p>
<p><strong>每个 MySQL 实例都维护了一个 GTID 集合，用来对应“这个实例执行过的所有事务”。Set集</strong></p>
<blockquote>
<p>如果出现主键冲突则提交一个GTID相同的空事务，这样执行的时候就会跳过这个主键冲突的的事务</p>
</blockquote>
<p><strong>基于GTID的主备切换</strong></p>
<p><img src="/Mysql45/image-20220320230630269.png" alt="image-20220320230630269"></p>
<p><img src="/Mysql45/image-20220320230754256.png" alt="image-20220320230754256"></p>
<h2 id="一主从主备切换策略"><a href="#一主从主备切换策略" class="headerlink" title="一主从主备切换策略"></a>一主从主备切换策略</h2><blockquote>
<p>由于<strong>主备延迟</strong>的存在，所以在<strong>主备切换</strong>的时候，就相应的有不同的策略。</p>
</blockquote>
<p><img src="/Mysql45/image-20220308223105778.png" alt="image-20220308223105778"></p>
<blockquote>
<p><strong>等到没延迟再传，让主库只读不能写，开始切换，切换完之后换主库</strong></p>
</blockquote>
<p><img src="/Mysql45/tmp4A9D.png" alt="tmp4A9D"></p>
<p><strong>可用性优先策略</strong></p>
<blockquote>
<p><strong>不等主备数据同步，直接把连接切到备库 B，并且让备库 B 可以读写，那么系统几乎就没有不可用时间了，传期间主库新的写到binlog中后续传给对方</strong></p>
</blockquote>
<p>tip: binlog设置成row格式更容易发生问题，比如自增主键，statement mixed不会记录，可能并行写的时候造成切换前后数据不一致</p>
<p><img src="/Mysql45/image-20220320212452496.png" alt="image-20220320212452496"></p>
<h1 id="主备导致的读写分离坑"><a href="#主备导致的读写分离坑" class="headerlink" title="主备导致的读写分离坑"></a>主备导致的读写分离坑</h1><p>一旦有了<strong>主备</strong>，就会产生<code>主备延迟</code>，一般<strong>主用来写，从用来读</strong>。</p>
<h2 id="读写分离的基本结构"><a href="#读写分离的基本结构" class="headerlink" title="读写分离的基本结构"></a><strong>读写分离的基本结构</strong></h2><p><strong><mark>双M + MS</mark></strong></p>
<p><strong><code>A和A&#39;互为主备，双M结构，这样A一旦宕机，A&#39;会成为主库</code></strong></p>
<p><img src="/Mysql45/image-20220320224239944.png" alt="image-20220320224239944"></p>
<p><strong><code> 客户端直连 &amp; 采用Proxy</code></strong></p>
<ol>
<li>第一种<strong>客户端直连的方案</strong>，可以采用zookeeper，将服务器节点动态保存在zookeeper种，完成动态上下线或者动态选择访问哪个数据库，缺点是如果需要主备切换，数据迁移的时候，都需要到zookeeper中调整连接信息，没有zookeeper就要到cilent中更改连接信息</li>
<li>第二种方案用的是<strong>proxy</strong>，对后端技术有比较大的要求，要能有高可用架构，现在主流趋势都是用proxy</li>
</ol>
<p><img src="/Mysql45/image-20220320224338378.png" alt="image-20220320224338378"></p>
<h2 id="过期读"><a href="#过期读" class="headerlink" title="过期读"></a>过期读</h2><p>无论是那种方案，都会产生<code>过期读</code></p>
<blockquote>
<p>过期读：主库更新了，从库还没有更新，cilent从从库上读取消息，这就是读取到了过期的消息，成为过期读</p>
</blockquote>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong><mark>解决方案</mark></strong></h3><ol>
<li>强制走主库</li>
<li>sleep方案</li>
<li>判断主备无延迟方案</li>
<li>配合semi—sync方案</li>
<li>等<strong>主库位点</strong>方案</li>
<li>等<strong>GTID</strong>方案</li>
</ol>
<h3 id="强制走主库"><a href="#强制走主库" class="headerlink" title="强制走主库"></a><strong>强制走主库</strong></h3><blockquote>
<p><strong>如果十分有必要读取到最新的数据的就需要强制走主库</strong>，比如付款之后余额，看结算页面</p>
<p>如果是没有必要拿到最新消息的可以走从库，比如访问商品页面，可以没有那么必要及时，可以走从库</p>
</blockquote>
<h3 id="sleep方案"><a href="#sleep方案" class="headerlink" title="sleep方案"></a><strong>sleep方案</strong></h3><blockquote>
<p>大多数情况下<strong>主备延迟时间在1秒以内</strong>，所以做一个<strong>sleep</strong>可以很大概率拿到最新的数据，等了这一秒可能就更新完成了</p>
<p>场景：商家发布一个商品，axios异步发送请求，前端页面直接显示添加成功，等卖家再刷新页面查的时候都已经主备都执行完了</p>
</blockquote>
<h3 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a><strong>判断主备无延迟方案</strong></h3><p><code>seconds_behind_master</code>表示主备延迟时间</p>
<ol>
<li>每次判断主备延迟时间是否为0，如为0才能进行查询请求，如果还不等于0就等</li>
<li>对比位点判断是否主备无延迟，如果位点都一样当然无延迟了</li>
<li>对比GTID判断主备是否无延迟，也就是判断Gtid_set是否一致<code>但凡用位点的都可以用GTID</code></li>
</ol>
<h3 id="配合semi—sync方案"><a href="#配合semi—sync方案" class="headerlink" title="配合semi—sync方案"></a><strong>配合semi—sync方案</strong></h3><p>在这之前看一下kafka的生产者ack机制</p>
<p><img src="/Mysql45/tmp3710.png" alt="tmp3710"></p>
<p><code>semi-sync</code>跟这个<strong>很像</strong>：</p>
<ol>
<li>事务提交-&gt;主库把binlog发送给从库</li>
<li>从库收到binlog，发送给主库ack，表示收到了</li>
<li>主库收到这个ack以后返回给客户端<code>事务完成</code></li>
</ol>
<blockquote>
<p>在<code>一主多从</code>当中，一旦有一个从库发送了ack，那么就会给客户端返回<code>事务完成</code>的确认</p>
<ol>
<li>无法保证哪一个从库更新完成了</li>
<li>查询到别的从库上，就还是会产生过期读的问题</li>
</ol>
</blockquote>
<p>场景：</p>
<ol>
<li>高峰期，可能位点总是对不上，产生读延迟很久</li>
<li>很多时候，我们并不需要保证<code>主备完全同步</code>，因为很多时候事务成组提交，而查询是在组其中之一完成之后查询的，那么就没必要等到后面的事务也执行完，后面的事务执行的结果属于预期结果了</li>
</ol>
<h3 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a><strong>等主库位点方案</strong></h3><p><code>SELECT master_pos_wait(file,pos[,timeout]);</code></p>
<ol>
<li>在从库执行</li>
<li>file和pos指的是主库上的文件名和位置</li>
<li>timeout可选，设置为正整数N表示这个函数最多等待N秒</li>
</ol>
<img src="Mysql45/6578a7ada10b4031d9660aec3989b14.png" alt="6578a7ada10b4031d9660aec3989b14" style="zoom:67%;" />

<h3 id="等GTID方案"><a href="#等GTID方案" class="headerlink" title="等GTID方案"></a><strong>等GTID方案</strong></h3><img src="Mysql45/7ecbd34764751644e560b16946fcf7e.png" alt="7ecbd34764751644e560b16946fcf7e" style="zoom: 67%;" />
]]></content>
      <categories>
        <category>Redis</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>first</title>
    <url>/2021/06/16/Mysql%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="Mysql的索引"><a href="#Mysql的索引" class="headerlink" title="Mysql的索引"></a>Mysql的索引</h1><blockquote>
<p>MYSQL做<strong>词法分析语法</strong>分析的时候是通过建立<strong>最左子树</strong>来建立<strong>语法树</strong>的，解析的过程也是<strong>从左到右所以遵循最左前缀的原则</strong>。</p>
<p><strong>对索引字段做函数操作</strong>，可能会<strong>破坏索引值的有序性</strong>，因此优化器就决定放弃走树搜索功能。</p>
<ul>
<li>索引字段是varchar，但是where查找字段是数字，会用函数把varchar转换成数字</li>
</ul>
</blockquote>
<h2 id="如何给字段加索引"><a href="#如何给字段加索引" class="headerlink" title="如何给字段加索引"></a>如何给字段加索引</h2><ol>
<li><p>使用前缀索引，定义好<strong>长度</strong>，就可以做到既节省空间，又不用额外增加太多的查询成本。</p>
<p><strong>前缀索引对覆盖索引的影响</strong>:如果限定了字段，本来索引值是字段全部，现在变成前缀，就需要回表对比一次是否等于语句中的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;zhangssxyz@xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这个语句只要求返回 id 和 email 字段。</p>
<p>所以，如果使用 index1（即 email 整个字符串的索引结构）的话，<strong>可以利用覆盖索引，从 index1 查到结果后直接就返回了，不需要回到 ID 索引再去查一次。</strong></p>
<p>而如果使用 index2（即 email(6) 索引结构）的话，<strong>就不得不回到 ID 索引再去判断 email 字段的值。</strong>即使你将 index2 的定义修改为 email(18) 的前缀索引，这时候虽然 index2 已经包含了所有的信息，但 InnoDB 还是要回到 id 索引再查一下，<strong>因为系统并不确定前缀索引的定义是否截断了完整信息。</strong></p>
</li>
<li><p>倒序存储</p>
<p>比如，我们国家的身份证号，一共 18 位，其中前 6 位是地址码，所以同一个县的人的身份证号前 6 位一般会是相同的。</p>
</li>
<li><p>hash字段</p>
<p>在表上再<strong>创建一个整数字段</strong>，来保存<strong>身份证的校验码</strong>，同时<strong>在这个字段上创建索引</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> id_card_crc <span class="type">int</span> unsigned, <span class="keyword">add</span> index(id_card_crc);</span><br></pre></td></tr></table></figure>

<p>然后每次插入新记录的时候，都同时用 crc32() 这个函数<strong>得到校验码填到这个新字段</strong>。由于校验码可能存在冲突，也就是说两个不同的身份证号通过 crc32() 函数得到的结果可能是相同的(hash碰撞)，所以你的查询语句 <strong>where 部分要判断 id_card 的值是否精确相同。</strong></p>
</li>
</ol>
<h2 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Jefabc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/Mysql45/e2bc5f120858391d4accff05573e1289.png" alt="img"></p>
<ol>
<li>id:选择标识符</li>
<li>select_type:表示查询的类型。</li>
<li>table:输出结果集的表</li>
<li>partitions:匹配的分区</li>
<li>type:表示表的连接类型</li>
<li>possible_keys:表示查询时，可能使用的索引</li>
<li><strong>key</strong>:表示实际使用的索引</li>
<li>key_len:索引字段的长度</li>
<li>ref:列与索引的比较</li>
<li><strong>rows</strong>:扫描出的行数(估算的行数)</li>
<li>filtered:按表条件过滤的行百分比</li>
<li><strong>Extra</strong>:执行情况的描述和说明</li>
</ol>
<h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a><strong>最左前缀原则</strong></h2><blockquote>
<p><strong>B+ 树</strong>这种索引结构，可以利用索引的“最左前缀”，来定位记录。</p>
</blockquote>
<p>最左前缀可以是联合索引的最左 N 个<strong>字段</strong>，也可以是字符串索引的最左 M 个<strong>字符</strong>。</p>
<p>由此可以得知<code>索引优化</code>：如果<strong>调换联合索引顺序</strong>，可以少维护一个索引，那么可以选择调换顺序</p>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a><strong>索引下推</strong></h2><p>在Mysql 5.6版本之后，引入了索引下推优化，可以在索引遍历过程中，<strong>对索引中包含的字段先做判断</strong>，直接过滤掉不满足条件的记录，减少回表次数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> ismale<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>（name, age）-&gt;满足最左前缀<code>张%</code>，开始查询-&gt;对查询到的行判断age,因为索引中就有记录age，满足<code>age==10</code>的才回表查询入结果集</p>
<h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><p>如果对group by语句的结果没有排序要求，要在语句后面加 order by null,group by 会对分组字段做一次默认排序；</p>
<h2 id="Order-by"><a href="#Order-by" class="headerlink" title="Order by"></a>Order by</h2><h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>正常情况下，根据where找到不满足条件的为止，满足的所有字段加入**<mark>soft buffer</mark>**<code>中，然后在</code>soft buffer<code>中做排序这个排序过程称之为</code>全字段排序&#96;</p>
<p>排序过程可能在<code>内存</code>中完成，也可能在<code>外部完成(归并排序)</code>,主要取决于内存够不够，不够的话就只能用外面的了，而外部排序使用的是<code>归并排序</code></p>
<p>是将数据分成<strong>多份临时文件</strong>，然后将这些文件<strong>单独排序</strong>，最后<strong>合并成为一个有序的大文件</strong></p>
<h3 id="Rowid排序"><a href="#Rowid排序" class="headerlink" title="Rowid排序"></a>Rowid排序</h3><blockquote>
<p>无法全字段排序时</p>
</blockquote>
<p>如果允许排序的行数据限制比较小的话，那么就有可能无法做<code>全字段排序</code>，这个时候会将<code>主键</code>和<code>需要排序的那个字段</code>加入到<code>soft buffer</code>中，然后根据where条件将满足行的这两个字段加入到<code>soft buffer</code>中去，然后再<code>回表</code>根据<code>soft buffer</code>中的id取出需要查询的所有字段加入到结果集中返回给客户端</p>
<p><img src="/Mysql45/tmp50E3.png" alt="tmp50E3"></p>
<p>如果索引为<code>(city,name)</code>的话，就不需要进行排序了，直接拿着id回表，可以作为结果集进行返回，因为<code>city</code>相同的时候<code>name</code>一定是有序的</p>
<p>但是！如果查询是<code>city&gt;杭州</code>，那么就无法利用到索引的<code>有序性</code>了，这是因为(city,name)是<strong>先按city排序，然后再按name排序，只有city相同的，其name才是有序的，而不是整个name都是有序的，总体来看name是无序的，只有city是有序的</strong></p>
<h2 id="选错索引"><a href="#选错索引" class="headerlink" title="选错索引"></a><strong>选错索引<a name="选错索引"></a></strong></h2><p><a href="C:\Users\Administrator\Desktop\MySQL\MYSQL实战45讲PDF\10.MySQL为什么有时候会选错索引？.pdf">选错索引.pdf</a></p>
<p>选择索引是<code>优化器</code>的工作。可以<code>force index(索引)</code>强制使用某索引</p>
<p><strong>如何选择索引</strong>？<strong>扫描行数</strong>并不是唯一的判断标准，优化器还会结合<strong>是否使用临时表</strong>、<strong>是否排序</strong>等因素进行<strong>综合判断</strong>。</p>
<p>Mysql根据<strong>统计信息</strong><code>预估</code>语句执行满足条件记录数</p>
<p><strong>统计信息：</strong></p>
<p>索引的“区分度”，一个索引上<strong>不同的值越多</strong>，这个索引的区分度就越好。而一个索引上<strong>不同的值的个数</strong>，称之为“<strong>基数</strong>”（cardinality）。这个<strong>基数↑ 索引的区分度↑</strong>。</p>
<p><strong>获得基数：采用统计</strong></p>
<p>InnoDB 默认会<strong>选择 N 个数据页</strong>，<strong>统计这些页面上的不同值，得到一个平均值</strong>，然后<strong>乘以这个索引的页面数</strong>，就得到了这个索引的基数。</p>
<p>如果是<strong>统计信息不对导致的选错索引</strong>可以：**<mark>analyze table t</mark><strong>命令，可以用来</strong>重新统计<strong>索引信息。统计时候会加</strong><code>MDL读锁</code>**</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Redis AOF日志</title>
    <url>/2021/07/16/RedisAOF/</url>
    <content><![CDATA[<h1 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><strong>AOF日志，Redis<code>先执行命令</code>，把数据写入内存，然后记录日志</strong></p>
<p><strong>AOF 里记录的是 <code>Redis 收到的每一条命令</code>，这些命令是<code>以文本形式保存</code>的。更像binlog</strong></p>
<p>Redis 在向 AOF 里面记录日志的时候，<code>并不会先去对这些命令进行语法检查</code>。所以，如果<code>先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。</code>而先执行命令也可以防止错误的命令被记入AOF日志</p>
<h2 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h2><ol>
<li>如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。</li>
<li><strong>AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。</strong>这是因为，<strong>AOF 日志也是在主线程中执行的</strong>，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</li>
</ol>
<h2 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h2><blockquote>
<p>控制AOF的写回时机</p>
</blockquote>
<p><strong><mark>Always</mark>同步写回</strong>：每个写命令执行完，<strong>立马同步</strong>地将日志写回磁盘；</p>
<p><strong><mark>Everysec</mark>每秒写回</strong>：每个写命令执行完，只是先把日志写到 <strong>AOF 文件的内存缓冲区</strong>，<strong>每隔一秒</strong>把缓冲区中的内容写入磁盘；</p>
<p><strong><mark>No</mark>操作系统控制的写回</strong>：每个写命令执行完，只是先把日志写到 <strong>AOF 文件的内存缓冲区</strong>，由<strong>操作系统决定</strong>何时将缓冲区内容写回磁盘。</p>
<p><img src="/redis_COAIX/tmp7EC2.png" alt="tmp7EC2"></p>
<h2 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h2><p>重写时，Redis 根据数据库的现状<strong>创建一个新的 AOF 文件</strong>，也就是说，<strong>读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入</strong>。</p>
<p>将Redis的每一条数据直接用一个<code>set key value</code>记录。当一个键值对被多条写命令反复修改时，AOF 文件会记录相应的多条命令。但是，在重写的时候，是根据这个键值对当前的最新状态，为它生成对应的写入命令。</p>
<h3 id="重写会阻塞吗"><a href="#重写会阻塞吗" class="headerlink" title="重写会阻塞吗?"></a>重写会阻塞吗?</h3><p><code>不会</code></p>
<blockquote>
<p><strong>每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写</strong>；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，<strong>因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。</strong></p>
</blockquote>
<p>**<mark>一个拷贝</mark>**：</p>
<p>每次执行重写时，<strong>主线程 fork 出后台的 bgrewriteaof 子进程</strong>。此时，<strong>fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程</strong>，这里面就包含了数据库的最新数据。然后，<strong>bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</strong></p>
<p><strong><mark>两处日志</mark></strong>:</p>
<ul>
<li><p>1如果有写操作，<strong>第一处日志就是指正在使用的 AOF 日志</strong>，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这<br>个 AOF 日志的操作仍然是齐全的，可以用于恢复。</p>
</li>
<li><p><strong>2就是指新的 AOF 重写日志</strong>。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，就可以用新的 AOF 文件替代旧文件了。</p>
</li>
</ul>
<p><img src="/redis_COAIX/tmp10D8.png" alt="tmp10D8"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL的锁</title>
    <url>/2021/06/16/Mysql%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="有哪些锁？"><a href="#有哪些锁？" class="headerlink" title="有哪些锁？"></a>有哪些锁？</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>从锁粒度分类(一般)</strong></td>
<td>行锁-&gt;也成为记录锁</td>
</tr>
<tr>
<td></td>
<td>表锁</td>
</tr>
<tr>
<td></td>
<td>库锁(全局锁)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>从对数据操作的类型</strong></td>
<td>读锁(共享锁)</td>
</tr>
<tr>
<td></td>
<td>写锁(排他锁)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>补充</strong></td>
<td>悲观锁(上面都是)</td>
</tr>
<tr>
<td></td>
<td>乐观锁-&gt;数据版本（Version）-&gt;CAS</td>
</tr>
</tbody></table>
<p>39</p>
<p><strong>InnoDB</strong>会自动给涉及<strong>UPDATE、DELETE、INSERT</strong>语句数据集加排他锁,<strong>SELECT</strong>语句不会自动加锁</p>
<p><strong>InnoDB</strong>在默认的情况下，select是不加任何行锁的,事务可以通过以下语句显示给记录集加共享锁或排他锁。</p>
<p>默认不会加读锁！但 MySQL InnoDB 的<code>可重复读</code>并不保证避免<code>幻读</code>(幻读是专指新增加的行)，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是 <strong>next-key locks</strong>。</p>
<ul>
<li><code>共享锁(S)</code>：SELECT * FROM table_name WHERE … <strong>LOCK IN SHARE MODE</strong></li>
<li><code>排他锁(X)</code>：SELECT * FROM table_name WHERE … <strong>FOR UPDATE</strong></li>
</ul>
<p><strong><mark>LOCK IN SHARE MODE</mark></strong></p>
<p>只锁<strong>覆盖索引</strong></p>
<p><strong><mark>FOR UPDATE</mark></strong></p>
<p>会认为你要修改数据，给<strong>主键</strong>也一块锁上</p>
<blockquote>
<p><strong>MyISAM</strong>在执行查询语句<strong>SELECT</strong>前，<strong>会自动给涉及的所有表加读锁</strong>，在执行<strong>增、删、改</strong>操作前，<strong>会自动给涉及的表加写锁，这个过程并不需要用户干预</strong></p>
</blockquote>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a><strong>全局锁</strong></h2><p><strong><code>Flush tables with read lock (FTWRL)</code></strong>:<strong>全局读锁</strong>,让整个库处于<strong>只读状态</strong>，如果客户端异常，会自动释放这个锁，如果是用<code>set global readonly=true</code>的方式不会自动释放这个锁</p>
<p>全局锁的典型**<code>使用场景</code><strong>是，做</strong>全库逻辑备份**</p>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><blockquote>
<p><strong><code>表锁</code></strong> &amp; <strong><code>元数据锁 MDL</code></strong></p>
</blockquote>
<p>表锁的语法是 <strong><code>lock tables … read/write</code></strong></p>
<p>还有另一种自动加的<code>MDL（metadata lock)</code>：在访问一个表的时候会被<strong>自动加上</strong></p>
<p><strong>MDL:</strong></p>
<blockquote>
<p>当对一个表做<strong>增删改查</strong>操作的时候，加<strong>MDL读锁</strong>；当要对表做<strong>结构变更</strong>操作的时候，加<strong>MDL写锁。</strong></p>
</blockquote>
<p><strong>增删改查</strong>  ➕ <strong><code>MDL读锁</code></strong></p>
<p><strong>表结构变更</strong> ➕ <strong><code>MDL写锁</code></strong></p>
<ul>
<li><strong>读锁</strong>之间不互斥，因此你可以有多个线程同时对一张表<strong>增删改查</strong>。</li>
<li><strong>读写锁之间、写锁之间是互斥的</strong>，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>
</ul>
<h2 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h2><blockquote>
<p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
</blockquote>
<p>优化场景:将<strong>并发度高</strong>的语句放在后面执行</p>
<h2 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a><strong>死锁和死锁检测</strong></h2><ul>
<li>一种策略是，<strong>直接进入等待</strong>，直到<strong>超时</strong>。这个超时时间可以通过参数 <strong><code>innodb_lock_wait_timeout(默认50s)</code></strong> 来设置。</li>
<li>另一种策略是，发起<strong>死锁检测</strong>，发现死锁后，<strong>主动回滚死锁链条中的某一个事务</strong>，让其他事务得以继续执行。将参数 <strong><code>innodb_deadlock_detect</code></strong> 设置为 on，表示开启这个逻辑。</li>
</ul>
<p>一般选择<strong>死锁检测</strong>，但是每条语句都要进行死锁检测，无疑耗费大量CPU资源</p>
<p><strong><mark>解决策略</mark></strong></p>
<p><strong>你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。</strong></p>
<p>还是以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1&#x2F;10，可以减少锁等待个数，也就减少了死锁检测的CPU 消耗。</p>
<h2 id="next-key-lock"><a href="#next-key-lock" class="headerlink" title="next-key lock"></a>next-key lock</h2><h2 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h2><p><strong>锁是加在<code>索引</code>上的</strong>-&gt;数据是存在主键索引上的</p>
<p>next-key lock是**<mark>可重复读级别</mark><strong>才有的，也就是</strong><code>间隙锁</code><strong>和</strong><code>行锁</code>**，可重复读级别有</p>
<p><strong><mark>读提交级别</mark><strong>的话没有</strong><code>间隙锁</code><strong>，有</strong><code>行锁</code></strong></p>
<blockquote>
<p>间隙锁例如(5,10)内别的session不能insert了但是还是可以update的，因为幻读指的是新增行数据</p>
</blockquote>
<p><img src="/Mysql45/tmp7BE0.png" alt="tmp7BE0"></p>
<blockquote>
<p>只有**<code>等值查询</code>**可以退化锁</p>
<ul>
<li><strong><code>等值查询</code></strong> + <strong><code>唯一索引</code></strong>-&gt; 退化成  <strong><code>行锁</code></strong></li>
<li><strong><code>等值查询</code></strong> + <strong><code>索引</code></strong>   -&gt; 退化成 <strong><code>间隙锁</code></strong></li>
</ul>
</blockquote>
<p><img src="/Mysql45/image-20220320175935663.png" alt="image-20220320175935663"></p>
<p>直接举例:</p>
<p>库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">id(not null,primary key)</th>
<th>c(key)</th>
<th>d</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td align="center">5</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td align="center">10</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td align="center">15</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td align="center">20</td>
<td>20</td>
<td>20</td>
</tr>
<tr>
<td align="center">25</td>
<td>25</td>
<td>25</td>
</tr>
</tbody></table>
<h2 id="1-主键上的等值查询"><a href="#1-主键上的等值查询" class="headerlink" title="1.主键上的等值查询"></a>1.主键上的等值查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">SET</span> D <span class="operator">=</span> D <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> ID <span class="operator">=</span> <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>主键索引，直接找7没找到，找到中间的间隙(5,10)</p>
<ol>
<li>加锁(5,10]</li>
<li>(5,10]退化-&gt;(5，10)<code>如果找到了的话会退化成行锁</code></li>
</ol>
<blockquote>
<p>(5,10)不能insert了，但是别的session还是可以update的</p>
</blockquote>
<h2 id="2-非唯一索引（包括主键索引）等值查询"><a href="#2-非唯一索引（包括主键索引）等值查询" class="headerlink" title="2.非唯一索引（包括主键索引）等值查询"></a>2.非唯一索引（包括主键索引）等值查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">5</span> lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里只用到了key c 覆盖索引<code>c:id</code>,<strong>只在覆盖索引上上了锁，没有在主键上上锁</strong>，但是如果是<strong>for update</strong>的话，系统会认为你要修改数据，<strong>会在主键上也上锁</strong></p>
</blockquote>
<ol>
<li>加锁(0,5] (5,10]</li>
<li>(5,10]-&gt;(5,10)</li>
</ol>
<h2 id="3-主键索引范围锁"><a href="#3-主键索引范围锁" class="headerlink" title="3.主键索引范围锁"></a>3.主键索引范围锁</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> id <span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> id <span class="operator">&lt;</span> <span class="number">11</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先需要等值查询查到id&#x3D;10，加锁(5,10]</li>
<li>找得到10退化成行锁10</li>
<li>向右范围查询，加锁(10,15]</li>
<li><strong><del>最右不满足条件，退化(10,15)</del>不会执行这一步，因为这个时候等值查询已经结束了，向右是范围查询</strong></li>
</ol>
<h2 id="4-非唯一索引范围查询"><a href="#4-非唯一索引范围查询" class="headerlink" title="4.非唯一索引范围查询"></a>4.非唯一索引范围查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span>  c <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">and</span> c <span class="operator">&lt;</span> <span class="number">11</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>查询10，加锁(5,10]</li>
<li>找到了，不会退化成行锁，因为不是唯一索引</li>
<li>范围查询,(10,15]</li>
</ol>
<h2 id="5-唯一索引bug"><a href="#5-唯一索引bug" class="headerlink" title="5.唯一索引bug"></a>5.唯一索引<code>bug</code></h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">and</span> id <span class="operator">&lt;=</span> <span class="number">15</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>直接找到(10,15]这个间隙</li>
<li>向右范围查询，找到15了，但是在8.0.26版本前，会有个bug，按理来说唯一索引不需要再往后找了，毕竟就此一个</li>
<li>但是还是继续往后面找，找到(15,20]</li>
</ol>
<h2 id="6-非唯一索引上存在等值"><a href="#6-非唯一索引上存在等值" class="headerlink" title="6.非唯一索引上存在等值"></a>6.非唯一索引上存在等值</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> v <span class="keyword">values</span>(<span class="number">30</span>,<span class="number">10</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">id(not null,primary key)</th>
<th>c(key)</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td align="center">5</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td align="center">10</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td align="center">15</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td align="center">20</td>
<td>20</td>
<td>20</td>
</tr>
<tr>
<td align="center">25</td>
<td>25</td>
<td>25</td>
</tr>
<tr>
<td align="center"><span style="background:#FF9999;">30</span></td>
<td><span style="background:#FF9999;">10</span></td>
<td><span style="background:#FF9999;">30</span></td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>加锁情况：(5,10] (10,15)</p>
<img src="https://static001.geekbang.org/resource/image/bb/24/bb0ad92483d71f0dcaeeef278f89cb24.png" alt="img" style="zoom:50%;" />

<p>虽然索引C相同都为10，但是因为id是不同的，所以还是存在间隙 です</p>
<h2 id="7-limit语句加锁"><a href="#7-limit语句加锁" class="headerlink" title="7.limit语句加锁"></a>7.limit语句加锁</h2><p><code>用上面那个例子</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> c<span class="operator">=</span><span class="number">10</span> limit <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>这个时候只会加锁(5,10]，<strong>不会继续往后面找</strong>，因为已经limit 2了，**<code>找到两个就返回了，后面的不会搜</code>**</p>
<h2 id="8-不等号里面的等值查询"><a href="#8-不等号里面的等值查询" class="headerlink" title="8.不等号里面的等值查询"></a>8.不等号里面的等值查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">9</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">12</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/Mysql45/tmp9271.png" alt="tmp9271"></p>
<p>先要找到12的位置(因为倒序)，但是没有，只找到了（10，15]这个间隙，<strong>等值查询</strong>退化成(10,15)</p>
<p>然后👈范围查询，一路查到第一个不满足的情况5，(0,5],(5,10]</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> c <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="operator">&gt;</span> <span class="number">5</span> lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>

<p>直接找到(5,10]这个间隙，然后向右查询(10,15](15,20](20,25]和(25,<code>supremum</code>]</p>
<blockquote>
<p><strong>supremum</strong> innodb默认会给的一个最大值</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span>  c <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/Mysql45/tmpE33D.png" alt="tmpE33D"></p>
<h2 id="9-等值查询的过程"><a href="#9-等值查询的过程" class="headerlink" title="9.等值查询的过程"></a>9.等值查询的过程</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>) lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>

<p><img src="/Mysql45/tmp4D72.png" alt="tmp4D72"></p>
<p><code>这个加锁的步骤，是一个一个加的，锁是在执行过程中加的</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> c <span class="keyword">in</span>(<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>如果同时有倒序，可能会产生<strong>死锁</strong></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>RedisRDB日志</title>
    <url>/2021/07/16/RedisRDB/</url>
    <content><![CDATA[<h1 id="RDB内存快照"><a href="#RDB内存快照" class="headerlink" title="RDB内存快照"></a>RDB内存快照</h1><blockquote>
<p><strong>Redis 会使用 bgsave 对当前内存中的所有数据做快照，这个操作是子进程在后台完成的，这就允许主线程同时可以修改数据。</strong></p>
</blockquote>
<p><strong>bgsave</strong>：**<code>创建一个子进程</code><strong>，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是Redis RDB 文件生成的</strong>默认配置**。</p>
<p><strong>save</strong>：在**<code>主线程中执行</code>**，会导致阻塞；</p>
<p><strong>内存中的数据在某一个时刻的状态记录</strong></p>
<table>
<thead>
<tr>
<th>快照种类</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>全量快照</td>
<td>把内存中的所有数据都记录到磁盘中</td>
</tr>
<tr>
<td>增量快照</td>
<td>做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。</td>
</tr>
</tbody></table>
<p><strong>如何拿到快照这一刻的数据？</strong></p>
<p><strong><mark>写时复制技术</mark></strong>:</p>
<p><strong>bgsave 子进程</strong>是由主线程 fork 生成的，<strong>可以共享主线程的所有内存数据</strong>。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。</p>
<p>如果主线程对这些数据也都是<strong>读操作</strong>（例如图中的键值对 A），那么，<strong>主线程和bgsave 子进程相互不影响</strong>。但是，如果主线程<strong>要修改一块数据</strong>（例如图中的键值对 C），那么，<strong>这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本</strong><br><strong>数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</strong></p>
<blockquote>
<p>也就是说，bgsave子进程读取主线程的内存数据，如果主线程update了某一块数据，会生成一块这块数据的副本给bgsave进程读取写入RDB文件</p>
</blockquote>
<p><img src="/redis_COAIX/tmp2F8C.png" alt="tmp2F8C"></p>
<h1 id="混合使用AOF和RDB"><a href="#混合使用AOF和RDB" class="headerlink" title="混合使用AOF和RDB"></a>混合使用AOF和RDB</h1><p>频繁全量快照，开销很大，磁盘压力很大</p>
<p>增量快照，还需要记录哪些数据修改了，空间开销大</p>
<p>所以，我们<strong>混合使用AOF和RDB</strong></p>
<blockquote>
<p><strong>混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</strong></p>
<p>一定频率：</p>
<ul>
<li>一定时间内写入了多少条数据执行内存快照</li>
</ul>
</blockquote>
<p><strong>全量快照的时候就可以清空AOF日志了，因为快照的时候数据已经是全的了</strong></p>
<p><img src="/redis_COAIX/tmpC2F6.png" alt="tmpC2F6"></p>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>开启了<code>混合持久化</code>时，<strong>启动redis依然优先加载aof文件</strong></p>
<p>aof文件加载可能有两种情况如下：</p>
<ol>
<li><strong>aof文件开头是rdb的格式</strong>, 先加载 rdb内容再加载剩余的 aof。</li>
<li><strong>aof文件开头不是rdb的格式</strong>，直接以aof格式加载整个文件。</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis跳表及数据结构</title>
    <url>/2021/07/16/Redis%E8%B7%B3%E8%A1%A8%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>跳表结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p>跳表节点结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//Sorted Set中的元素</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">//元素权重值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">//&lt;-指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">//节点的level数组，保存每层上的-&gt;指针和跨度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<h2 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取跳表的表头</span></span><br><span class="line">x = zsl-&gt;header;</span><br><span class="line"><span class="comment">//从最大层数开始逐一遍历</span></span><br><span class="line"><span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">//如果当前元素就是要找的元素的话就直接返回了</span></span><br><span class="line">   ...</span><br><span class="line">    <span class="comment">//如果当前元素所在层的下一个节点不为空</span></span><br><span class="line">       <span class="comment">//并且下一个节点的权值小于找的权值</span></span><br><span class="line">       		<span class="comment">//或者下一个节点的权值等于找的权值 但是 sdscmp(,)-&gt; 字符串比找的要小</span></span><br><span class="line">    <span class="comment">//yes-&gt;就继续找同层的下一个节点</span></span><br><span class="line">    <span class="comment">//no -&gt;找下一层的节点</span></span><br><span class="line">   <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (x-&gt;level[i].forward-&gt;score &lt; score || (x-&gt;level[i].forward-&gt;score == score </span><br><span class="line">    &amp;&amp; sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>))) &#123;</span><br><span class="line">      ...</span><br><span class="line">      x = x-&gt;level[i].forward;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong><mark>同层往后找条件</mark></strong></p>
<ul>
<li>如果当层下一个元素为空</li>
<li>如果当层下一个元素的score &lt; 当前节点score</li>
<li>如果单层下一个元素的score &#x3D; 当前节点score<ul>
<li>但是下一个节点的SDS值 &lt; 当前节点SDS值</li>
</ul>
</li>
</ul>
<p> <strong><mark>不往后找的话就跳到下一层</mark></strong></p>
<h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><p>创建节点的索引层数随机<code>zslRandomLevel</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZSKIPLIST_MAXLEVEL 64  <span class="comment">//最大层数为64</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZSKIPLIST_P 0.25       <span class="comment">//随机数的值为0.25</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">zslRandomLevel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化层为1</span></span><br><span class="line">    <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>zslRandomLevel</code> 函数会把层数初始化为 1，这也是结点的最小层数。</p>
<p>然后，该函数会生成随机数，如果随机数的值小于 ZSKIPLIST_P（指跳表结点增加层数的概率，值为 0.25），那么层数就增加 1 层。因为随机数取值到[0,0.25) 范围内的概率不超过 25%，所以这也就表明了，每增加一层的概率不超过 25%。如果while循环下一轮还是小于0.25，则又++。</p>
<h2 id="Zset中结构：哈希表和跳表组合使用"><a href="#Zset中结构：哈希表和跳表组合使用" class="headerlink" title="Zset中结构：哈希表和跳表组合使用"></a>Zset中结构：哈希表和跳表组合使用</h2><p><strong><mark>Zset结构</mark></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict; <span class="comment">//哈希表</span></span><br><span class="line">    zskiplist *zsl;	<span class="comment">//跳表</span></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p><strong><mark>zslCreate 创建Zset</mark></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">zs-&gt;dict = dictCreate(&amp;zsetDictType,<span class="literal">NULL</span>); <span class="comment">//创建哈希表</span></span><br><span class="line">zs-&gt;zsl = zslCreate();						<span class="comment">//创建跳表</span></span><br></pre></td></tr></table></figure>

<p><strong><mark>zsetAdd 添加节点</mark></strong></p>
<ol>
<li><p><strong>首先，zsetAdd 函数会判定 Sorted Set 采用的是 <code>ziplist</code> 还是 <code>skiplist</code> 的编码方式。</strong>.</p>
</li>
<li><p><strong>然后，如果 zsetAdd 函数通过 <code>哈希表 dictFind</code> 函数发现要插入的元素已经存在，那么 zsetAdd 函数会判断<code>是否要增加元素的权重值</code>。</strong></p>
<ul>
<li><p><strong>如果权重值发生了变化，zsetAdd 函数就会调用 zslUpdateScore 函数，更新跳表中的元素权重值。紧接着，<code>zsetAdd 函数会把哈希表中该元素（对应哈希表中的 key）的 value 指向跳表结点中的权重值，这样一来，哈希表中元素的权重值就可以保持最新值了。</code></strong></p>
<p><strong>hash中直接改value指针</strong> , dictEntry哈希字典Entry 结构⾥键值对中的值是⼀个「联合体 v」定义的，因此，键值对中的<strong>值可以是⼀个指向实际值的指针，或者是⼀个⽆符号的 64 位整数或有符号的 64 位整数或double 类的值。</strong> 这么做的好处是<strong>可以节省内存空间，因为当「值」是整数或浮点数时，就可以将值的数据<code>内嵌</code>在 dictEntry结构⾥，<code>⽆需再⽤⼀个指针指向实际的值</code>，从⽽节省了内存空间。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">	<span class="comment">//键值对中的键</span></span><br><span class="line">	<span class="type">void</span> *key;</span><br><span class="line">	<span class="comment">//键值对中的值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">	<span class="comment">//指向下⼀个哈希表节点，形成链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;     </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>源码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果采用ziplist编码方式时，zsetAdd函数的处理逻辑</span></span><br><span class="line"> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果采用skiplist编码方式时，zsetAdd函数的处理逻辑</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        zset *zs = zobj-&gt;ptr;zskiplistNode *znode;dictEntry *de;</span><br><span class="line">        <span class="comment">//从哈希表中查询新增元素</span></span><br><span class="line">        de = dictFind(zs-&gt;dict,ele);</span><br><span class="line">        <span class="comment">//如果能查询到该元素</span></span><br><span class="line">        <span class="keyword">if</span> (de != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//从哈希表中查询元素的权重</span></span><br><span class="line">            curscore = *(<span class="type">double</span>*)dictGetVal(de);</span><br><span class="line">            <span class="comment">//如果要更新元素权重值</span></span><br><span class="line">            <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">                <span class="comment">//更新权重值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果权重发生变化了</span></span><br><span class="line">            <span class="keyword">if</span> (score != curscore) &#123;</span><br><span class="line">                <span class="comment">//更新跳表结点</span></span><br><span class="line">                znode = zslUpdateScore(zs-&gt;zsl,curscore,ele,score);</span><br><span class="line">                <span class="comment">//让哈希表元素的值指向跳表结点的权重</span></span><br><span class="line">                dictGetVal(de) = &amp;znode-&gt;score; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//如果新元素不存在</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123;</span><br><span class="line">            ele = sdsdup(ele);</span><br><span class="line">            <span class="comment">//新插入跳表结点</span></span><br><span class="line">            znode = zslInsert(zs-&gt;zsl,score,ele);</span><br><span class="line">            <span class="comment">//新插入哈希表元素</span></span><br><span class="line">            serverAssert(dictAdd(zs-&gt;dict,ele,&amp;znode-&gt;score) == DICT_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br></pre></td></tr></table></figure>



<h1 id="数据结构时间复杂度"><a href="#数据结构时间复杂度" class="headerlink" title="数据结构时间复杂度"></a>数据结构时间复杂度</h1><p><img src="/redis_COAIX/image-20220319100559632.png" alt="image-20220319100559632"></p>
<ul>
<li>范围操作比较耗时比如List的LRANGE 和 Zset的ZRANGE</li>
</ul>
<h1 id="使用什么数据结构"><a href="#使用什么数据结构" class="headerlink" title="使用什么数据结构"></a>使用什么数据结构</h1><img src="redis_COAIX/tmp5E0A.png" alt="tmp5E0A" style="zoom:80%;" />

<p><strong><mark>Set</mark></strong>:统计手机 App 每天的新增用户数和第二天的留存用户数，正好对应了聚合统计。</p>
<blockquote>
<p>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，**<code>会导致 Redis 实例阻塞</code><strong>。所以，我给你分享一个小建议：你可以从</strong><code>主从集群中选择一个从库，让它专门负责聚合计算</code>**，或者是把数据读取到客户端，在客户端来完成聚合统计，这样就可以规避阻塞主库实例和其他从库实例的风险了。</p>
</blockquote>
<p><strong><mark>Sort Set &amp; List</mark></strong>:最新的评论，展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，优先使用<strong>Sort Set</strong></p>
<p>**<mark>Bitmap</mark>**：某用户的签到统计</p>
<blockquote>
<p>本身是用 <strong><code>String</code></strong> 类型作为底层数据结构实现的一种统计二值状态的数据类型。**<code>String 类型是会保存为二进制的字节数组</code>**，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态。可以把 <strong><code>Bitmap 看作是一个 bit 数组。</code></strong></p>
</blockquote>
<p>**<mark>HyperLogLog &amp; Set</mark>**：统计一个集合中不重复的元素个数。对应到我们刚才介绍的场景中，就是统计网页的用户访问量。需要去重</p>
<p><strong><mark>GEO</mark></strong>:带有地理位置的</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis的事务？</title>
    <url>/2021/07/16/Redis%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><blockquote>
<p>严格说不算事务，但是具有部分特性</p>
</blockquote>
<p><img src="/redis_COAIX/image-20220319180216835.png" alt="image-20220319180216835"></p>
<p><strong><mark>原子性</mark></strong> </p>
<ul>
<li>命令入队时就报错，会放弃事务执行，保证原子性；</li>
<li>命令入队时没报错，实际执行时报错，不保证原子性；</li>
<li>EXEC 命令执行时实例故障，如果开启了 AOF 日志，可以保证原子性。(需要执行AOF修复)</li>
</ul>
<p><strong><mark>一致性</mark></strong></p>
<ul>
<li>命令入队时就报错<br><strong>事务本身就会被放弃执行，所以可以保证数据库的一致性。</strong></li>
<li>命令入队时没报错，实际执行时报错<br><strong>有错误的命令不会被执行，正确的命令可以正常执行，也不会改变数据库的一致性。</strong></li>
<li>EXEC 命令执行时实例发生故障<ul>
<li>没开AOF，RDB持久化，出故障了数据不会保存，是一致的(跟程序员心中想的一样)</li>
<li>使用了 RDB 快照，因为 <strong>RDB 快照不会在事务执行时执行</strong>，所以，<strong>事务命令操作的结果不会被保存到 RDB 快照中</strong>，使用 <strong>RDB 快照进行恢复时，数据库里的数据也是一致的</strong>。</li>
<li>使用 AOF 日志<ul>
<li>事务操作还没有被记录到 AOF 日志时，实例就发生了故障，那么，使用 AOF 日志恢复的数据库数据是一致的。</li>
<li>如果只有部分操作被记录到了AOF 日志，我们可以使用 <strong><code>redis-check-aof</code></strong> 清除事务中已经完成的操作，数据库恢复后也是一致的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><mark>隔离性</mark></strong></p>
<ul>
<li><strong><code>并发操作在 EXEC 命令前执行</code><strong>，此时，</strong>隔离性的保证要使用 WATCH 机制来实现</strong>，<strong>否则隔离性无法保证</strong></li>
<li><strong><code>并发操作在 EXEC 命令后执行</code><strong>，此时，</strong>隔离性可以保证</strong></li>
</ul>
<p><strong><mark>持久性</mark></strong></p>
<p>不管 Redis 采用什么<strong>持久化模式</strong>，事务的持久性属性是得不到保证的。</p>
<ul>
<li>如果 Redis <strong>没有使用 RDB 或 AOF</strong>，那么事务的持久化属性肯定得不到保证。</li>
<li>如果 Redis <strong>使用了 RDB 模式</strong>，那么，在一个事务执行后，而下一次的 RDB 快照还未执行前，如果发<br>生了实例宕机，这种情况下，事务修改的数据也是不能保证持久化的。</li>
<li>如果 Redis <strong>采用了 AOF 模式</strong>，因为 AOF 模式的三种配置选项 no、everysec 和 always<br>都会存在数据丢失的情况，所以，事务的持久性属性也还是得不到保证。</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis缓存</title>
    <url>/2021/07/16/Redis%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="旁路缓存"><a href="#旁路缓存" class="headerlink" title="旁路缓存"></a>旁路缓存</h1><p>缓存中的数据需要按<strong>一定规则</strong>淘汰出去，写回后端系统，而<strong>新的数据又要从后端系统中读取进来，写入缓存</strong>。</p>
<p><strong>把 Redis 称为旁路缓存</strong>，也就是说，**<code>读取缓存、读取数据库和更新缓存的操作都需要在应用程序中来完成</code>**。</p>
<p><img src="/redis_COAIX/tmp35B9.png" alt="tmp35B9"></p>
<p>**<mark>使用Redis缓存</mark>**：</p>
<ul>
<li>应用读取数据时，需要<strong>先读取 Redis</strong></li>
<li>发生缓存<strong>缺失</strong>时，需要从数据库读取数据</li>
<li>发生缓存<strong>缺失</strong>时，还需要更新缓存</li>
</ul>
<h2 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h2><h3 id="只读缓存"><a href="#只读缓存" class="headerlink" title="只读缓存"></a>只读缓存</h3><p><img src="/redis_COAIX/tmp8E02.png" alt="tmp8E02"></p>
<h3 id="读写缓存"><a href="#读写缓存" class="headerlink" title="读写缓存"></a>读写缓存</h3><p><strong><code>两种策略</code></strong></p>
<ul>
<li><p><strong><mark>同步直写</mark></strong></p>
<p>同步直写是指，**<code>写请求发给缓存的同时，也会发给后端数据库进行处理，等到缓存和数据库都写完数据，才给客户端返回。</code><strong>这样，即使缓存宕机或发生故障，最新的数据仍然保存在数据库中，这就</strong><code>提供了数据可靠性保证。</code>**</p>
</li>
<li><p><strong><mark>异步写回</mark></strong></p>
<p>则是**<code>优先考虑了响应延迟</code><strong>。此时，</strong><code>所有写请求都先在缓存中处理</code><strong>。</strong><code>等到这些增改的数据要被从缓存中淘汰出来时，缓存将它们写回后端数据库</code><strong>。这样一来，</strong>处理这些数据的操作是在缓存中进行的，很快就能完成。**只不过，如果发生了掉电，而它们还没有被写回数据库，就会有丢失的风险了。</p>
<p><img src="/redis_COAIX/image-20220319151354467.png" alt="image-20220319151354467"></p>
</li>
</ul>
<h2 id="如何选择哪种缓存"><a href="#如何选择哪种缓存" class="headerlink" title="如何选择哪种缓存"></a>如何选择哪种缓存</h2><ul>
<li>如果需要对<strong>写请求进行加速</strong>，我们选择**<code>读写缓存</code>**</li>
<li>如果<strong>写请求很少</strong>，或者是只需要提升读请求的响应速度的话，我们选择**<code>只读缓存</code>**</li>
</ul>
<blockquote>
<p>举个例子，在商品大促的场景中，商品的库存信息会一直被修改。如果每次修改都需到数据库中处理，就会拖慢整个应用，此时，我们通常会选择读写缓存的模式。而在短视频App 的场景中，虽然视频的属性有很多，但是，一般确定后，修改并不频繁，此时，在数据库中进行修改对缓存影响不大，所以只读缓存模式是一个合适的选择。</p>
</blockquote>
<h2 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h2><p><img src="/redis_COAIX/tmp6537.png" alt="tmp6537"></p>
<p><strong><mark>在设置了过期时间的数据中进行淘汰</mark></strong></p>
<p><img src="/redis_COAIX/tmpF92B.png" alt="tmpF92B"></p>
<p><strong><mark>在所有数据中进行淘汰</mark></strong></p>
<img src="redis_COAIX/tmp45D5.png" alt="tmp45D5" style="zoom:120%;" />

<p>因为LRU在实现的时候会使用链表来管理所有的缓存数据，<strong>会带来额外的开销，所以Redis对LRU进行了简化</strong></p>
<p><strong><mark>Redis LRU</mark></strong>:</p>
<p>Redis 默认会记录**<code>每个数据的最近一次访问的时间戳</code><strong>（由</strong><code>键值对数据结构</code> RedisObject** 中的 <strong>lru 字段</strong>记录）。然后，Redis 在决定淘汰的数据时，第一次会<strong>随机选出 N 个数据</strong>，把它们作为一个**<code>候选集合</code><strong>。接下来，Redis 会</strong>比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。**</p>
<p><img src="/redis_COAIX/image-20220319173528780.png" alt="image-20220319173528780"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG SET maxmemory-samples 100 #设置候选集合的大小</span><br></pre></td></tr></table></figure>

<p><strong>在第一次创建出来候选集合之后还需要再淘汰数据</strong>，用<strong>之前的候选集合</strong>，就是**<code>选择小于之前集合最小lru值的元素入这个候选集合</code><strong>，<br>不再另外创建集合，</strong><code>如果候选集合满了，说明挑选完了，可以执行下一步，把lru最小的淘汰</code>**</p>
<h2 id="如何选择使用哪种淘汰策略"><a href="#如何选择使用哪种淘汰策略" class="headerlink" title="如何选择使用哪种淘汰策略"></a>如何选择使用哪种淘汰策略</h2><p><strong>优先使用 allkeys-lru 策略</strong>。这样，<strong>可以充分利用 LRU 这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能</strong>。如果你的业务数据中**<code>有明显的冷热数据区分，我建议你使用 allkeys-lru 策略</code><strong>。如果业务应用中的数据访问频率相差不大，</strong><code>没有明显的冷热数据区分，建议使用allkeys-random 策略</code><strong>，随机选择淘汰的数据就行。如果你的业务中有</strong><code>置顶的需求，比如置顶新闻、置顶视频，那么，可以使用 volatile-lru策略，同时不给这些置顶数据设置过期时间</code><strong>。这样一来，这些</strong><code>需要置顶的数据一直不会被删除，而其他数据会在过期时根据 LRU 规则进行筛选。</code>**</p>
<table>
<thead>
<tr>
<th>使用场景</th>
<th>策略</th>
</tr>
</thead>
<tbody><tr>
<td>一般场景</td>
<td>allkeys-lru</td>
</tr>
<tr>
<td>有明显冷热数据区分</td>
<td>allkeys-lru</td>
</tr>
<tr>
<td>没有明显冷数据区分</td>
<td>allkeys-random</td>
</tr>
<tr>
<td>有置顶需求</td>
<td>volatile-lru</td>
</tr>
</tbody></table>
<h2 id="淘汰的数据如何处理"><a href="#淘汰的数据如何处理" class="headerlink" title="淘汰的数据如何处理"></a>淘汰的数据如何处理</h2><p><img src="/redis_COAIX/tmp3BF8.png" alt="tmp3BF8"></p>
<p><strong>干净数据</strong>和<strong>脏数据</strong>的区别就在于，和最初从后端数据库里读取时的值相比，有没有被修改过。</p>
<ul>
<li><p>干净数据一直没有被修改，所以后端数据库里的数据也是最新值。</p>
</li>
<li><p>而脏数据就是曾经被修改过的，已经和后端数据库中保存的数据不一致了。此时，如果不把脏数据写回到数据库中，这个数据的最新值就丢失了，就会影响应用的正常使用。</p>
</li>
</ul>
<h2 id="过期数据如何处理"><a href="#过期数据如何处理" class="headerlink" title="过期数据如何处理"></a>过期数据如何处理<a name="guoqishujuchuli"></a></h2><p><a href="#zhucongbuyizhi"><strong>:point_right:<code>跳转 -&gt; 数据设定过期时间的指令引起的主从数据不一致问题</code></strong></a></p>
<p>两种策略来删除过期的数据，分别是<strong>惰性删除策略</strong>和<strong>定期删除策略</strong>。</p>
<p><strong><mark>惰性删除策略</mark></strong></p>
<p>当一个数据的过期时间到了以后，并<strong>不会立即删除数据</strong>，而是等到<strong>再有请求来读写这个数据时，对数据进行检查，如果发现数据已经过期了，再删除这个数据。</strong></p>
<p>但是从库本身**<code>不会执行删除操作</code><strong>，如果数据过期了，会返回这个值给客户端吗？</strong><code>不会</code>**！会返回空值</p>
<p><strong><mark>定期删除策略</mark></strong></p>
<p>Redis <strong>每隔一段时间</strong>（默认 100ms），就会**<code>随机选出一定数量的数据</code><strong>，</strong>检查它们是否过期，并把其中过期的数据删除，**这样就可以及时释放一些内存。</p>
<h2 id="缓存不一致"><a href="#缓存不一致" class="headerlink" title="缓存不一致"></a>缓存不一致</h2><ul>
<li>缓存中<strong>有数据</strong>，那么，缓存的数据值需要和数据库中的值相同</li>
<li>缓存中<strong>本身没有数据</strong>，那么，数据库中的值必须是最新值</li>
</ul>
<p>缓存写入策略：</p>
<ul>
<li><strong>同步直写</strong>策略：写缓存时，也同步写数据库，缓存和数据库中的<strong>数据一致</strong>；</li>
<li><strong>异步写回</strong>策略：写缓存时不同步写数据库，<strong>等到数据从缓存中淘汰时，再写回数据库</strong>。使用这种策略时，如果数据还没有写回数据库，缓存就发生了故障，那么，此时，数据库就没有最新的数据了。</li>
</ul>
<p><strong><code>问题怎么产生的</code></strong></p>
<p><img src="/redis_COAIX/image-20220319154008562.png" alt="image-20220319154008562"></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong><mark>解决方法</mark></strong></h3><p><strong><mark>重试机制</mark></strong>:</p>
<p> <strong><code>更新数据库 删除缓存值其中一个操作失败的情况下</code></strong></p>
<p>可以把要删除的缓存值或者是s要更新的数据库值暂存到<strong>消息队列</strong>中（例如使用Kafka 消息队列）。当应用没有能够成功地删除缓     存值或者是更新数据库值时，可以<strong>从消息队列中重新读取这些值，然后再次进行删除或更新。</strong></p>
<p><img src="/redis_COAIX/image-20220319154153486.png" alt="image-20220319154153486"></p>
<p><strong><mark>延迟双删</mark></strong></p>
<p><strong><code>先删除缓存，再更新数据库</code></strong></p>
<p><strong>在第一次删除缓存值后，延迟一段时间再次进行删除，所以我们也把它叫做“延迟双删”。</strong></p>
<p><strong>sleep()时间：<code>统计下线程读数据和写缓存的操作时间</code></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis.delKey(X) # 第一次删除</span><br><span class="line">db.update(X)	# Mysql更新</span><br><span class="line">Thread.sleep(N) # 延迟 sleep()</span><br><span class="line">redis.delKey(X)	# 第二次删除</span><br></pre></td></tr></table></figure>

<p><img src="/redis_COAIX/tmp9CA7.png" alt="tmp9CA7"></p>
<p><strong><mark>监听binlog</mark></strong></p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>缓存雪崩是指<code>大量的应用请求</code>无法在 Redis 缓存中进行处理</strong></p>
<p><strong><mark>原因 及 解决方案</mark></strong>:</p>
<p><strong><mark>原因 1.缓存中有大量数据同时过期，导致大量请求无法得到处理。</mark></strong></p>
<img src="redis_COAIX/image-20220319163640261.png" alt="image-20220319163640261" style="zoom:50%;" />

<p><strong><code>解决办法</code></strong></p>
<p>**<code>解决1.避免给大量的数据设置相同的过期时间</code>**。</p>
<p>如果业务层的确要求有些数据同时失效，你可以在用 <strong>EXPIRE 命令给每个数据设置过期时间时，给这些数据的过期时间增加一个较小的随机数（例如，随机增加 1~3 分钟</strong>），这样一来，<strong>不同数据的过期时间有所</strong><br><strong>差别，但差别又不会太大，既避免了大量数据同时过期，同时也保证了这些数据基本在相近的时间失效</strong>，仍然能满足业务需求。</p>
<p><strong><code>解决2.服务降级</code></strong></p>
<p>当业务应用访问的是<strong>非核心数据</strong>（例如电商商品属性）时，<strong>暂时停止从缓存中查询</strong>这些数据，而是直接返回<strong>预定义信息</strong>、<strong>空值</strong>或是<strong>错误信息</strong>；<br>当业务应用访问的是<strong>核心数据</strong>（例如电商商品库存）时，<strong>仍然允许查询缓存</strong>，如果缓存缺失，也可以继续通过数据库读取。</p>
<img src="redis_COAIX/image-20220319164342798.png" alt="image-20220319164342798" style="zoom:50%;" />

<p><strong><mark>Redis实例 发生故障宕机了</mark></strong></p>
<p>是在业务系统中实现<strong>服务熔断</strong>或<strong>请求限流机制</strong>。</p>
<p><strong><code>解决1.服务熔断</code></strong></p>
<p><strong>暂停业务应用对缓存系统的接口访问</strong>。再具体点说，就是业务应用调用缓存接口时，缓存客户端并不把请求发给 Redis 缓存实例，而是直接返回，不经过Mysql，等到 Redis 缓存实例<strong>重新恢复服务</strong>后，再允许应用请求发送到缓存系统。</p>
<img src="redis_COAIX/image-20220319164649083.png" alt="image-20220319164649083" style="zoom:50%;" />

<p><strong><code>解决2.请求限流</code></strong></p>
<p><strong>业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库。</strong></p>
<img src="redis_COAIX/image-20220319164746323.png" alt="image-20220319164746323" style="zoom: 67%;" />

<p><strong><code>解决3.事前预防</code></strong></p>
<p>通过**<code>主从节点的方式构建 Redis 缓存高可靠集群</code>**。如果 Redis 缓存的主节点故障宕机了，从节点还可以切换成为主节点，继续提供缓存服务，避免了由于缓存实例宕机而导致的缓存雪崩问题。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿是指，<strong>针对<code>某个</code>访问非常频繁的热点数据的请求</strong>，无法在缓存中进行处理，紧接着，访问该数据的大量请求，一下子都发送到了后端数据库，导致了数据库压力变大</p>
<p><img src="/redis_COAIX/image-20220319165015254.png" alt="image-20220319165015254"></p>
<p><strong><code>解决1：对于访问特别频繁的热点数据，不设置过期时间了</code></strong></p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>要访问的数据既<code>不在</code> Redis 缓存中，也<code>不在</code>数据库中</strong></p>
<p>出现原因：</p>
<ol>
<li>业务层误操作：缓存中的数据和数据库中的数据被误删除了，所以缓存和数据库中都没有数据</li>
<li>恶意攻击：专门访问数据库中没有的数据。</li>
</ol>
<p><strong><code>应对方案</code></strong></p>
<p><strong><code>1.缓存空值或缺省值。</code></strong></p>
<p><strong><code>2.使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力。</code></strong></p>
<p><img src="/redis_COAIX/image-20220319171403545.png" alt="image-20220319171403545"></p>
<p><strong><code>3.在请求入口的前端进行请求检测。</code></strong></p>
<h2 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h2><p>有些数据被<strong>访问的次数非常少，甚至只会被访问一次</strong>。当这些数据服务完访问请求后，如果还<strong>继续留存在缓存中的话，就只会白白占用缓存空间。这种情况，就是缓存污染。</strong></p>
<blockquote>
<p>简而言之：就是基本不被访问的数据在缓存中就是**<code>缓存污染</code>**</p>
</blockquote>
<p>**<code>LRU</code>**能解决吗？</p>
<p>使用 <strong><code>LRU</code></strong> 策略在<strong>处理<code>扫描式单次查询</code>操作时，无法解决缓存污染</strong>。所谓的扫描式单次查询操作，就是指应用对大量的数据进行一次全体读取，每个数据都会被读取，而且只会被读取一次</p>
<h3 id="LFU-缓存策略"><a href="#LFU-缓存策略" class="headerlink" title="LFU 缓存策略"></a>LFU 缓存策略</h3><p>LFU 缓存策略是<strong>在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数</strong>。当使用 LFU 策略筛选淘汰数据时，<strong>首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存</strong>。如果<strong>两个数据的访问次数相同，LFU 策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存</strong>。</p>
<p>在LRU的基础上：</p>
<ul>
<li>优先将访问次数最少的淘汰</li>
<li>访问次数相同再将访问时间最久的淘汰</li>
</ul>
<p><strong>Redis 在实现 LFU 策略的时候，只是<code>把原来 24bit 大小的 lru 字段，又进一步拆分成了两部分。</code></strong></p>
<p><img src="/redis_COAIX/Redis_LRU_LFU-16476825431141.png" alt="Redis_LRU_LFU"></p>
<p><strong><code>但是：只要访问次数超过了 255，数据的 counter 值就一样了。如果A访问了1000次，B访问了300次，但是B最近访问了一次，如果替换就会把1000次的A替换掉，实际使用A更多</code></strong></p>
<p>所以R<strong>edis对LFU进行了优化</strong>，在实现 LFU 策略时，Redis 并没有采用数据每被访问一次，就给对应的 counter 值加 1 的计数规则，而是采用了一个<strong>更优化的计数规则。</strong></p>
<h3 id="LFU优化计数规则"><a href="#LFU优化计数规则" class="headerlink" title="LFU优化计数规则"></a><strong><mark>LFU优化计数规则</mark></strong></h3><p><strong>每当数据被访问一次时，首先，用计数器当前的值乘以配置项 <code>lfu_log_factor</code> 再加 1，再取其倒数，得到一个 p 值；然后，把这个 p 值和一个取值范围在（0，1）间的随机数 r 值比大小，只有 p 值大于 r 值时，计数器才加 1。</strong></p>
<p><code>源码：</code></p>
<p>baseval是计数器当前的值。计数器的初始值默认是 5（由代码中的 LFU_INIT_VAL 常量设置），而不是 0，这样可以避免数据刚被写入缓存，就因为访问次数少而被立即淘汰。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> r = (<span class="type">double</span>)rand()/RAND_MAX;</span><br><span class="line">...</span><br><span class="line"><span class="type">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (r &lt; p) counter++;</span><br></pre></td></tr></table></figure>

<h3 id="Counter衰减机制"><a href="#Counter衰减机制" class="headerlink" title="Counter衰减机制"></a><strong><mark>Counter衰减机制</mark></strong></h3><p><strong><code>LFU</code></strong> 策略使用**<code>衰减因子配置项 lfu_decay_time</code>** 来<strong>控制访问次数的衰减</strong>。LFU 策略会计算<strong>当前时间和数据最近一次访问时间的<code>差值</code><strong>，并把这个</strong>差值<code>换算成以分钟为单位</code><strong>。然后，LFU 策略再把这个</strong>差值<code>除以 lfu_decay_time</code></strong> 值，所得的结果就是数据 counter 要衰减的值。</p>
<blockquote>
<p>decr &#x3D;<strong><code>getNow()</code></strong>- <strong><code>getlastTime(该数据Key)</code></strong></p>
<p>decr &#x3D; decr &#x2F; <strong><code>lfu_decay_time</code></strong></p>
<p>decr 就是这个数据需要衰减的值</p>
</blockquote>
<p>简单举个例子，假设 <strong>lfu_decay_time</strong> 取值为 1，如果<strong>数据在 N 分钟内没有被访问，那么它的访问次数就要减 N</strong>。如果 <strong>lfu_decay_time 取值更大，那么相应的衰减值会变小，衰减效果也会减弱</strong>。</p>
<p>所以，如果业务应用中有**<code>短时高频访问的数据</code><strong>的话，建议</strong><code>把lfu_decay_time 值设置为 1</code><strong>，这样一来，LFU 策略</strong><code>在它们不再被访问后，会较快地衰减它们的访问次数，尽早把它们从缓存中淘汰出去，避免缓存污染。</code>**</p>
<h1 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h1><h2 id="repl-backlog-buffer"><a href="#repl-backlog-buffer" class="headerlink" title="repl_backlog_buffer"></a><strong><mark>repl_backlog_buffer</mark></strong></h2><p><a href="#replbacklogbuffer"><strong>:point_right:<code>-&gt;跳转_repl_backlog_buffer</code></strong></a></p>
<h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h2><blockquote>
<p>使用缓冲区以后，当命令数据的接收方处理速度跟不上发送方的发送速度时，缓冲区可以避免命令数据的丢失。</p>
</blockquote>
<p><strong>溢出问题</strong></p>
<p><img src="/redis_COAIX/tmp66CC.png" alt="tmp66CC"></p>
<p><strong>解决方案</strong></p>
<p><img src="/redis_COAIX/tmp3911.png" alt="tmp3911"></p>
<p><img src="/redis_COAIX/tmp5EBB.png" alt="tmp5EBB"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis集群</title>
    <url>/2021/07/16/Redis%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h1 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h1><p>Redis 提供了<strong>主从库模式</strong>，以保证数据副本的一致，主从库之间采用的是<strong>读写分离</strong>的方式。多实例保存同一份数据</p>
<ul>
<li><strong>读</strong>操作：主库、从库都可以接收；</li>
<li><strong>写</strong>操作：<strong>首先到主库执行，然后，主库将写操作同步给从库。</strong></li>
</ul>
<p><img src="/redis_COAIX/tmp216F.png" alt="tmp216F"></p>
<h2 id="主从一致"><a href="#主从一致" class="headerlink" title="主从一致"></a><strong>主从一致</strong></h2><h3 id="主从第一次同步"><a href="#主从第一次同步" class="headerlink" title="主从第一次同步"></a><code>主从第一次同步</code></h3><p><strong>多个 Redis 实例</strong>相互之间就可以通过 <code>replicaof</code>（Redis 5.0 之前使用 <code>slaveof</code>）命令形成主库和从库的关系，之后会按照<strong>三个阶段</strong>完成数据的<strong>第一次同步。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">replicaof 172.16.19.3 6379</span><br></pre></td></tr></table></figure>

<p><mark>第一次同步</mark></p>
<p><img src="/redis_COAIX/tmp8F1A.png" alt="tmp8F1A"></p>
<ol>
<li><p>是主从库间建立连接、协商同步的过程，主要是<strong>为全量复制做准备</strong>。在这一步，<strong>从库和主库建立起连接，并告诉主库即将进行同步</strong>，主库确认回复后，主从库间就可以开始同步了。</p>
<ul>
<li><p><strong>psync</strong> 命令包含了<strong>主库的 runID</strong> 和<strong>复制进度 offset</strong> 两个参数</p>
<ul>
<li><p><strong><code>runId</code></strong>:</p>
<p>从库和主库第一次复制时，因为<strong>不知道主库的 runID</strong>，所以<strong>将 runID 设为“？”</strong>。</p>
</li>
<li><p><strong><code>offset</code></strong>:</p>
<p>第一次时设为 <strong>-1</strong>，<strong>表示第一次复制</strong>。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>主库会发送FULLRESYNC:带上两个参数：<strong>主库 runID</strong> 和<strong>主库目前的复制进度 offset</strong>，<strong>返回给从库</strong>。</p>
<blockquote>
<p><strong>主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。</strong></p>
</blockquote>
<ul>
<li>FULLRESYNC 响应表示**<code>第一次复制采用的全量复制</code>**，也就是说，主库会把当前所有的数据都复制给从库。</li>
<li><strong>从库收到数据后,清空当前数据库(可能保存了别的数据)，在本地完成数据加载</strong>。这个过程依赖于<strong>内存快照生成的 RDB 文件。</strong></li>
</ul>
<p><strong>在主库将数据同步给从库的过程中，主库不会被阻塞</strong>，仍然可以正常接收请求</p>
<p>为了保证主从库的数据一致性，主库会在内存中用专门的 **<mark>replication buffer</mark>**，记录RDB 文件生成后收到的所有写操作。</p>
<p>第一同步完成之后，之后都是使用这个**<mark>replication buffer</mark><strong>进行</strong>主库传送数从库**</p>
</li>
<li><p>主库会把**第二阶段执行过程中<code>新收到的写命令</code>**，再发送给从库。</p>
<p>具体的操作是，**<code>当主库完成 RDB 文件发送后</code>**，就会把此时 **<mark>replication buffer</mark>**中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p>
</li>
</ol>
<blockquote>
<p><strong><code>一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为基于长连接的命令传播，可以避免频繁建立连接的开销。</code></strong></p>
</blockquote>
<h2 id="主从级联分担全量复制时候主库的压力"><a href="#主从级联分担全量复制时候主库的压力" class="headerlink" title="主从级联分担全量复制时候主库的压力"></a><code>主从级联</code>分担<code>全量复制</code>时候<code>主库</code>的压力</h2><blockquote>
<p><strong>如果从库数量很多，主库对于每个从库都要fork出一个子进程，压力很大</strong></p>
</blockquote>
<p><strong>“主 - 从 - 从”模式</strong></p>
<p><img src="/redis_COAIX/tmp2896.png" alt="tmp2896"></p>
<h2 id="主从库间网络断了"><a href="#主从库间网络断了" class="headerlink" title="主从库间网络断了"></a>主从库间网络断了</h2><p>网络断了之后，主从库会采用增量复制的方式继续同步</p>
<p><strong><mark>repl_backlog_buffer</mark></strong><a name="replbacklogbuffer"></a></p>
<p><strong>repl_backlog_buffer 是一个<code>环形缓冲区</code>，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。</strong></p>
<p><img src="/redis_COAIX/image-20220319114423868.png" alt="image-20220319114423868"></p>
<p>主从库连接恢复之后，从库首先会给主库发送 <strong><code>psync</code></strong> 命令（不是第一次连接了），并把自己当前的slave_repl_offset 发给主库，主库会判断自己的 master_repl_offset 和 slave_repl_offset之间的差距。</p>
<p><strong>主库和从库之间相差的操作，在增量复制时，主库只需要把它们同步给从库，就行了。</strong></p>
<p><img src="/redis_COAIX/tmp5874.png" alt="tmp5874"></p>
<p><strong>环形缓冲区风险</strong></p>
<p>因为 repl_backlog_buffer 是一个**<code>环形缓冲区</code><strong>，所以在</strong><code>缓冲区写满后</code><strong>，主库会继续写入，此时，就会覆盖掉之前写入的操作。如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被</strong><code>主库新写的操作覆盖</code><strong>了，</strong><code>这会导致主从库间的数据不一致。</code>**</p>
<blockquote>
<p>解决办法：增大缓冲区…repl_backlog_size</p>
</blockquote>
<h2 id="主从之间会场产生的问题"><a href="#主从之间会场产生的问题" class="headerlink" title="主从之间会场产生的问题"></a>主从之间会场产生的问题</h2><h3 id="主从数据不一致"><a href="#主从数据不一致" class="headerlink" title="主从数据不一致"></a>主从数据不一致</h3><p>客户端从从库中读取到的值和主库中的<strong>最新值并不一致</strong>。</p>
<p>因为**<code>主从库间的命令复制是异步进行的，从库有可能会滞后执行同步命令</code>**</p>
<p>原因</p>
<ul>
<li><strong>网络阻塞</strong></li>
<li>从库及时收到了主库的命令，但是，也可能会因为正在<strong>处理其它复杂度高的命令</strong>（例如集合操作命令）而阻塞</li>
</ul>
<h3 id="读到过期的数据"><a href="#读到过期的数据" class="headerlink" title="读到过期的数据"></a>读到过期的数据<a name="zhucongbuyizhi"></a></h3><p><a href="#guoqishujuchuli"><strong>:point_right:<code>跳转 -&gt; Redis删除过期数据采用策略</code></strong></a></p>
<p>跟**<code>命令</code>**有关</p>
<p><strong>EXPIRE</strong> 和 <strong>PEXPIRE</strong>：它们给数据设置的是<strong>从命令执行时开始计算的存活时间</strong></p>
<p><strong>EXPIREAT</strong> 和 <strong>PEXPIREAT</strong>：它们会直接把数据的<strong>过期时间设置为<code>具体的一个时间点</code></strong></p>
<p><strong><code>因为EXPIRE是再当前时间基础上加存活时间</code><strong>，收到了一条 <strong>EXPIRE</strong> 命令，</strong>主库会直接执行这条命令</strong>。这条命令会在全量同步完成后，发给从库执行。而<strong>从库在执行时，就会在当前时间的基础上加上数据的存活时间</strong>，这样一来，<strong>从库上数据的过期时间就会比主库上延后了。</strong></p>
<p><img src="/redis_COAIX/image-20220319190628144.png" alt="image-20220319190628144"></p>
<h2 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h2><blockquote>
<p>数据丢失</p>
</blockquote>
<p><strong>概念：主从集群中，同时有两个主节点，它们都能接收写请求。而脑裂最直接的影响，就是客户端不知道应该往哪个主节点写入数据，结果就是不同的客户端会往不同的主节点上写入数据。而且，严重的话，脑裂会进一步导致数据丢失。</strong></p>
<p><strong><code>哨兵切换完成后，客户端会和新主库进行通信，发送请求操作。但是，在切换过程中，既然客户端仍然和原主库通信，这就表明，原主库并没有真的发生故障（例如主库进程挂掉），主库是由于某些原因无法处理请求，也没有响应哨兵的心跳，才被哨兵错误地判断为客观下线的。结果，在被判断下线之后，原主库又重新开始处理请求了，而此时，哨兵还没有完成主从切换，客户端仍然可以和原主库通信，客户端发送的写操作就会在原主库上写入数据了。</code></strong></p>
<p><strong>为什么会数据丢失？</strong></p>
<p>主从切换后，从库一旦升级为新主库，**<code>哨兵就会让原主库执行 slave of 命令</code><strong>，</strong>和新主库重新进行全量同步<strong>。而在全量同步执行的最后阶段，</strong>原主库需要<code>清空本地的数据</code><strong>，加载新主库发送的 RDB 文件，这样一来，</strong>原主库在主从切换期间保存的新写数据就丢失**。</p>
<p><img src="/redis_COAIX/image-20220319192409135.png" alt="image-20220319192409135"></p>
<p><strong><mark>解决方法</mark></strong></p>
<p>Redis 已经提供了<strong>两个配置项来限制主库的请求处理</strong>，分别是 <strong>minslaves-to-write</strong> 和 <strong>min-slaves-max-lag。</strong></p>
<p>把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。这两个配置项组合后的要求是，<strong>主库连接的从库中至少有 N 个从库</strong>，<strong>和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的请求了。</strong></p>
<p><strong>即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 ACK 确认了。</strong>这样一来，<strong>min-slaves-to-write</strong> 和 <strong>min-slavesmax-lag</strong> 的<strong>组合要求</strong>就无法得到满足，<strong>原主库就会被限制接收客户端请求，客户端也就不能在原主库中写入新数据了。</strong></p>
<p><strong>等到新主库上线时，就只有新主库能接收和处理客户端请求，此时，新写的数据会被直接写到新主库中。</strong>而原主库会被**<code>哨兵降为从库</code>**，即使它的数据被清空了，也不会有新数据丢失。</p>
<blockquote>
<p>假设我们将 min-slaves-to-write 设置为 1，把 min-slaves-max-lag 设置为 12s，把哨兵的 down-after-illiseconds 设置为 10s，主库因为某些原因卡住了 15s，导致哨兵判断主库客观下线，开始进行主从切换。同时，因为原主库卡住了 15s，没有一个从库能和原主库在 12s 内进行数据复制，原主库也无法接收客户端请求了。这样一来，主从切换完成后，也只有新主库能接收请求，不会发生脑裂，也就不会发生数据丢失的问题了。</p>
</blockquote>
<hr>
<h1 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h1><p><img src="/redis_COAIX/image-20220319115957142.png" alt="image-20220319115957142"></p>
<p>运行在<strong>特殊模式下的 Redis 进程</strong>，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：**<code>监控、选主（选择主库）和通知。</code>**</p>
<p><img src="/redis_COAIX/tmpA5C6.png" alt="tmpA5C6"></p>
<ol>
<li>周期性地给所有的主从库发送 **<code>PING 命令</code>**，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始自动切换主库的流程。</li>
<li>主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。这一步完成后，现在的集群<br>里就有了新主库。</li>
<li>哨兵会把新主库的连接信息发给其他从库，让它们执行 <code>replicaof</code> 命令，和新主库建立连接，并进行数据复制。同时，<strong>哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上。</strong></li>
</ol>
<h2 id="主观下线，客观下线"><a href="#主观下线，客观下线" class="headerlink" title="主观下线，客观下线"></a>主观下线，客观下线</h2><p>哨兵也是集群，自己认为主库挂了，是主观下线，从别人那里收到主库挂了是客观下线。</p>
<p>判断主库是否下线，**<code>少数服从多数</code>**</p>
<p><img src="/redis_COAIX/tmp53E5.png" alt="tmp53E5"></p>
<h2 id="如何选定新主库"><a href="#如何选定新主库" class="headerlink" title="如何选定新主库"></a>如何选定新主库</h2><p>先按照**<code>一定的筛选条件</code><strong>，把不符合条件的从库去掉。然后，我们再按照</strong><code>一定的规则</code>**打分选择</p>
<ul>
<li><p>筛选</p>
<ul>
<li>总是断连的不要，断连次数超过阈值<code>down-after-milliseconds * 10</code>的不要，这种库网络状况不好</li>
</ul>
</li>
<li><p>规则</p>
<ul>
<li>优先级最高的从库得分高</li>
<li>和旧主库同步程度最接近的从库得分高，通过<code>repl_backlog_buffer</code>环形缓冲区</li>
<li>ID 号小的从库得分高</li>
</ul>
</li>
</ul>
<h2 id="哨兵直接通信"><a href="#哨兵直接通信" class="headerlink" title="哨兵直接通信"></a>哨兵直接通信</h2><blockquote>
<p>Redis 提供的 <strong><code>pub/sub</code></strong> 机制，也就是**<code>发布 / 订阅</code>**</p>
</blockquote>
<p>在主从集群中，主库上有一个名为**<code>“sentinel:hello”</code><strong>的频道，</strong><code>不同哨兵就是通过它来相互发现，实现互相通信的</code>**。</p>
<p><img src="/redis_COAIX/tmpFF92.png" alt="tmpFF92"></p>
<p><strong>通过INFO命令得知从库的IP和端口</strong></p>
<p><img src="/redis_COAIX/image-20220319120535235.png" alt="image-20220319120535235"></p>
<h2 id="选择哪个库进行主从切换和通知"><a href="#选择哪个库进行主从切换和通知" class="headerlink" title="选择哪个库进行主从切换和通知"></a>选择哪个库进行主从切换和通知</h2><p>哨兵判断主库下线之后会给自己投一票，让别的哨兵给自己投票，每个哨兵只有一票，如果有多个哨兵同时请求别人给自己投票，投出去一张之后不会再投，超过半数就选定</p>
<p>如果这一轮没有产生Leader，<strong>这轮投票就不会产生 Leader</strong>。**<code>哨兵集群会等待一段时间（也就是哨兵故障转移超时时间的 2 倍）</code><strong>，再重新选举。这是因为，</strong><code>哨兵集群能够进行成功投票，很大程度上依赖于选举命令的正常网络传播</code>**。如果网络压力较大或有短时堵塞，就可能导致没有一个哨兵能拿到半数以上的赞成票。所以，等到网络拥塞好转之后，再进行投票选举，成功的概率就会增加。</p>
<p><strong>如果哨兵集群只有 2 个实例，此时，一个哨兵要想成为 Leader，必须获得2 票，而不是 1 票。所以，如果有个哨兵挂掉了，那么，此时的集群是无法进行主从库切换的。因此，通常我们至少会配置 3 个哨兵实例</strong></p>
<h1 id="切片集群"><a href="#切片集群" class="headerlink" title="切片集群"></a>切片集群</h1><p><img src="/redis_COAIX/image-20220319121056403.png" alt="image-20220319121056403"></p>
<h2 id="Redis-Cluster方案"><a href="#Redis-Cluster方案" class="headerlink" title="Redis Cluster方案"></a>Redis Cluster方案</h2><p>Redis Cluster 方案采用<strong>哈希槽</strong>（Hash Slot，接下来我会直接称之为 Slot），来处理<strong>数据和实例之间的映射关系</strong>。在 Redis Cluster 方案中，一个切片集群共有 <strong><code>16384</code><strong>个哈希槽，这些哈希槽类似于数据分区，</strong><code>每个键值对都会根据它的 key，被映射到一个哈希槽中。</code></strong></p>
<p><strong><code>CRC16(key)&amp;16384 哈希槽个数</code></strong></p>
<p><img src="/redis_COAIX/tmpEFD1.png" alt="tmpEFD1"></p>
<p><strong>客户端和集群实例建立连接后，实例就会把<code>哈希槽的分配信息发给客户端</code></strong></p>
<p><strong>客户端收到哈希槽信息后，会把<code>哈希槽信息缓存在本地</code>。当客户端请求键值对时，<code>会先计算键所对应的哈希槽</code>，然后就可以给相应的实例发送请求了。</strong></p>
<p>哈希槽的位置会产生变化</p>
<ul>
<li>在集群中，**<code>实例有新增或删除</code><strong>，Redis 需要</strong>重新分配哈希槽**</li>
<li>为了**<code>负载均衡</code><strong>，Redis 需要把哈希槽</strong>在所有实例上重新分布一遍**。</li>
</ul>
<h2 id="重定向机制"><a href="#重定向机制" class="headerlink" title="重定向机制"></a>重定向机制</h2><p><strong>这个实例上并没有相应的数据，这个实例会给客户端返回下面的 MOVED  命令响应结果，这个结果中就包含了<code>新实例的访问地址</code>。<code>同时客户端会更新该Slot的新位置</code>。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET hello:key</span><br><span class="line">(error) MOVED 13320 172.16.19.5:6379</span><br></pre></td></tr></table></figure>

<p><img src="/redis_COAIX/image-20220319140354503.png" alt="image-20220319140354503"></p>
<p><strong>如果这个时候该哈希槽的数据正在迁移中，会收到实例返回的ASK命令，表示数据正在迁移中，会把新的Slot实例位置发送给客户端，<code>但是这种情况下客户端不会改变Slot跟实例的映射关系</code></strong></p>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p><strong><mark>SET</mark></strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>EX</td>
<td>设置键的过期时间为second 秒</td>
</tr>
<tr>
<td>PX</td>
<td>设置键的过期时间为millisecond 毫秒</td>
</tr>
<tr>
<td>NX</td>
<td>只在键不存在时，才对键进行设置操作,效果等同于**<code>SETEX</code>**</td>
</tr>
</tbody></table>
<p><strong>分布式锁流程</strong></p>
<p><strong><code>setnx失败会返回null</code></strong></p>
<p>设置<strong>过期时间</strong>，可以<strong>防止锁无法释放</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET lock_key unique_value NX PX 10000</span><br></pre></td></tr></table></figure>

<p><img src="/redis_COAIX/image-20220319175118926.png" alt="image-20220319175118926"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Spring注解驱动开发</title>
    <url>/2022/01/26/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="spring注解"><a href="#spring注解" class="headerlink" title="spring注解"></a>spring注解</h2><p><a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html">注解是什么，有哪些要求，怎么用(反射)？</a></p>
<ul>
<li><strong>@Configuration</strong> 用于标注配置类</li>
<li><strong>@Bean</strong> 结合@Configuration（full mode）使用或结合@Component（light mode）使用。可以导入第三方组件,入方法有参数默认从IOC容器中获取，可以指定initMethod和destroyMethod 指定初始化和销毁方法,多实例对象不会调用销毁方法.</li>
<li>包扫描@ComponentScan (@ComponentScans可以配置多个扫描,@TypeFilter:指定过滤规则,自己实现TypeFilter类)<br>组件(@Service、@Controller、@Repository):包扫描+组件注解导入注解。</li>
<li><strong>@Scope</strong>:设置组件作用域 <ul>
<li>1.<strong>prototype</strong>:<strong>多例</strong>的</li>
<li>2.<strong>singleton</strong>:<strong>单例</strong>的（默认值）</li>
</ul>
</li>
<li><strong>@Lazy</strong> 懒加载</li>
<li><strong>@Conditional</strong>({Condition}):按照一定的条件进行判断,满足条件给容器中注册Bean,传入Condition数组,，使用时需自己创建类继承Condition然后重写match方法。</li>
<li><strong>@Import</strong>[快速给容器中导入一个组件]<ol>
<li>Import(类名),容器中就会自动注册这个组件，id默认是组件的全名</li>
<li>ImportSelector：返回需要导入的组件的全类名的数组，自定义一个Selector，然后返回全类名就是需要导入的组件(比如:com.coaixlw.Color.class)</li>
<li>ImportBeanDefinitionRegistrar：手动注册bean</li>
</ol>
</li>
<li><strong>FactoryBean</strong>:工厂Bean,交给spring用来生产Bean到spring容器中.可以通过前缀&amp;来获取工厂Bean本身.</li>
<li><strong>@Value</strong>:给属性赋值,也可以使用SpEL和外部文件的值</li>
<li><strong>@PropertySource</strong>:读取外部配置文件中的k&#x2F;v保存到运行环境中,结合@value使用,或使用ConfigurableEnvironment获取</li>
<li><strong>@Profile</strong>:结合@Bean使用,默认为default环境,可以通过命令行参数来切换环境</li>
<li>自定义组件使用Spring容器底层的组件:需要让自定义组件实现xxxAware，(例如:ApplicationContextAware),spring在创建对象的时候,会帮我们自动注入。spring通过BeanPostProcessor机制来实现XXXXAware的自动注入。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContextProcessor.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeAwareInterfaces</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">                ((ResourceLoaderAware)bean).setResourceLoader(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">                ((ApplicationContextAware)bean).setApplicationContext(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>@Autowried 装配优先级如下:</p>
<ol>
<li>使用按照类型去容器中找对应的组件</li>
<li>按照属性名称去作为组件id去找对应的组件</li>
</ol>
</li>
<li><p>@Qualifier:指定默认的组件,结合@Autowried使用<br>--标注在构造器:spring创建对象调用构造器创建对象<br>--标注在方法上:</p>
</li>
<li><p>@Primary:spring自动装配的时候,默认首先bean,配合@Bean使用</p>
</li>
<li><p>@Resource(JSR250):jsr规范:按照组件名称进行装配</p>
</li>
<li><p>@Inject(JSR330):jsr规范和@Autowired功能一致,不支持require&#x3D;false;</p>
</li>
</ul>
<h2 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h2><p>总结一下生命周期<br>Spring容器启动进行扫描,把BeanName变成<strong>BeanDefinition（可以理解为SpringBean的一个建模）</strong>对象-&gt;放入BeanDefinitionMap-&gt;<strong>遍历</strong>做一系列的<strong>验证</strong>(是否单例、是否延迟加载、是否抽象)-&gt;去单例池中查是否存在如果没有被创建，就再去去<strong>二级缓存</strong>查是否存在(提前暴露)-&gt;如果都没有,准备创建Bean对象，会对其<strong>进行初始化工作</strong>-&gt;推断构造方法(一个bean如果有很多构造方法的话)-&gt;通过反射实例化Java对象-&gt;进行初始化,比如是否支持循环依赖,如果支持就生成当前Java对象的ObjectFactory对象存到二级缓存(Map)中(暴露)-&gt;进行属性填充(自动注入)如果x依赖了y就会把y set进去-&gt;代码接着往下执行-&gt;进行各种Aware接口的回调-&gt;进行生命周期初始化的回调(InitializingBean)-&gt;生成代理(前提有AOP)，做一些发布事件,生命周期差不多就走完了-&gt;放入单例池</p>
<p><strong>初始化和销毁</strong></p>
<blockquote>
<p>初始化是Bean赋完属性的时候，对象创建好，并赋值好，调用初始化方法，Destory是指Bean对象销毁的时候</p>
</blockquote>
<ol>
<li><p>通过**@Bean** 指定<strong>init-method</strong>和<strong>destroy-method</strong></p>
</li>
<li><p>Bean类实现<strong>InitializingBean</strong>定义初始化逻辑,实现<strong>DisposableBean</strong>定义销毁方法</p>
</li>
<li><p>实现<strong>BeanPostProcessor</strong>接口的<strong>后置拦截器放入容器</strong>中，可以拦截bean初始化，并可以在被拦截的Bean的初始化前后进行一些处理工作。<code>BeforeInitialization</code> <code>AfterInitialization</code>一个在<code>初始化</code>之前，一个在<code>初始化</code>之后</p>
</li>
</ol>
<p>spring底层常用的BeanPostProcessor：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">\* BeanValidationPostProcessor用来实现数据校验</span><br><span class="line">\* AutowireAnnotationBeanPostProcessor,<span class="meta">@Autowire</span>实现</span><br><span class="line">\* ApplicationContextProcessor实现XXXAware的自动注入。</span><br></pre></td></tr></table></figure>

<p><strong>执行时机</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doCreateBean</span><br><span class="line">-populateBean（）：给bean的各种属性赋值</span><br><span class="line">-initializeBean（）：初始化bean</span><br><span class="line">-处理Aware方法</span><br><span class="line">-applyBeanPostProcessorsBeforeInitialization：后置处理器的实例化前拦截</span><br><span class="line">-invokeInitMethods:执行<span class="meta">@Bean</span>指定的initMethod</span><br><span class="line">-applyBeanPostProcessorsAfterInitialization：后置处理器的实例化后拦截</span><br></pre></td></tr></table></figure>

<h2 id="SpringAOP实现原理"><a href="#SpringAOP实现原理" class="headerlink" title="SpringAOP实现原理"></a>SpringAOP实现原理</h2><blockquote>
<p>AOP-&gt;【动态代理】<br>指在<strong>程序运行期间动态</strong>的将<strong>某段代码</strong>切入到<strong>指定方法指定位置进行运行</strong>的编程方式：</p>
</blockquote>
<p><strong>使用步骤</strong></p>
<ol>
<li><p><strong>@EnableAspectJAutoProxy</strong> 开启基于注解的aop模式</p>
</li>
<li><p><strong>@Aspect</strong>：定义切面类，切面类里定义通知</p>
</li>
<li><p><strong>@PointCut</strong> 切入点，可以写切入点表达式，指定在哪个方法切入</p>
</li>
<li><p>通知方法</p>
<ul>
<li><strong>@Before</strong>(前置通知)</li>
<li><strong>@After</strong>(后置通知)</li>
<li><strong>@AfterReturning</strong>(返回通知)</li>
<li><strong>@AfterTrowing</strong>(异常通知)</li>
<li><strong>@Around</strong>(环绕通知)</li>
</ul>
<h3 id="正常情况：-Before-x3D-x3D-目标方法-x3D-x3D-AfterReturning-x3D-x3D-After"><a href="#正常情况：-Before-x3D-x3D-目标方法-x3D-x3D-AfterReturning-x3D-x3D-After" class="headerlink" title="正常情况：@Before&#x3D;&#x3D;目标方法&#x3D;&#x3D;@AfterReturning&#x3D;&#x3D;@After"></a>正常情况：@Before&#x3D;&#x3D;目标方法&#x3D;&#x3D;@AfterReturning&#x3D;&#x3D;@After</h3><h3 id="异常情况：-Before-x3D-x3D-目标方法-x3D-x3D-AfterThrowing-x3D-x3D-After"><a href="#异常情况：-Before-x3D-x3D-目标方法-x3D-x3D-AfterThrowing-x3D-x3D-After" class="headerlink" title="异常情况：@Before&#x3D;&#x3D;目标方法&#x3D;&#x3D;@AfterThrowing&#x3D;&#x3D;@After"></a>异常情况：@Before&#x3D;&#x3D;目标方法&#x3D;&#x3D;@AfterThrowing&#x3D;&#x3D;@After</h3><h3 id="正常情况：环绕前置-x3D-x3D-Before-x3D-x3D-目标方法执行-x3D-x3D-AfterReturning-x3D-x3D-After-x3D-x3D-环绕返回-x3D-x3D-环绕最终"><a href="#正常情况：环绕前置-x3D-x3D-Before-x3D-x3D-目标方法执行-x3D-x3D-AfterReturning-x3D-x3D-After-x3D-x3D-环绕返回-x3D-x3D-环绕最终" class="headerlink" title="正常情况：环绕前置&#x3D;&#x3D;@Before&#x3D;&#x3D;目标方法执行&#x3D;&#x3D;@AfterReturning&#x3D;&#x3D;@After&#x3D;&#x3D;环绕返回&#x3D;&#x3D;环绕最终"></a>正常情况：环绕前置&#x3D;&#x3D;@Before&#x3D;&#x3D;目标方法执行&#x3D;&#x3D;@AfterReturning&#x3D;&#x3D;@After&#x3D;&#x3D;环绕返回&#x3D;&#x3D;环绕最终</h3><h3 id="异常情况：环绕前置-x3D-x3D-Before-x3D-x3D-目标方法执行-x3D-x3D-AfterThrowing-x3D-x3D-After-x3D-x3D-环绕异常-x3D-x3D-环绕最终s"><a href="#异常情况：环绕前置-x3D-x3D-Before-x3D-x3D-目标方法执行-x3D-x3D-AfterThrowing-x3D-x3D-After-x3D-x3D-环绕异常-x3D-x3D-环绕最终s" class="headerlink" title="异常情况：环绕前置&#x3D;&#x3D;@Before&#x3D;&#x3D;目标方法执行&#x3D;&#x3D;@AfterThrowing&#x3D;&#x3D;@After&#x3D;&#x3D;环绕异常&#x3D;&#x3D;环绕最终s"></a>异常情况：环绕前置&#x3D;&#x3D;@Before&#x3D;&#x3D;目标方法执行&#x3D;&#x3D;@AfterThrowing&#x3D;&#x3D;@After&#x3D;&#x3D;环绕异常&#x3D;&#x3D;环绕最终s</h3></li>
<li><p><strong>JoinPoint</strong>：连接点,是一个类，配合通知使用，用于获取切入的点的信息</p>
</li>
</ol>
<p><strong>SpringAop原理</strong></p>
<ol>
<li><p>@EnableAspectJAutoProxy</p>
<ul>
<li>@EnableAspectJAutoProxy 通过@Import(AspectJAutoProxyRegistrar.class)给spring容器中导入了一个<strong>AnnotationAwareAspectJAutoProxyCreator</strong>。</li>
<li>AnnotationAwareAspectJAutoProxyCreator实现了<strong>InstantiationAwareBeanPostProcessor</strong>,InstantiationAwareBeanPostProcessor是一个<strong>BeanPostProcessor</strong>。它可以拦截<strong>spring的Bean初始化(Initialization)前后</strong>和<strong>实例化(Initialization)前后</strong>。</li>
</ul>
</li>
<li><p><strong>AnnotationAwareAspectJAutoProxyCreator</strong>的<strong>postProcessBeforeInstantiation(bean实例化前)<strong>：会通过调用</strong>isInfrastructureClass(beanClass)<strong>来判断 被拦截的类是否是基础类型的Advice、PointCut、Advisor、</strong>AopInfrastructureBean</strong>，或者是否是切面（@Aspect），若是则放入<strong>adviseBean</strong>集合。这里主要是用来<strong>处理我们的切面类。</strong></p>
</li>
<li><p>AnnotationAwareAspectJAutoProxyCreator的BeanPostProcessorsAfterInitialization（bean初始化后）：</p>
<ol>
<li>首先找到被拦截的Bean的匹配的增强器（通知方法），这里有切入点表达式匹配的逻辑</li>
<li>将增强器保存到proxyFactory中，</li>
<li>根据被拦截的Bean是否实现了接口，spring自动决定使用JdkDynamicAopProxy还是ObjenesisCglibAopProxy</li>
<li>最后返回被拦截的Bean的代理对象，注册到spring容器中</li>
</ol>
</li>
<li><p>代理Bean的目标方法执行过程：CglibAopProxy.intercept();</p>
<ol>
<li>保存所有的增强器，并处理转换为一个拦截器链</li>
<li>如果没有拦截器链，就直接执行目标方法</li>
<li>如果有拦截器链，就将目标方法，拦截器链等信息传入并创建CglibMethodInvocation对象，并调用proceed()方法获取返回值。proceed方法内部会依次执行拦截器链。</li>
</ol>
</li>
</ol>
<p><strong>S总结：</strong><br>          1）、**@EnableAspectJAutoProxy** 开启AOP功能<br>          2）、**@EnableAspectJAutoProxy** 会给容器中<strong>注册</strong>一个组件 <strong>AnnotationAwareAspectJAutoProxyCreator</strong><br>          3）、AnnotationAwareAspectJAutoProxyCreator是一个<strong>后置处理器</strong>；<br>          4）、容器的创建流程：<br>              1）、容器创建的时候有一步<strong>refresh</strong>，在refresh中有一步<strong>registerBeanPostProcessors</strong>（）<strong>注册后置处理器</strong>；<br>                  在这里创建AnnotationAwareAspectJAutoProxyCreator对象<br>              2）、finishBeanFactoryInitialization（）<strong>初始化剩下的单实例bean</strong><br>                  1）、创建<strong>业务逻辑组件</strong>和<strong>切面组件</strong><br>                  2）、关键异步就是AnnotationAwareAspectJAutoProxyCreator<strong>后置处理器会</strong>来<strong>拦截组件的创建过程</strong><br>                  3）、<strong>组件创建完之后，判断组件是否需要增强</strong><br>                      是：<strong>切面的通知方法，包装成增强器（Advisor）;给业务逻辑组件创建一个代理对象</strong>（默认cglib）；如果是接口也能用jdk动态代理<br>          5）、执行目标方法：<br>              1）、代理对象执行目标方法<br>              2）、如何执行？-&gt;CglibAopProxy.intercept()；<br>                  1）、得到目标方法的<strong>拦截器链</strong>（增强器包装成拦截器MethodInterceptor）<br>                  2）、利用拦截器的链式机制，依次进入每一个拦截器进行执行；<br>                  3）、效果：<br>                      正常执行：前置通知-》目标方法-》后置通知-》返回通知<br>                      出现异常：前置通知-》目标方法-》后置通知-》异常通知</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * AOP：【动态代理】</span><br><span class="line"> * 		指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式；</span><br><span class="line"> * </span><br><span class="line"> * 1、导入aop模块；Spring AOP：(spring-aspects)</span><br><span class="line"> * 2、定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx）</span><br><span class="line"> * 3、定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行；</span><br><span class="line"> * 		通知方法：</span><br><span class="line"> * 			前置通知(@Before)：logStart：在目标方法(div)运行之前运行</span><br><span class="line"> * 			后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束）</span><br><span class="line"> * 			返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行</span><br><span class="line"> * 			异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行</span><br><span class="line"> * 			环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()）</span><br><span class="line"> * 4、给切面类的目标方法标注何时何地运行（通知注解）；</span><br><span class="line"> * 5、将切面类和业务逻辑类（目标方法所在类）都加入到容器中;</span><br><span class="line"> * 6、必须告诉Spring哪个类是切面类(给切面类上加一个注解：@Aspect)</span><br><span class="line"> * [7]、给配置类中加 @EnableAspectJAutoProxy 【开启基于注解的aop模式】</span><br><span class="line"> * 		在Spring中很多的 @EnableXXX;</span><br><span class="line"> * </span><br><span class="line"> * 三步：</span><br><span class="line"> * 	1）、将业务逻辑组件和切面类都加入到容器中；告诉Spring哪个是切面类（@Aspect）</span><br><span class="line"> * 	2）、在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式）</span><br><span class="line"> *  3）、开启基于注解的aop模式；@EnableAspectJAutoProxy</span><br><span class="line"> *  </span><br><span class="line"> * AOP原理：【看给容器中注册了什么组件，这个组件什么时候工作，这个组件的功能是什么？】</span><br><span class="line"> * 		@EnableAspectJAutoProxy；</span><br><span class="line"> * 1、@EnableAspectJAutoProxy是什么？</span><br><span class="line"> * 		@Import(AspectJAutoProxyRegistrar.class)：给容器中导入AspectJAutoProxyRegistrar</span><br><span class="line"> * 			利用AspectJAutoProxyRegistrar自定义给容器中注册bean；BeanDefinetion</span><br><span class="line"> * 			internalAutoProxyCreator=AnnotationAwareAspectJAutoProxyCreator</span><br><span class="line"> * </span><br><span class="line"> * 		给容器中注册一个AnnotationAwareAspectJAutoProxyCreator；</span><br><span class="line"> * </span><br><span class="line"> * 2、 AnnotationAwareAspectJAutoProxyCreator：</span><br><span class="line"> * 		AnnotationAwareAspectJAutoProxyCreator</span><br><span class="line"> * 			-&gt;AspectJAwareAdvisorAutoProxyCreator</span><br><span class="line"> * 				-&gt;AbstractAdvisorAutoProxyCreator</span><br><span class="line"> * 					-&gt;AbstractAutoProxyCreator</span><br><span class="line"> * 							implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware</span><br><span class="line"> * 						关注后置处理器（在bean初始化完成前后做事情）、自动装配BeanFactory</span><br><span class="line"> * </span><br><span class="line"> * AbstractAutoProxyCreator.setBeanFactory()</span><br><span class="line"> * AbstractAutoProxyCreator.有后置处理器的逻辑；</span><br><span class="line"> * </span><br><span class="line"> * AbstractAdvisorAutoProxyCreator.setBeanFactory()-》initBeanFactory()</span><br><span class="line"> * </span><br><span class="line"> * AnnotationAwareAspectJAutoProxyCreator.initBeanFactory()</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * 流程：</span><br><span class="line"> * 		1）、传入配置类，创建ioc容器</span><br><span class="line"> * 		2）、注册配置类，调用refresh（）刷新容器；</span><br><span class="line"> * 		3）、registerBeanPostProcessors(beanFactory);注册bean的后置处理器来方便拦截bean的创建；</span><br><span class="line"> * 			1）、先获取ioc容器已经定义了的需要创建对象的所有BeanPostProcessor</span><br><span class="line"> * 			2）、给容器中加别的BeanPostProcessor</span><br><span class="line"> * 			3）、优先注册实现了PriorityOrdered接口的BeanPostProcessor；</span><br><span class="line"> * 			4）、再给容器中注册实现了Ordered接口的BeanPostProcessor；</span><br><span class="line"> * 			5）、注册没实现优先级接口的BeanPostProcessor；</span><br><span class="line"> * 			6）、注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存在容器中；</span><br><span class="line"> * 				创建internalAutoProxyCreator的BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】</span><br><span class="line"> * 				1）、创建Bean的实例</span><br><span class="line"> * 				2）、populateBean；给bean的各种属性赋值</span><br><span class="line"> * 				3）、initializeBean：初始化bean；</span><br><span class="line"> * 						1）、invokeAwareMethods()：处理Aware接口的方法回调</span><br><span class="line"> * 						2）、applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessBeforeInitialization（）</span><br><span class="line"> * 						3）、invokeInitMethods()；执行自定义的初始化方法</span><br><span class="line"> * 						4）、applyBeanPostProcessorsAfterInitialization()；执行后置处理器的postProcessAfterInitialization（）；</span><br><span class="line"> * 				4）、BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；--》aspectJAdvisorsBuilder</span><br><span class="line"> * 			7）、把BeanPostProcessor注册到BeanFactory中；</span><br><span class="line"> * 				beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line"> * =======以上是创建和注册AnnotationAwareAspectJAutoProxyCreator的过程========</span><br><span class="line"> * </span><br><span class="line"> * 			AnnotationAwareAspectJAutoProxyCreator =&gt; InstantiationAwareBeanPostProcessor</span><br><span class="line"> * 		4）、finishBeanFactoryInitialization(beanFactory);完成BeanFactory初始化工作；创建剩下的单实例bean</span><br><span class="line"> * 			1）、遍历获取容器中所有的Bean，依次创建对象getBean(beanName);</span><br><span class="line"> * 				getBean-&gt;doGetBean()-&gt;getSingleton()-&gt;</span><br><span class="line"> * 			2）、创建bean</span><br><span class="line"> * 				【AnnotationAwareAspectJAutoProxyCreator在所有bean创建之前会有一个拦截，InstantiationAwareBeanPostProcessor，会调用postProcessBeforeInstantiation()】</span><br><span class="line"> * 				1）、先从缓存中获取当前bean，如果能获取到，说明bean是之前被创建过的，直接使用，否则再创建；</span><br><span class="line"> * 					只要创建好的Bean都会被缓存起来</span><br><span class="line"> * 				2）、createBean（）;创建bean；</span><br><span class="line"> * 					AnnotationAwareAspectJAutoProxyCreator 会在任何bean创建之前先尝试返回bean的实例</span><br><span class="line"> * 					【BeanPostProcessor是在Bean对象创建完成初始化前后调用的】</span><br><span class="line"> * 					【InstantiationAwareBeanPostProcessor是在创建Bean实例之前先尝试用后置处理器返回对象的】</span><br><span class="line"> * 					1）、resolveBeforeInstantiation(beanName, mbdToUse);解析BeforeInstantiation</span><br><span class="line"> * 						希望后置处理器在此能返回一个代理对象；如果能返回代理对象就使用，如果不能就继续</span><br><span class="line"> * 						1）、后置处理器先尝试返回对象；</span><br><span class="line"> * 							bean = applyBeanPostProcessorsBeforeInstantiation（）：</span><br><span class="line"> * 								拿到所有后置处理器，如果是InstantiationAwareBeanPostProcessor;</span><br><span class="line"> * 								就执行postProcessBeforeInstantiation</span><br><span class="line"> * 							if (bean != null) &#123;</span><br><span class="line">								bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">							&#125;</span><br><span class="line"> * </span><br><span class="line"> * 					2）、doCreateBean(beanName, mbdToUse, args);真正的去创建一个bean实例；和3.6流程一样；</span><br><span class="line"> * 					3）、</span><br><span class="line"> * 			</span><br><span class="line"> * 		</span><br><span class="line"> * AnnotationAwareAspectJAutoProxyCreator【InstantiationAwareBeanPostProcessor】	的作用：</span><br><span class="line"> * 1）、每一个bean创建之前，调用postProcessBeforeInstantiation()；</span><br><span class="line"> * 		关心MathCalculator和LogAspect的创建</span><br><span class="line"> * 		1）、判断当前bean是否在advisedBeans中（保存了所有需要增强bean）</span><br><span class="line"> * 		2）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean，</span><br><span class="line"> * 			或者是否是切面（@Aspect）</span><br><span class="line"> * 		3）、是否需要跳过</span><br><span class="line"> * 			1）、获取候选的增强器（切面里面的通知方法）【List&lt;Advisor&gt; candidateAdvisors】</span><br><span class="line"> * 				每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor；</span><br><span class="line"> * 				判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回true</span><br><span class="line"> * 			2）、永远返回false</span><br><span class="line"> * </span><br><span class="line"> * 2）、创建对象</span><br><span class="line"> * postProcessAfterInitialization；</span><br><span class="line"> * 		return wrapIfNecessary(bean, beanName, cacheKey);//包装如果需要的情况下</span><br><span class="line"> * 		1）、获取当前bean的所有增强器（通知方法）  Object[]  specificInterceptors</span><br><span class="line"> * 			1、找到候选的所有的增强器（找哪些通知方法是需要切入当前bean方法的）</span><br><span class="line"> * 			2、获取到能在bean使用的增强器。</span><br><span class="line"> * 			3、给增强器排序</span><br><span class="line"> * 		2）、保存当前bean在advisedBeans中；</span><br><span class="line"> * 		3）、如果当前bean需要增强，创建当前bean的代理对象；</span><br><span class="line"> * 			1）、获取所有增强器（通知方法）</span><br><span class="line"> * 			2）、保存到proxyFactory</span><br><span class="line"> * 			3）、创建代理对象：Spring自动决定</span><br><span class="line"> * 				JdkDynamicAopProxy(config);jdk动态代理；</span><br><span class="line"> * 				ObjenesisCglibAopProxy(config);cglib的动态代理；</span><br><span class="line"> * 		4）、给容器中返回当前组件使用cglib增强了的代理对象；</span><br><span class="line"> * 		5）、以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程；</span><br><span class="line"> * 		</span><br><span class="line"> * 	</span><br><span class="line"> * 	3）、目标方法执行	；</span><br><span class="line"> * 		容器中保存了组件的代理对象（cglib增强后的对象），这个对象里面保存了详细信息（比如增强器，目标对象，xxx）；</span><br><span class="line"> * 		1）、CglibAopProxy.intercept();拦截目标方法的执行</span><br><span class="line"> * 		2）、根据ProxyFactory对象获取将要执行的目标方法拦截器链；</span><br><span class="line"> * 			List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"> * 			1）、List&lt;Object&gt; interceptorList保存所有拦截器 5</span><br><span class="line"> * 				一个默认的ExposeInvocationInterceptor 和 4个增强器；</span><br><span class="line"> * 			2）、遍历所有的增强器，将其转为Interceptor；</span><br><span class="line"> * 				registry.getInterceptors(advisor);</span><br><span class="line"> * 			3）、将增强器转为List&lt;MethodInterceptor&gt;；</span><br><span class="line"> * 				如果是MethodInterceptor，直接加入到集合中</span><br><span class="line"> * 				如果不是，使用AdvisorAdapter将增强器转为MethodInterceptor；</span><br><span class="line"> * 				转换完成返回MethodInterceptor数组；</span><br><span class="line"> * </span><br><span class="line"> * 		3）、如果没有拦截器链，直接执行目标方法;</span><br><span class="line"> * 			拦截器链（每一个通知方法又被包装为方法拦截器，利用MethodInterceptor机制）</span><br><span class="line"> * 		4）、如果有拦截器链，把需要执行的目标对象，目标方法，</span><br><span class="line"> * 			拦截器链等信息传入创建一个 CglibMethodInvocation 对象，</span><br><span class="line"> * 			并调用 Object retVal =  mi.proceed();</span><br><span class="line"> * 		5）、拦截器链的触发过程;</span><br><span class="line"> * 			1)、如果没有拦截器执行执行目标方法，或者拦截器的索引和拦截器数组-1大小一样（指定到了最后一个拦截器）执行目标方法；</span><br><span class="line"> * 			2)、链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行；</span><br><span class="line"> * 				拦截器链的机制，保证通知方法与目标方法的执行顺序；</span><br><span class="line"> * 		</span><br><span class="line"> * 	总结：</span><br><span class="line"> * 		1）、@EnableAspectJAutoProxy 开启AOP功能</span><br><span class="line"> * 		2）、@EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator</span><br><span class="line"> * 		3）、AnnotationAwareAspectJAutoProxyCreator是一个后置处理器；</span><br><span class="line"> * 		4）、容器的创建流程：</span><br><span class="line"> * 			1）、容器创建的时候有一部refresh，在refresh中有一步registerBeanPostProcessors（）注册后置处理器；</span><br><span class="line">                在这里创建AnnotationAwareAspectJAutoProxyCreator对象</span><br><span class="line"> * 			2）、finishBeanFactoryInitialization（）初始化剩下的单实例bean</span><br><span class="line"> * 				1）、创建业务逻辑组件和切面组件</span><br><span class="line"> * 				2）、关键异步就是AnnotationAwareAspectJAutoProxyCreator后置处理器会来拦截组件的创建过程</span><br><span class="line"> * 				3）、组件创建完之后，判断组件是否需要增强</span><br><span class="line"> * 					是：切面的通知方法，包装成增强器（Advisor）;给业务逻辑组件创建一个代理对象（cglib）；如果是接口也能用jdk动态代理</span><br><span class="line"> * 		5）、执行目标方法：</span><br><span class="line"> * 			1）、代理对象执行目标方法</span><br><span class="line"> * 			2）、如何执行？-&gt;CglibAopProxy.intercept()；</span><br><span class="line"> * 				1）、得到目标方法的拦截器链（增强器包装成拦截器MethodInterceptor） </span><br><span class="line"> * 				2）、利用拦截器的链式机制，依次进入每一个拦截器进行执行；</span><br><span class="line"> * 				3）、效果：</span><br><span class="line"> * 					正常执行：前置通知-》目标方法-》后置通知-》返回通知</span><br><span class="line"> * 					出现异常：前置通知-》目标方法-》后置通知-》异常通知</span><br><span class="line"> * 		</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> */</span><br></pre></td></tr></table></figure>



<h2 id="spring-声明式事务"><a href="#spring-声明式事务" class="headerlink" title="spring 声明式事务"></a>spring 声明式事务</h2><p><strong>基本步骤</strong></p>
<ol>
<li>配置数据源：DataSource</li>
<li>配置事务管理器来控制事务：PlatformTransactionManager</li>
<li>@EnableTransactionManagement开启基于注解的事务管理功能</li>
<li>给方法上面标注@Transactional标识当前方法是一个事务方法</li>
</ol>
<p>  环境搭建：<br>  1、<strong>导入相关依赖</strong>-&gt;数据源、数据库驱动、Spring-jdbc模块<br>  2、<strong>配置数据源</strong>-&gt;JdbcTemplate（Spring提供的简化数据库操作的工具）操作数据<br>  3、给方法上<strong>标注 @Transactional</strong> 表示当前方法是一个事务方法；<br>  4、 @EnableTransactionManagement 开启基于注解的事务管理功能；<br>  5、配置<strong>事务管理器来控制事务</strong>;<br>      @Bean<br>      public <strong>PlatformTransactionManager</strong> transactionManager() { return new —– ;}</p>
<p><strong>声明式事务实现原理</strong></p>
<p>  声明式事务：        </p>
<p>  <strong>原理：</strong><br>  1）、@<strong>EnableTransactionManagement</strong><br>              利用<strong>TransactionManagementConfigurationSelector</strong>给<strong>容器中会导入组件</strong><br>              导入两个组件:<br>              <strong>AutoProxyRegistrar</strong><br>              <strong>ProxyTransactionManagementConfiguration</strong><br>  2）、<strong>AutoProxyRegistrar</strong>：<br>              给容器中注册一个 <strong>InfrastructureAdvisorAutoProxyCreator</strong> 组件；<br>              InfrastructureAdvisorAutoProxyCreator：？<br>              <strong>利用后置处理器机制在对象创建以后，包装对象，返回一个代理对象</strong>（增强器），代理对象执行方法利用<strong>拦截器链进行调用；</strong></p>
<p>  3）、<strong>ProxyTransactionManagementConfiguration</strong> 做了什么？<br>              1、给容器中注册事务增强器；<br>                  1）、事务增强器要用事务注解的信息，AnnotationTransactionAttributeSource<strong>解析事务注解</strong><br>                  2）、事务拦截器：<br>                      TransactionInterceptor；保存了<strong>事务属性信息，事务管理器</strong>；<br>                      他是一个 MethodInterceptor；<br>                      在目标方法执行的时候；<br>                          <strong>执行拦截器链</strong>；<br>                          <strong>事务拦截器</strong>：<br>                              1）、先获取<strong>事务相关的属性</strong><br>                              2）、再获取PlatformTransactionManager，如果<strong>事先没有添加指定任何</strong>transactionmanger,最终会从容器中按照类型获取一个PlatformTransactionManager；<br>                              3）、执行目标方法<br>                                  如果<strong>异常</strong>，获取到事务管理器，利用<strong>事务管理回滚</strong>操作；<br>                                  如果<strong>正常</strong>，利用事务管理器，<strong>提交事务</strong></p>
<h2 id="PostProcessor后置处理器"><a href="#PostProcessor后置处理器" class="headerlink" title="PostProcessor后置处理器"></a>PostProcessor后置处理器</h2><h2 id="Spring-扩展-钩子"><a href="#Spring-扩展-钩子" class="headerlink" title="Spring 扩展(钩子)"></a>Spring 扩展(钩子)</h2><ol>
<li><p><strong>BeanFactoryPostProcessor：<code>beanFactory</code><strong>后置处理器，的拦截时机：所有Bean的定义信息</strong>已经加载到容器，但还没有被实例化</strong>。可以对beanFactory进行一些操作。**<code>一般都是在我们bean初始化前后进行逻辑增强的</code>**</p>
</li>
<li><p><strong>BeanPostProcessor：<code>bean</code><strong>后置处理器，拦截时机：bean创建对象</strong>初始化前后进行拦截工作</strong>。可以对<strong>每一个Bean</strong>进行一些操作。</p>
</li>
<li><p><strong>BeanDefinitionRegistryPostProcessor</strong>：是BeanFactoryPostProcessor的子接口，拦截时机：在BeanFactoryPostProcessor**<code>之后</code><strong>，postProcessBeanDefinitionRegistry方法的执行时机是在所有</strong>bean定义信息将要被加载<strong>，但是bean</strong>实例还未创建**的时候。</p>
<blockquote>
<ol>
<li>创建IOC容器</li>
<li>创建IOC容器时，要调用一个刷新方法，即**<code>refresh</code>**方法</li>
<li>从IOC容器中获取到所有的**<code>BeanDefinitionRegistryPostProcessor</code><strong>组件，并依次触发它们的</strong><code>postProcessBeanDefinitionRegistry</code><strong>方法，然后再来触发它们的</strong><code>postProcessBeanFactory</code>**方法</li>
<li>再来从IOC容器中获取到所有的**<code>BeanFactoryPostProcessor</code><strong>组件，并依次触发它们的</strong><code>postProcessBeanFactory</code>**方法</li>
</ol>
</blockquote>
</li>
<li><p><strong>ApplicationListener</strong>,自定义ApplicationListener实现类并加入到容器中,可以监听spring容器中发布的事件。spring在创建容器的时候（finishRefresh（）方法）会发布ContextRefreshedEvent事件，关闭的时候（doClose()）会发布ContextClosedEvent事件。也可以通过spring容器的publishEvent发布自己的事件。</p>
<ol>
<li><p>事件发布流程：publishEvent方法</p>
<ol>
<li>获取事件的多播器，getApplicationEventMulticaster()。</li>
<li>调用multicastEvent(applicationEvent, eventType)派发事件。获取到所有的ApplicationListener,即getApplicationListeners()，然后同步或者异步的方式执行监听器的onApplicationEvent。</li>
</ol>
</li>
<li><p>事件的多播器的初始化中（initApplicationEventMulticaster（）），如果容器中没有配置applicationEventMulticaster，就使用SimpleApplicationEventMulticaster。然后获取所有的监听器，并把它们注册到SimpleApplicationEventMulticaster中。</p>
</li>
</ol>
</li>
<li><p><strong>@EventListener</strong>(class&#x3D;{})：在普通的业务逻辑的方法上监听事件特定的事件。原理：EventListenerMethodProcessor是一个SmartInitializingSingleton，当所有的单例bean都初始化完以后， 容器会回调该接口的方法afterSingletonsInstantiated(),该方法里会遍历容器中所有的bean，并判断每一个bean里是否带有@EventListener注解的Method，然后创建ApplicationListenerMethodAdapter存储并包装该Method，最后将ApplicationListenerMethodAdapter添加到spring容器中。</p>
</li>
</ol>
<h2 id="Spring源代码分析"><a href="#Spring源代码分析" class="headerlink" title="Spring源代码分析"></a>Spring源代码分析</h2><p>spring核心逻辑<strong>AbstractApplicationContext</strong>的**refresh()**方法如下</p>
<h3 id="refresh"><a href="#refresh" class="headerlink" title="refresh()"></a>refresh()</h3><p><strong><code>BeanFactory的创建以及预准备工作</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 刷新前的预准备工作</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">// 提取bean的配置信息并封装成BeanDefinition实例，然后将其添加到注册中心。注册中心是一个ConcurrentHashMap&lt;String,BeanDefinition&gt;类型，key为Bean的名字，value为BeanDefinition实例。</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line">       <span class="comment">//对beanFactory进行一些配置，注册一些BeanPostProcessor和一些特殊的Bean。</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">//留给子类在BeanFactory准备工作完成后处理一些工作。</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">           <span class="comment">//调用 BeanFactory的后置处理器。</span></span><br><span class="line">           invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">           <span class="comment">//注册Bean的后置处理器。</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">//国际化相关功能</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">//初始化事件派发器；</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">// 提供给子容器类，供子容器去实例化其他的特殊的Bean</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">// 处理容器中已有的ApplicationListener</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">//初始化容器中剩余的单实例bean</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">//最后一步</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh()"></a>prepareRefresh()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 记录启动时间，设置容器的active和close状态。 </span><br><span class="line"><span class="number">2.</span> initPropertySources():提供给子容器类，子容器类可覆盖该方法进行一些自定义的属性设置。</span><br><span class="line"><span class="number">3.</span> getEnvironment().validateRequiredProperties()：检验属性的合法性</span><br><span class="line"><span class="number">4.</span> <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;ApplicationEvent\&gt;() ：保存容器中的一些早期的事件，待事件多播器创建后执行。</span><br></pre></td></tr></table></figure>

<h4 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory()"></a>obtainFreshBeanFactory()</h4><p>提取bean的配置信息并封装成BeanDefinition实例，然后将其添加到注册中心。注册中心是一个ConcurrentHashMap&lt;String,BeanDefinition&gt;类型，key为Bean的名字，value为BeanDefinition实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> refreshBeanFactory：如果当前容器已经有了BeanFactory就销毁原来的BeanFactory。然后创建一个DefaultListableBeanFactory();</span><br><span class="line">    \* 对BeanFactory并进行配置，主要配置是否允许BeanDefinition覆盖，是否允许Bean间的循环引用。</span><br><span class="line">    \* 加载BeanDefinition，解析XML文件和配置文件，将其转换为BeanDefinition，然后保存到DefaultListableBeanFactory的beanDefinitionMap字段中。</span><br><span class="line"><span class="number">2.</span> getBeanFactory() 简单的返回beanFactory，即DefaultListableBeanFactory。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="prepareBeanFactory（）"><a href="#prepareBeanFactory（）" class="headerlink" title="prepareBeanFactory（）"></a>prepareBeanFactory（）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 设置BeanFactory的类加载器、设置支持SPEL表达式的解析器。</span><br><span class="line"><span class="number">2.</span> 添加ApplicationContextAwareProcessor用于处理XXXAware接口的回调。 </span><br><span class="line"><span class="number">3.</span> 设置忽略一些接口。并注册一些类，这些类可以在bean里直接进行自动装配。</span><br><span class="line"><span class="number">4.</span> 添加ApplicationListenerDetector用于识别并保存ApplicationListener的子类。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="postProcessBeanFactory（）："><a href="#postProcessBeanFactory（）：" class="headerlink" title="postProcessBeanFactory（）："></a>postProcessBeanFactory（）：</h4><p>提供给子容器类，子容器类可以覆盖该方法在BeanFactory准备工作完成后处理一些工作。</p>
<h4 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors()"></a>invokeBeanFactoryPostProcessors()</h4><blockquote>
<p>执行了<strong>BeanDefinitionRegistryPostProcessor</strong>的<strong>postProcessBeanDefinitionRegistry</strong>和<strong>postProcessBeanFactory</strong>这俩方法，以及<strong>BeanFactoryPostProcessors</strong>的<strong>postProcessBeanFactory</strong>方法</p>
<p><strong>BeanDefinitionRegistryPostProcessor是要优先于BeanFactoryPostProcessor执行的</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">\* BeanFactoryPostProcessor是beanFactory后置处理器，在整个BeanFactory标准初始化完成后进行拦截调用， </span><br><span class="line">\* BeanDefinitionRegistryPostProcessor继承了BeanFactoryPostProcessor，在beanFactory解析完所有的BeanDefinition后拦截调用。</span><br><span class="line">\* BeanFactoryPostProcessor来源</span><br><span class="line">    \* 通过ApplicationContent的addBeanFactoryPostProcessor()方法手动添加自己的拦截器</span><br><span class="line">    \* 系统默认了一些BeanFactoryPostProcessor。例如：ConfigurationClassPostProcessor用来处理<span class="meta">@Configuration</span>标注的Spring配置类。</span><br><span class="line">\* 调用顺序 </span><br><span class="line">    <span class="number">1.</span> 先调用BeanDefinitionRegistryPostProcessor类型的拦截器，</span><br><span class="line">    <span class="number">2.</span> 然后再依次调用实现了PriorityOrdered,Ordered接口的BeanFactoryPostProcessor</span><br><span class="line">    <span class="number">3.</span> 最后调用普通的BeanFactoryPostProcessor</span><br></pre></td></tr></table></figure>

<h4 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors()"></a>registerBeanPostProcessors()</h4><p>注册Bean的后置处理器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 从beanFactory里获取所有BeanPostProcessor类型的Bean的名称。</span><br><span class="line"><span class="number">2.</span> 调用beanFactory的getBean方法并传入每一个BeanPostProcesso类型的Bean名称，从容器中获取该Bean的实例。</span><br><span class="line"><span class="number">3.</span> </span><br><span class="line">    <span class="number">1.</span> 第一步向beanFactory注册实现了PriorityOrdered的BeanPostProcessor类型的Bean实例。</span><br><span class="line">    <span class="number">2.</span> 第二步向beanFactory注册实现了Ordered的BeanPostProcessor类型的Bean实例。</span><br><span class="line">    <span class="number">3.</span> 第三步向beanFactory注册普通的BeanPostProcessor类型的Bean实例。</span><br><span class="line">    <span class="number">4.</span> 最后一步向beanFactory重新注册实现了MergedBeanDefinitionPostProcessor的BeanPostProcessor类型的Bean实例</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 向beanFactory注册BeanPostProcessor的过程就是简单的将实例保存到beanFactory的beanPostProcessors属性中。</span><br></pre></td></tr></table></figure>

<h4 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource()"></a>initMessageSource()</h4><p>国际化相关功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 看容器中是否有id为messageSource的，类型是MessageSource的Bean实例。如果有赋值给messageSource，如果没有自己创建一个DelegatingMessageSource。</span><br><span class="line"><span class="number">2.</span> 把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource。</span><br></pre></td></tr></table></figure>

<h4 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster()"></a>initApplicationEventMulticaster()</h4><p>初始化事件派发器；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 看容中是否有名称为applicationEventMulticaster的，类型是ApplicationEventMulticaster的Bean实例。如果没有就创建一个SimpleApplicationEventMulticaster。</span><br><span class="line"><span class="number">2.</span> 把创建好的ApplicationEventMulticaster添加到BeanFactory中。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="onRefresh-："><a href="#onRefresh-：" class="headerlink" title="onRefresh()："></a>onRefresh()：</h4><p>提供给子容器类，供子容器去实例化其他的特殊的Bean。</p>
<h4 id="registerListeners-："><a href="#registerListeners-：" class="headerlink" title="registerListeners()："></a>registerListeners()：</h4><p>处理容器中已有的ApplicationListener。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 从容器中获得所有的ApplicationListener</span><br><span class="line"><span class="number">2.</span> 将每个监听器添加到事件派发器（ApplicationEventMulticaster）中；</span><br><span class="line"><span class="number">3.</span> 处理之前步骤产生的事件；</span><br></pre></td></tr></table></figure>

<h4 id="finishBeanFactoryInitialization-："><a href="#finishBeanFactoryInitialization-：" class="headerlink" title="finishBeanFactoryInitialization()："></a>finishBeanFactoryInitialization()：</h4><p><strong>初始化容器中剩余的单实例bean</strong>：拿到剩余的所有的BeanDefinition，依次调用getBean方法（详看beanFactory.getBean的执行流程）</p>
<p>没有实现<strong>FactoryBean</strong>接口，那么就会利用**getBean()**方法来创建对象</p>
<p>实现了：Spring就会调用<strong>FactoryBean</strong>接口里面的**getObject()**方法来帮我们创建对象</p>
<blockquote>
<p><strong>get Bean()</strong></p>
<p>先尝试从缓存中获取我们单实例bean-&gt;getSingleton()</p>
<p>-&gt;从一个<strong>Map</strong>集合</p>
<p>如果没有-&gt;首先会来获取一个（父）BeanFactory-&gt;createBean()</p>
<p>-&gt;会先拿到我们bean的定义信息，然后再来解析我们要创建的bean的类型-&gt;创建我们bean的对象之前，会调用了一个<strong>resolveBeforeInstantiation</strong>方法。方法上说是给<strong>BeanPostProcessor</strong>一个机会来<strong>提前返回我们bean的代理对象</strong>，这主要是为了解决<strong>依赖注入问题</strong>。也就是说，这是让<strong>BeanPostProcessor</strong>先<strong>拦截并返回代理对象</strong></p>
<p>-&gt;但是，此刻是没有返回我们单实例bean的代理对象的</p>
<p>-&gt;doCreateBean-&gt;createBeanInstance创建实例**<code>创建bean的流程的第一步就是先来创建bean实例</code>**</p>
<p>-&gt;getFactoryMethodName获取工厂方法的名字-&gt;调用了类的构造器创建出了对象**<code>只不过该Blue对象刚刚创建出来，空空如也，什么都没有</code>**</p>
<p>-&gt;<strong>遍历一大堆后置处理器</strong>-&gt;<strong>populateBean-&gt;getPropertyValues为属性赋值-&gt;postProcessPropertyValues给属性真正赋值</strong></p>
<blockquote>
<p><strong>赋值</strong>-&gt;利用<strong>setter</strong>方法为bean的属性进行<strong>赋值</strong>-&gt;利用<strong>反射</strong>调setter方法</p>
</blockquote>
<p>-&gt;initializeBean<strong>初始化Bean</strong>-&gt;初始化完成后加入到缓存中</p>
<p>-&gt;注册bean的销毁方法</p>
</blockquote>
<h4 id="finishRefresh-："><a href="#finishRefresh-：" class="headerlink" title="finishRefresh()："></a>finishRefresh()：</h4><p>最后一步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 初始化和生命周期有关的后置处理器；LifecycleProcessor，如果容器中没有指定处理就创建一个DefaultLifecycleProcessor加入到容器。</span><br><span class="line"><span class="number">2.</span> 获取容器中所有的LifecycleProcessor回调onRefresh()方法。</span><br><span class="line"><span class="number">3.</span> 发布容器刷新完成事件ContextRefreshedEvent。</span><br></pre></td></tr></table></figure>



<p><strong><code>BeanFactory的创建以及预准备工作就已经完成啦</code></strong></p>
<hr>
<h3 id="ConfigurationClassPostProcessor处理-Configuration的过程："><a href="#ConfigurationClassPostProcessor处理-Configuration的过程：" class="headerlink" title="ConfigurationClassPostProcessor处理@Configuration的过程："></a>ConfigurationClassPostProcessor处理@Configuration的过程：</h3><ol>
<li><p>先从主从中心取出所有的BeanDefinition。依次判断，若一个BeanDefinition是被@Configuration标注的，spring将其标记为FullMode，否则若一个BeanDefinition没有被@Configuration标注，但有被@Bean标注的方法，spring将其标记为LightMode。筛选出所有候选配置BeanDefinition（FullMode和LightMode）</p>
</li>
<li><p>创建一个ConfigurationClassParser，调用parse方法解析每一个配置类。</p>
<ol>
<li>解析@PropertySources,将解析结果设置到Environment</li>
<li>利用ComponentScanAnnotationParser，将@ComponentScans标签解析成BeanDefinitionHolder。再迭代解析BeanDefinitionHolder</li>
<li>解析@Import，@ImportResource</li>
<li>将@Bean解析为MethodMetadata，将结果保存到ConfigurationClass中。最终ConfigurationClass会被保存到ConfigurationClassParser的configurationClasses中。</li>
</ol>
</li>
<li><p>调用ConfigurationClassParser的loadBeanDefinitions方法，加载解析结果到注册中。</p>
<ol>
<li>从利用ComponentScanAnnotationParser的configurationClasses获取所有的ConfigurationClass，依次调用loadBeanDefinitionsForConfigurationClass方法。</li>
<li>loadBeanDefinitionsForConfigurationClass会将每一个BeanMethod转为ConfigurationClassBeanDefinition，最后将其添加到spring的注册中心。</li>
</ol>
</li>
</ol>
<h3 id="beanFactory-getBean方法执行的过程"><a href="#beanFactory-getBean方法执行的过程" class="headerlink" title="beanFactory.getBean方法执行的过程"></a>beanFactory.getBean方法执行的过程</h3><ol>
<li><p>首先将方法传入的beanName进行转换：先去除FactoryBean前缀（&amp;符）如果传递的beanName是别名，则通过别名找到bean的原始名称。</p>
</li>
<li><p>根据名称先从singletonObjects（一个Map类型的容）获取bean实例。如果能获取到就先判断该bean实例是否实现了FactoryBean，如果是FactoryBean类型的bean实例，就通过FactoryBean获取Bean。然后直接返回该bean实例。getBean方法结束。</p>
</li>
<li><p>如果从singletonObjects没有获取到bean实例就开始创建Bean的过程。</p>
<ol>
<li><p>首先标记该Bean处于创建状态。</p>
</li>
<li><p>根据Bean的名称找到BeanDefinition。查看该Bean是否有前置依赖的Bean。若有则先创建该Bean前置依赖的Bean。</p>
</li>
<li><p>spring调用AbstractAutowireCapableBeanFactory的createBean方法并传入BeanDefinition开始创建对象。先调用resolveBeforeInstantiation给BeanPostProcessor一个机会去返回一个代理对象去替代目标Bean的实例。</p>
</li>
<li><p>如果BeanPostProcessor没有返回Bean的代理就通过doCreateBean方法创建对象。</p>
<ol>
<li>首先确定Bean的构造函数，如果有有参构造器，先自动装配有参构造器，默认使用无参数构造器。</li>
<li>选择一个实例化策略去实例化bean。默认使用CglibSubclassingInstantiationStrategy。该策略模式中,首先判断bean是否有方法被覆盖,如果没有则直接通过反射的方式来创建,如果有的话则通过CGLIB来实例化bean对象. 把创建好的bean对象包裹在BeanWrapper里。</li>
<li>调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition</li>
<li>判断容器是否允许循环依赖，如果允许循环依赖，就创建一个ObjectFactory类并实现ObjectFactory接口的唯一的一个方法getObject（）用于返回Bean。然后将该ObjectFactory添加到singletonFactories中。</li>
<li>调用populateBean为bean实例赋值。在赋值之前执行InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation和postProcessPropertyValues方法。</li>
<li>调用initializeBean初始化bean。如果Bean实现了XXXAware，就先处理对应的Aware方法。然后调用beanProcessor的postProcessBeforeInitialization方法。再以反射的方式调用指定的bean指定的init方法。最后调用beanProcessor的postProcessAfterInitialization方法。</li>
<li>调用registerDisposableBeanIfNecessary，将该bean保存在一个以beanName为key，以包装了bean引用的DisposableBeanAdapter，为value的map中，在spring容器关闭时，遍历这个map来获取需要调用bean来依次调用Bean的destroyMethod指定的方法。</li>
</ol>
</li>
<li><p>将新创建出来的Bean保存到singletonObjects中</p>
</li>
</ol>
</li>
</ol>
<h2 id="AutoWired"><a href="#AutoWired" class="headerlink" title="@AutoWired"></a>@AutoWired</h2><p>自动装配</p>
<pre><code> Spring利用依赖注入（DI），完成对IOC容器中中各个组件的依赖关系赋值；*
</code></pre>
<p>  1）、@Autowired：自动注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）、默认优先按照类型去容器中找对应的组件:applicationContext.getBean(BookDao.class);找到就赋值*</span><br><span class="line"><span class="number">2</span>）、如果找到多个相同类型的组件，再将属性的名称作为组件的id去容器中查找</span><br><span class="line">          applicationContext.getBean(<span class="string">&quot;bookDao&quot;</span>)</span><br><span class="line"><span class="number">3</span>）、<span class="meta">@Qualifier(&quot;bookDao&quot;)</span>：使用<span class="meta">@Qualifier</span>指定需要装配的组件的id，而不是使用属性名</span><br><span class="line"><span class="number">4</span>）、自动装配默认一定要将属性赋值好，没有就会报错；</span><br><span class="line">  可以使用<span class="meta">@Autowired(required=false)</span>;</span><br><span class="line"><span class="number">5</span>）、<span class="meta">@Primary</span>：让Spring进行自动装配的时候，默认使用首选的bean；</span><br><span class="line">    也可以继续使用<span class="meta">@Qualifier</span>指定需要装配的bean的名字</span><br><span class="line">    </span><br><span class="line">BookService&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  BookDao  bookDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  2）、Spring还支持使用@Resource(JSR250)和@Inject(JSR330)[java规范的注解]*</p>
<pre><code> @Resource:
   可以和@Autowired一样实现自动装配功能；默认是按照组件名称进行装配的；
   没有能支持@Primary功能没有支持@Autowired（reqiured=false）;
 @Inject:
   需要导入javax.inject的包，和Autowired的功能一样。没有required=false的功能；
</code></pre>
<p>   <strong>@Autowired</strong>:<strong>Spring</strong>定义的； <strong>@Resource</strong>、**@Inject<strong>都是</strong>java**规范</p>
<p>  <strong>AutowiredAnnotationBeanPostProcessor</strong>:<strong>解析完成自动装配功能</strong>；   </p>
<p>  3）、 <strong>@Autowired</strong>:构造器，<strong>参数</strong>，方法，<strong>属性</strong>；都是<strong>从容器中获取参数组件的值</strong></p>
<pre><code> 1）、[标注在方法位置]：@Bean+方法参数；参数从容器中获取;默认不写@Autowired效果是一样的；都能自动装配*
 2）、[标在构造器上]：如果组件只有一个有参构造器，这个有参构造器的@Autowired可以省略，参数位置的组件还是可以自动从容器中获取
 3）、放在参数位置：
</code></pre>
<p>  4）、自定义组件想要使用Spring容器底层的一些组件（ApplicationContext，BeanFactory，xxx）；</p>
<pre><code> 自定义组件实现xxxAware；在创建对象的时候，会调用接口规定的方法注入相关组件；Aware；*
 把Spring底层一些组件注入到自定义的Bean中；*
 xxxAware：功能使用xxxProcessor；*
   ApplicationContextAware==》ApplicationContextAwareProcessor；*
</code></pre>
<h2 id="spring原理补充"><a href="#spring原理补充" class="headerlink" title="spring原理补充"></a>spring原理补充</h2><h3 id="spring解决循环依赖"><a href="#spring解决循环依赖" class="headerlink" title="spring解决循环依赖"></a>spring解决循环依赖</h3><p><strong>以类A，B互相依赖注入为例</strong></p>
<ol>
<li><p>根据类A的名称先从singletonObjects获取Bean实例，发现获取不到，就通过doGetBean方法开始创建Bean的流程。</p>
</li>
<li><p>根据A的名称找到对应的BeanDefinition，通过doCreateBean（）方法创建对象，先确定类A的构造函数，然后选择一个实例化策略去实例化类A。</p>
</li>
<li><p>判断容器是否允许循环依赖，如果允许循环依赖，就创建一个ObjectFactory类并实现ObjectFactory接口的唯一的一个方法getObject（）用于返回类A。然后将该ObjectFactory添加到singletonFactories中。</p>
</li>
<li><p>调用populateBean（）为类A进行属性赋值，发现需要依赖类B，此时类B尚未创建，启动创建类B的流程。</p>
<ol>
<li>根据类B的名称先从singletonObjects获取Bean实例，发现获取不到，就开始通过doGetBean方法开始创建Bean的流程</li>
<li>找到类B对应的BeanDefinition，确认B的构造函数，然后实例化B。</li>
<li>判断容器是否允许循环依赖，创建一个ObjectFactory并实现getObject（）方法，用于返回类B，并添加到singletonFactories中。</li>
<li>调用populateBean（）为类B进行属性赋值，发现需要依赖类A，调用getSingleton方法获取A：A现在已存在于singletonFactories中，getSingleton将A从singletonFactories方法中移除并放入earlySingletonObjects中。</li>
<li>调用getSingleton（）方法获取B：getSingleton将A从singletonFactories方法中移除并放入earlySingletonObjects中。</li>
<li>调用initializeBean初始化bean，最后将新创建出来的类B保存到singletonObjects中</li>
</ol>
</li>
<li><p>调用getSingleton（）方法获取A，这时A已在earlySingletonObjects中了，就直接返回A</p>
</li>
<li><p>调用initializeBean初始化bean，最后将新创建出来的类B保存到singletonObjects中。</p>
</li>
</ol>
<blockquote>
<p>spring进行扫描-&gt;反射后封装成beanDefinition对象-&gt;放入beanDefinitionMap-&gt;遍历map-&gt;验证（是否单例、是否延迟加载、是否抽象）-&gt;推断构造方法-&gt;**<code>BEGIN</code>**准备开始进行实例-&gt;去单例池中查，没有-&gt;去二级缓存中找，没有提前暴露-&gt;生成一个objectFactory对象暴露到二级缓存中-&gt;属性注入，发现依赖Y-&gt;此时Y开始它的生命周期直到属性注入，发现依赖X-&gt;X又走一遍生命周期，当走到去二级缓存中找的时候找到了已经暴露好的ObjectFactory所产生的x对象那个-&gt;往Y中注入X的objectFactory对象-&gt;完成循环依赖。<br><strong>1、为什么要使用X的objectFacory对象而不是直接使用X对象？</strong><br>利于拓展，程序员可以通过beanPostProcess接口操作objectFactory对象生成自己想要的对象<br><strong>2、是不是只能支持单例(scope&#x3D;singleton)而不支持原型(scope&#x3D;prototype)？</strong><br>是。因为单例是spring在启动时进行bean加载放入单例池中，在依赖的bean开始生命周期后，可以直接从二级缓存中取到它所依赖的bean的objectFactory对象从而结束循环依赖。而原型只有在用到时才会走生命周期流程，但是原型不存在一个已经实例化好的bean，所以会无限的创建-&gt;依赖-&gt;创建-&gt;依赖-&gt;…。<br><strong>3、循环依赖是不是只支持非构造方法？</strong><br>是。如果是通过特殊构造方法，构造方法不能创建对象，实例化x要y，实例化y要x，类似死锁问题</p>
</blockquote>
<h3 id="Autowire-实现原理"><a href="#Autowire-实现原理" class="headerlink" title="@Autowire 实现原理"></a>@Autowire 实现原理</h3><p>上面介绍<strong>beanFactory.getBean方法执行的过程</strong>中提到：<strong>populateBean</strong>为<strong>bean</strong>实例赋值。在赋值之前执行<strong>InstantiationAwareBeanPostProcessor</strong>的<strong>postProcessAfterInstantiation</strong>和<strong>postProcessPropertyValues</strong>方法。**@Autowire<strong>由</strong>AutowiredAnnotationBeanPostProcessor<strong>完成，它实现了</strong>InstantiationAwareBeanPostProcessor**。<br><strong>AutowiredAnnotationBeanPostProcessor</strong>执行过程：</p>
<ol>
<li><strong>postProcessAfterInstantiation</strong>方法执行，直接return null。</li>
<li><strong>postProcessPropertyValues</strong>方法执行，主要逻辑在此处理。待补充。。。。。</li>
</ol>
<p>间接实现InstantiationAwareBeanPostProcessor，<strong>就具备了实例化前后</strong>(而不是初始化前后)<strong>管理对象的能力</strong>，实现了<strong>BeanPostProcessor</strong>，具有初<strong>始化前后管理对象的能力</strong>，实现<strong>BeanFactoryAware</strong>，具备随时拿到<strong>BeanFactory</strong>的能力，也就是说，这个<strong>AutowiredAnnotationBeanPostProcessor具备一切后置处理器的能力</strong>。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>count()</title>
    <url>/2021/05/17/count()/</url>
    <content><![CDATA[<h1 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h1><ul>
<li><strong><mark>MyISAM</mark></strong> 引擎把一个<strong>表的总行数存在了磁盘上</strong>，因此执行 count(<em>) 的时候会直接返回这个数，效率很高；</em></li>
<li>而 <strong><mark>InnoDB</mark></strong> 引擎就麻烦了，它执行 count(*) 的时候，需要把<strong>数据一行一行地从引擎里面读出来，然后累积计数</strong>。<ul>
<li><strong>遍历哪个索引树得到的结果逻辑上都是一样的</strong>。因此，<strong>MySQL 优化器会找到最小的那棵树来遍历</strong>。在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</li>
</ul>
</li>
</ul>
<ol>
<li><strong>count()</strong> 是一个聚合函数，对于返回的结果集，<strong>一行行地判断</strong>，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。</li>
<li><strong>count(字段）</strong>，则表示返回满足条件的数据行里面，<strong>参数“字段”不为 NULL 的总个数</strong></li>
<li><strong>count(主键 id)</strong> 来说，<strong>InnoDB 引擎会遍历整张表</strong>，<strong>把每一行的 id 值都取出来</strong>，返回给 server 层。<strong>server 层拿到 id 后，判断是不可能为空的，就按行累加。</strong></li>
<li><strong>count(1)</strong> 来说，<strong>InnoDB 引擎遍历整张表，但不取值</strong>。server 层对于*<em>返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</em></li>
<li><strong>count(*)</strong> 并不会把全部字段取出来，<strong>而是专门做了优化，不会把全部字段取出来</strong>。count(*) 肯定不是 null，按行累加。</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Vue 3</title>
    <url>/2020/06/16/Vue3/</url>
    <content><![CDATA[<h1 id="Vue3快速上手"><a href="#Vue3快速上手" class="headerlink" title="Vue3快速上手"></a>Vue3快速上手</h1><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" />

<h2 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1.Vue3简介"></a>1.Vue3简介</h2><ul>
<li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li>
<li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a> </li>
<li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li>
</ul>
<h2 id="2-Vue3带来了什么"><a href="#2-Vue3带来了什么" class="headerlink" title="2.Vue3带来了什么"></a>2.Vue3带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul>
<li><p>打包大小减少41%</p>
</li>
<li><p>初次渲染快55%, 更新渲染快133%</p>
</li>
<li><p>内存减少54%</p>
<p>……</p>
</li>
</ul>
<h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul>
<li><p>使用Proxy代替defineProperty实现响应式</p>
</li>
<li><p>重写虚拟DOM的实现和Tree-Shaking</p>
<p>……</p>
</li>
</ul>
<h3 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h3><ul>
<li>Vue3可以更好的支持TypeScript</li>
</ul>
<h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol>
<li><p>Composition API（组合API）</p>
<ul>
<li>setup配置</li>
<li>ref与reactive</li>
<li>watch与watchEffect</li>
<li>provide与inject</li>
<li>……</li>
</ul>
</li>
<li><p>新的内置组件</p>
<ul>
<li>Fragment </li>
<li>Teleport</li>
<li>Suspense</li>
</ul>
</li>
<li><p>其他改变</p>
<ul>
<li>新的生命周期钩子</li>
<li>data 选项应始终被声明为一个函数</li>
<li>移除keyCode支持作为 v-on 的修饰符</li>
<li>……</li>
</ul>
</li>
</ol>
<h1 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h2><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class="line">vue --version</span><br><span class="line"><span class="comment">## 安装或者升级你的@vue/cli</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment">## 创建</span></span><br><span class="line">vue create vue_test</span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h2><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p>
<p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p>
<ul>
<li>什么是vite？—— 新一代前端构建工具。</li>
<li>优势如下：<ul>
<li>开发环境中，无需打包操作，可快速的冷启动。</li>
<li>轻量快速的热重载（HMR）。</li>
<li>真正的按需编译，不再等待整个应用编译完成。</li>
</ul>
</li>
<li>传统构建 与 vite构建对比图</li>
</ul>
<p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left" /><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 创建工程</span></span><br><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 进入工程目录</span></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">## 运行</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<h1 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h1><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p>
<h2 id="1-setup"><a href="#1-setup" class="headerlink" title="1.setup"></a>1.setup</h2><ol>
<li>理解：Vue3.0中一个新的配置项，值为一个函数。</li>
<li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li>
<li>组件中所用到的：数据、方法等等，均要配置在setup中。</li>
<li>setup函数的两种返回值：<ol>
<li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li>
<li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li>
</ol>
</li>
<li>注意点：<ol>
<li>尽量不要与Vue2.x配置混用<ul>
<li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li>
<li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li>
<li>如果有重名, setup优先。</li>
</ul>
</li>
<li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>
</ol>
</li>
</ol>
<h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h2><ul>
<li>作用: 定义一个响应式的数据</li>
<li>语法: <code>const xxx = ref(initValue)</code> <ul>
<li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li>
<li>JS中操作数据： <code>xxx.value</code></li>
<li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li>
</ul>
</li>
<li>备注：<ul>
<li>接收的数据可以是：基本类型、也可以是对象类型。</li>
<li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li>
<li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li>
</ul>
</li>
</ul>
<h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul>
<li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li>
<li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li>
<li>reactive定义的响应式数据是“深层次的”。</li>
<li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li>
</ul>
<h2 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul>
<li><p>实现原理：</p>
<ul>
<li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
</li>
<li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">    get () &#123;&#125;, </span><br><span class="line">    set () &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>存在问题：</p>
<ul>
<li>新增属性、删除属性, 界面不会更新。</li>
<li>直接通过下标修改数组, 界面不会自动更新。</li>
</ul>
</li>
</ul>
<h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul>
<li>实现原理: <ul>
<li>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</li>
<li>通过Reflect（反射）:  对源对象的属性进行操作。</li>
<li>MDN文档中描述的Proxy与Reflect：<ul>
<li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
</li>
<li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">	<span class="comment">// 拦截读取属性值</span></span><br><span class="line">    get (target, prop) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">    set (target, prop, value) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截删除属性</span></span><br><span class="line">    deleteProperty (target, prop) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span>   </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul>
<li>从定义数据角度对比：<ul>
<li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li>
<li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li>
<li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li>
</ul>
</li>
<li>从原理角度对比：<ul>
<li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li>
<li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li>
</ul>
</li>
<li>从使用角度对比：<ul>
<li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li>
<li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li>
</ul>
</li>
</ul>
<h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul>
<li><p>setup执行的时机</p>
<ul>
<li>在beforeCreate之前执行一次，this是undefined。</li>
</ul>
</li>
<li><p>setup的参数</p>
<ul>
<li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li>
<li>context：上下文对象<ul>
<li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li>
<li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li>
<li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul>
<li><p>与Vue2.x中computed配置功能一致</p>
</li>
<li><p>写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">//计算属性——简写</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//计算属性——完整</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> nameArr = value.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            person.<span class="property">firstName</span> = nameArr[<span class="number">0</span>]</span><br><span class="line">            person.<span class="property">lastName</span> = nameArr[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul>
<li><p>与Vue2.x中watch配置功能一致</p>
</li>
<li><p>两个小“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况一：监视ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>(sum,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：监视多个ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>([sum,msg],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情况三：监视reactive定义的响应式数据</span></span><br><span class="line"><span class="comment">			若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span></span><br><span class="line"><span class="comment">			若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">watch</span>(person,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">false</span>&#125;) <span class="comment">//此处的deep配置不再奏效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况四：监视reactive定义的响应式数据中的某个属性</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">//情况五：监视reactive定义的响应式数据中的某些属性</span></span><br><span class="line"><span class="title function_">watch</span>([<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">()=&gt;</span>person.<span class="property">name</span>],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;) <span class="comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul>
<li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p>
</li>
<li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p>
</li>
<li><p>watchEffect有点像computed：</p>
<ul>
<li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li>
<li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x1 = sum.<span class="property">value</span></span><br><span class="line">    <span class="keyword">const</span> x2 = person.<span class="property">age</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;watchEffect配置的回调执行了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><div style="border:1px solid black;width:380px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="https://cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px" /></div><div style="border:1px solid black;width:510px;height:985px;float:left"><strong>vue3.0的生命周期</strong><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="lifecycle_2" style="zoom:33%;width:2500px" /></div>





































<p>1</p>
<ul>
<li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul>
<li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li>
<li><code>destroyed</code>改名为 <code>unmounted</code></li>
</ul>
</li>
<li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul>
<li><code>beforeCreate</code>&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li>
<li><code>created</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li>
<li><code>beforeMount</code> &#x3D;&#x3D;&#x3D;&gt;<code>onBeforeMount</code></li>
<li><code>mounted</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onMounted</code></li>
<li><code>beforeUpdate</code>&#x3D;&#x3D;&#x3D;&gt;<code>onBeforeUpdate</code></li>
<li><code>updated</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUpdated</code></li>
<li><code>beforeUnmount</code> &#x3D;&#x3D;&gt;<code>onBeforeUnmount</code></li>
<li><code>unmounted</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUnmounted</code></li>
</ul>
</li>
</ul>
<h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul>
<li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p>
</li>
<li><p>类似于vue2.x中的mixin。</p>
</li>
<li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p>
</li>
</ul>
<h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul>
<li><p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p>
</li>
<li><p>语法：<code>const name = toRef(person,&#39;name&#39;)</code></p>
</li>
<li><p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p>
</li>
<li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p>
</li>
</ul>
<h1 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul>
<li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p>
</li>
<li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>
</li>
<li><p>什么时候使用?</p>
<ul>
<li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。</li>
<li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。</li>
</ul>
</li>
</ul>
<h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul>
<li>readonly: 让一个响应式数据变为只读的（深只读）。</li>
<li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li>
<li>应用场景: 不希望数据被修改时。</li>
</ul>
<h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul>
<li>toRaw：<ul>
<li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li>markRaw：<ul>
<li>作用：标记一个对象，使其永远不会再成为响应式对象。</li>
<li>应用场景:<ol>
<li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li>
<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul>
<li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p>
</li>
<li><p>实现防抖效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;</span><br><span class="line">	&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	import &#123;ref,customRef&#125; from &#x27;vue&#x27;</span><br><span class="line">	export default &#123;</span><br><span class="line">		name:&#x27;Demo&#x27;,</span><br><span class="line">		setup()&#123;</span><br><span class="line">			// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref</span><br><span class="line">			//自定义一个myRef</span><br><span class="line">			function myRef(value,delay)&#123;</span><br><span class="line">				let timer</span><br><span class="line">				//通过customRef去实现自定义</span><br><span class="line">				return customRef((track,trigger)=&gt;&#123;</span><br><span class="line">					return&#123;</span><br><span class="line">						get()&#123;</span><br><span class="line">							track() //告诉Vue这个value值是需要被“追踪”的</span><br><span class="line">							return value</span><br><span class="line">						&#125;,</span><br><span class="line">						set(newValue)&#123;</span><br><span class="line">							clearTimeout(timer)</span><br><span class="line">							timer = setTimeout(()=&gt;&#123;</span><br><span class="line">								value = newValue</span><br><span class="line">								trigger() //告诉Vue去更新界面</span><br><span class="line">							&#125;,delay)</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref</span><br><span class="line">			return &#123;</span><br><span class="line">				keyword</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" />

<ul>
<li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p>
</li>
<li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>
</li>
<li><p>具体写法：</p>
<ol>
<li><p>祖组件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;)</span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;car&#x27;</span>,car)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后代组件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params">props,context</span>)&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">const</span> car = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;car&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul>
<li>isRef: 检查一个值是否为一个 ref 对象</li>
<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>
<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>
<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>
</ul>
<h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p>
<div style="width:600px;height:370px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" />
</div>
<div style="width:300px;height:370px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> 
</div>















<h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p>
<div style="width:500px;height:340px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
</div>
<div style="width:430px;height:340px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
</div>













<h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul>
<li>在Vue2中: 组件必须有一个根标签</li>
<li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li>
<li>好处: 减少标签层级, 减小内存占用</li>
</ul>
<h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul>
<li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;teleport to=&quot;移动位置&quot;&gt;</span><br><span class="line">	&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;</span><br><span class="line">		&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">			&lt;h3&gt;我是一个弹窗&lt;/h3&gt;</span><br><span class="line">			&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul>
<li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
</li>
<li><p>使用步骤：</p>
<ul>
<li><p>异步引入组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineAsyncComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&#x27;./components/Child.vue&#x27;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">		&lt;h3&gt;我是App组件&lt;/h3&gt;</span><br><span class="line">		&lt;Suspense&gt;</span><br><span class="line">			&lt;template v-slot:default&gt;</span><br><span class="line">				&lt;Child/&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">			&lt;template v-slot:fallback&gt;</span><br><span class="line">				&lt;h3&gt;加载中.....&lt;/h3&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Suspense&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul>
<li><p>Vue 2.x 有许多全局 API 和配置。</p>
<ul>
<li><p>例如：注册全局组件、注册全局指令等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册全局组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyButton&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册全局指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inserted</span>: <span class="function"><span class="params">el</span> =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Vue3.0中对这些API做出了调整：</p>
<ul>
<li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p>
<table>
<thead>
<tr>
<th>2.x 全局 API（<code>Vue</code>）</th>
<th>3.x 实例 API (<code>app</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config.xxxx</td>
<td>app.config.xxxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td><strong style="color:#DD5145">移除</strong></td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul>
<li><p>data选项应始终被声明为一个函数。</p>
</li>
<li><p>过度类名的更改：</p>
<ul>
<li><p>Vue2.x写法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.v-enter</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vue3.x写法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.v-enter-from</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.v-leave-from</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p>
</li>
<li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p>
<ul>
<li><p>父组件中绑定事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close=&quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click=&quot;handleNativeClickEvent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子组件中声明自定义事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    emits: [&#x27;close&#x27;]</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p>
<blockquote>
<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>
</blockquote>
</li>
<li><p>……</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Axios</title>
    <url>/2020/06/16/first%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="AIXOS"><a href="#AIXOS" class="headerlink" title="AIXOS"></a>AIXOS</h1><p>method-&gt;请求类型</p>
<p>url-&gt;URL请求地址</p>
<p>data-&gt;post请求 设置请求体</p>
<p>timeout-&gt;超时</p>
<p>params-&gt;添加到url请求字符串-&gt;get请求 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为params是添加到url的请求字符串中的，用于get请求。 </span><br><span class="line"></span><br><span class="line">而data是添加到请求体（body）中的， 用于post请求。</span><br></pre></td></tr></table></figure>

<h2 id="axios配置"><a href="#axios配置" class="headerlink" title="axios配置"></a>axios配置</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>axios配置<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(axios);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="axios基本使用"><a href="#axios基本使用" class="headerlink" title="axios基本使用"></a>axios基本使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">获取按钮</span><br><span class="line"><span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="发送ajax请求"><a href="#发送ajax请求" class="headerlink" title="发送ajax请求"></a>发送ajax请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个</span></span><br><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//发送 AJAX 请求</span></span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="comment">//请求类型</span></span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="comment">//URL</span></span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts/2&#x27;</span>,</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一篇新的文章</span></span><br><span class="line">btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//发送 AJAX 请求</span></span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="comment">//请求类型</span></span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="comment">//URL</span></span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span><br><span class="line">        <span class="comment">//设置请求体</span></span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&quot;今天天气不错, 还挺风和日丽的&quot;</span>,</span><br><span class="line">            <span class="attr">author</span>: <span class="string">&quot;张三&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新数据</span></span><br><span class="line">btns[<span class="number">2</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//发送 AJAX 请求</span></span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="comment">//请求类型</span></span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;PUT&#x27;</span>,</span><br><span class="line">        <span class="comment">//URL</span></span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts/3&#x27;</span>,</span><br><span class="line">        <span class="comment">//设置请求体</span></span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&quot;今天天气不错, 还挺风和日丽的&quot;</span>,</span><br><span class="line">            <span class="attr">author</span>: <span class="string">&quot;李四&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);  <span class="comment">/* respones中的data是响应体，为什么是对象？因为axios会自动将响应体进行json解析 */</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数据</span></span><br><span class="line">btns[<span class="number">3</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//发送 AJAX 请求</span></span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">        <span class="comment">//请求类型</span></span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;delete&#x27;</span>,</span><br><span class="line">        <span class="comment">//URL</span></span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts/3&#x27;</span>,</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发送GET请求"><a href="#发送GET请求" class="headerlink" title="发送GET请求"></a>发送GET请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="comment">// axios()</span></span><br><span class="line">      axios.<span class="title function_">request</span>(&#123;</span><br><span class="line">          <span class="attr">method</span>:<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">          <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/comments&#x27;</span></span><br><span class="line">      &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="发送POST请求"><a href="#发送POST请求" class="headerlink" title="发送POST请求"></a>发送POST请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="comment">// axios()</span></span><br><span class="line">           axios.<span class="title function_">post</span>(</span><br><span class="line">                   <span class="string">&#x27;http://localhost:3000/comments&#x27;</span>, </span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="string">&quot;body&quot;</span>: <span class="string">&quot;喜大普奔&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;postId&quot;</span>: <span class="number">2</span></span><br><span class="line">                   &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                       <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">                   &#125;)</span><br><span class="line">      			 	&#125;</span><br><span class="line"></span><br><span class="line">				axios.<span class="title function_">request</span>(&#123;</span><br><span class="line">                   <span class="attr">url</span>: <span class="string">&#x27;/api/getTableData?databaseName=&#x27;</span>+databaseName+<span class="string">&#x27;&amp;tableName=&#x27;</span>+tableName,</span><br><span class="line">                   <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">               &#125;).<span class="title function_">then</span>(</span><br><span class="line">                   <span class="comment">//引入-&gt;import axios from &#x27;axios&#x27;</span></span><br><span class="line">                   <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                       <span class="comment">//回调函数</span></span><br><span class="line">                       <span class="variable language_">this</span>.<span class="property">dataBase</span> = response.<span class="property">data</span>;</span><br><span class="line">                       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;GetTableMessage请求成功了&#x27;</span>, response.<span class="property">data</span>);</span><br><span class="line">                       <span class="variable language_">this</span>.<span class="property">columnValueList</span> = response.<span class="property">data</span>.<span class="property">data</span>;</span><br><span class="line">                       <span class="variable language_">this</span>.<span class="property">columnNameList</span> = response.<span class="property">data</span>.<span class="property">columnNameList</span>;</span><br><span class="line">                   &#125;,</span><br><span class="line">                   <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                       <span class="comment">//出错函数</span></span><br><span class="line">                       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;GetTableMessage请求失败了&#x27;</span>, error.<span class="property">message</span>)</span><br><span class="line">                   &#125;</span><br><span class="line">               )</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * axios(&#123;</span><br><span class="line"> *      url: &#x27;/post&#x27;,</span><br><span class="line"> *      //  /post?a=100&amp;b=200</span><br><span class="line"> *      //  /post/a/100/b/200</span><br><span class="line"> *      //  /post/a.100/b.200</span><br><span class="line"> *      params: &#123;</span><br><span class="line"> *          a:100,</span><br><span class="line"> *          b:200</span><br><span class="line"> *      &#125;</span><br><span class="line"> * &#125;)</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> *  </span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h2 id="axios的默认配置"><a href="#axios的默认配置" class="headerlink" title="axios的默认配置"></a>axios的默认配置</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">method</span> = <span class="string">&#x27;GET&#x27;</span>;<span class="comment">//设置默认的请求类型为 GET</span></span><br><span class="line">        axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://localhost:3000&#x27;</span>;<span class="comment">//设置基础 URL</span></span><br><span class="line">        axios.<span class="property">defaults</span>.<span class="property">params</span> = &#123;<span class="attr">id</span>:<span class="number">100</span>&#125;;</span><br><span class="line">        axios.<span class="property">defaults</span>.<span class="property">timeout</span> = <span class="number">3000</span>;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">axios</span>(&#123;</span><br><span class="line">                <span class="attr">url</span>: <span class="string">&#x27;/posts&#x27;</span></span><br><span class="line">            &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="axios创建实例对象"><a href="#axios创建实例对象" class="headerlink" title="axios创建实例对象"></a>axios创建实例对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建实例对象  /getJoke</span></span><br><span class="line">        <span class="keyword">const</span> duanzi = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">            <span class="attr">baseURL</span>: <span class="string">&#x27;https://api.apiopen.top&#x27;</span>,</span><br><span class="line">            <span class="attr">timeout</span>: <span class="number">2000</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> onather = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">            <span class="attr">baseURL</span>: <span class="string">&#x27;https://b.com&#x27;</span>,</span><br><span class="line">            <span class="attr">timeout</span>: <span class="number">2000</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//这里  duanzi 与 axios 对象的功能几近是一样的</span></span><br><span class="line">        <span class="comment">// duanzi(&#123;</span></span><br><span class="line">        <span class="comment">//     url: &#x27;/getJoke&#x27;,</span></span><br><span class="line">        <span class="comment">// &#125;).then(response =&gt; &#123;</span></span><br><span class="line">        <span class="comment">//     console.log(response);</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">        duanzi.<span class="title function_">get</span>(<span class="string">&#x27;/getJoke&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>axios拦截器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise</span></span><br><span class="line">       <span class="comment">// 设置请求拦截器  config 配置对象</span></span><br><span class="line">       axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 1号&#x27;</span>);</span><br><span class="line">           <span class="comment">//修改 config 中的参数</span></span><br><span class="line">           config.<span class="property">params</span> = &#123;<span class="attr">a</span>:<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> config;</span><br><span class="line">       &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 1号&#x27;</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 2号&#x27;</span>);</span><br><span class="line">           <span class="comment">//修改 config 中的参数</span></span><br><span class="line">           config.<span class="property">timeout</span> = <span class="number">2000</span>;</span><br><span class="line">           <span class="keyword">return</span> config;</span><br><span class="line">       &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 2号&#x27;</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 设置响应拦截器</span></span><br><span class="line">       axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 1号&#x27;</span>);</span><br><span class="line">           <span class="keyword">return</span> response.<span class="property">data</span>;</span><br><span class="line">           <span class="comment">// return response;</span></span><br><span class="line">       &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 1号&#x27;</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 2号&#x27;</span>)</span><br><span class="line">           <span class="keyword">return</span> response;</span><br><span class="line">       &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 2号&#x27;</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//发送请求</span></span><br><span class="line">       <span class="title function_">axios</span>(&#123;</span><br><span class="line">           <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">           <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span><br><span class="line">       &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;自定义回调处理成功的结果&#x27;</span>);</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="请求取消"><a href="#请求取消" class="headerlink" title="请求取消"></a>请求取消</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取按钮</span></span><br><span class="line">        <span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">        <span class="comment">//2.声明全局变量</span></span><br><span class="line">        <span class="keyword">let</span> cancel = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//发送请求</span></span><br><span class="line">        btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">//检测上一次的请求是否已经完成</span></span><br><span class="line">            <span class="keyword">if</span>(cancel !== <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//取消上一次的请求</span></span><br><span class="line">                <span class="title function_">cancel</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">axios</span>(&#123;</span><br><span class="line">                <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">                <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span><br><span class="line">                <span class="comment">//1. 添加配置对象的属性</span></span><br><span class="line">                <span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="keyword">function</span>(<span class="params">c</span>)&#123;</span><br><span class="line">                    <span class="comment">//3. 将 c 的值赋值给 cancel</span></span><br><span class="line">                    cancel = c;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">                <span class="comment">//将 cancel 的值初始化</span></span><br><span class="line">                cancel = <span class="literal">null</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定第二个事件取消请求</span></span><br><span class="line">        btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">cancel</span>();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置代理服务器解决跨域问题"><a href="#配置代理服务器解决跨域问题" class="headerlink" title="配置代理服务器解决跨域问题"></a>配置代理服务器解决跨域问题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">pages</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: &#123;</span><br><span class="line">      <span class="comment">//入口</span></span><br><span class="line">      <span class="attr">entry</span>: <span class="string">&#x27;src/main.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">	<span class="attr">lintOnSave</span>:<span class="literal">false</span>, <span class="comment">//关闭语法检查</span></span><br><span class="line">	<span class="comment">//开启代理服务器（方式一）</span></span><br><span class="line">	<span class="comment">/* devServer: &#123;</span></span><br><span class="line"><span class="comment">    proxy: &#x27;http://localhost:5000&#x27;</span></span><br><span class="line"><span class="comment">  &#125;, */</span></span><br><span class="line">	<span class="comment">//开启代理服务器（方式二）</span></span><br><span class="line">	<span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/atguigu&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,</span><br><span class="line">				<span class="attr">pathRewrite</span>:&#123;<span class="string">&#x27;^/atguigu&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">        <span class="comment">// ws: true, //用于支持websocket</span></span><br><span class="line">        <span class="comment">// changeOrigin: true //用于控制请求头中的host值</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/demo&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,</span><br><span class="line">				<span class="attr">pathRewrite</span>:&#123;<span class="string">&#x27;^/demo&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">        <span class="comment">// ws: true, //用于支持websocket</span></span><br><span class="line">        <span class="comment">// changeOrigin: true //用于控制请求头中的host值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>first</title>
    <url>/2020/06/16/first/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Redis</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>hello</title>
    <url>/2020/09/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Thread Local</title>
    <url>/2022/01/16/ThreadLocal/</url>
    <content><![CDATA[<h1 id="ThreadLocal全面解析"><a href="#ThreadLocal全面解析" class="headerlink" title="ThreadLocal全面解析"></a>ThreadLocal全面解析</h1><p><strong>学习目标</strong></p>
<ul>
<li><strong>了解ThreadLocal的介绍</strong></li>
<li><strong>掌握ThreadLocal的运用场景</strong></li>
<li><strong>了解ThreadLocal的内部结构</strong></li>
<li><strong>了解ThreadLocal的核心方法源码</strong></li>
<li><strong>了解ThreadLocalMap的源码</strong></li>
</ul>
<h2 id="1-ThreadLocal介绍"><a href="#1-ThreadLocal介绍" class="headerlink" title="1. ThreadLocal介绍"></a>1. ThreadLocal介绍</h2><h3 id="1-1-官方介绍"><a href="#1-1-官方介绍" class="headerlink" title="1.1 官方介绍"></a>1.1 官方介绍</h3><p> 从Java官方文档中的描述：<strong>ThreadLocal类用来提供线程内部的局部变量</strong>。这种变量在多线程环境下访问（通过get和set方法访问）时能保证各个线程的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程上下文。</p>
<p>我们可以得知 ThreadLocal 的作用是：提供线程内的局部变量，不同的线程之间不会相互干扰，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量传递的复杂度。</p>
<blockquote>
<p>总结:</p>
<ol>
<li>线程并发: 在多线程并发的场景下</li>
<li>传递数据: 我们可以通过ThreadLocal在同一线程，不同组件中传递公共变量</li>
<li>线程隔离: 每个线程的变量都是独立的，不会互相影响</li>
</ol>
</blockquote>
<h3 id="1-2-基本使用"><a href="#1-2-基本使用" class="headerlink" title="1.2 基本使用"></a>1.2 基本使用</h3><h4 id="1-2-1-常用方法"><a href="#1-2-1-常用方法" class="headerlink" title="1.2.1 常用方法"></a>1.2.1 常用方法</h4><p> 在使用之前,我们先来认识几个ThreadLocal的常用方法</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ThreadLocal()</td>
<td>创建ThreadLocal对象</td>
</tr>
<tr>
<td>public void set( T value)</td>
<td>设置当前线程绑定的局部变量</td>
</tr>
<tr>
<td>public T get()</td>
<td>获取当前线程绑定的局部变量</td>
</tr>
<tr>
<td>public void remove()</td>
<td>移除当前线程绑定的局部变量</td>
</tr>
</tbody></table>
<h4 id="1-2-2-使用案例"><a href="#1-2-2-使用案例" class="headerlink" title="1.2.2 使用案例"></a>1.2.2 使用案例</h4><p>我们来看下面这个案例 , 感受一下ThreadLocal 线程隔离的特点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    demo.setContent(Thread.currentThread().getName() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">             		System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + demo.getContent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果:<br><img src="https://img-blog.csdnimg.cn/20210123210723278.png" alt="在这里插入图片描述"><br>​ 从结果可以看出多个线程在访问同一个变量的时候出现的异常，线程间的数据没有隔离。下面我们来看下采用 ThreadLocal 的方式来解决这个问题的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();<span class="comment">//每个线程一份</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String content; <span class="comment">//同一个对象的content在不同线程中是共享变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">         tl.set(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    demo.setContent(Thread.currentThread().getName() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + demo.getContent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果:<br><img src="https://img-blog.csdnimg.cn/20210123210812106.png" alt="在这里插入图片描述"><br>从结果来看，这样很好的解决了多线程之间数据隔离的问题，十分方便。</p>
<h3 id="1-3-ThreadLocal类与synchronized关键字"><a href="#1-3-ThreadLocal类与synchronized关键字" class="headerlink" title="1.3 ThreadLocal类与synchronized关键字"></a>1.3 ThreadLocal类与synchronized关键字</h3><h4 id="1-3-1-synchronized同步方式"><a href="#1-3-1-synchronized同步方式" class="headerlink" title="1.3.1 synchronized同步方式"></a>1.3.1 synchronized同步方式</h4><p> 这里可能会觉得在上述例子中我们完全可以通过加锁来实现这个功能。我们首先来看一下用synchronized代码块实现的效果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo02</span> <span class="variable">demo02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo02</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (Demo02.class)&#123;</span><br><span class="line">                        demo02.setContent(Thread.currentThread().getName() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;-------------------------------------&quot;</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> demo02.getContent();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + content);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.setName(<span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果:<br><img src="https://img-blog.csdnimg.cn/20210123210856358.png" alt="在这里插入图片描述"><br>​ 从结果可以发现, 加锁确实可以解决这个问题，但是在这里我们强调的是线程数据隔离的问题，并不是多线程共享数据的问题, 在这个案例中使用synchronized关键字是不合适的。</p>
<h4 id="1-3-2-ThreadLocal与synchronized的区别"><a href="#1-3-2-ThreadLocal与synchronized的区别" class="headerlink" title="1.3.2 ThreadLocal与synchronized的区别"></a>1.3.2 ThreadLocal与synchronized的区别</h4><p> 虽然ThreadLocal模式与synchronized关键字都用于处理多线程并发访问变量的问题, 不过两者处理问题的角度和思路不同。</p>
<table>
<thead>
<tr>
<th></th>
<th>synchronized</th>
<th>ThreadLocal</th>
</tr>
</thead>
<tbody><tr>
<td>原理</td>
<td>同步机制采用’以时间换空间’的方式, 只提供了一份变量,让不同的线程排队访问</td>
<td>ThreadLocal采用’以空间换时间’的方式, 为每一个线程都提供了一份变量的副本,从而实现同时访问而相不干扰</td>
</tr>
<tr>
<td>侧重点</td>
<td>多个线程之间访问资源的同步</td>
<td>多线程中让每个线程之间的数据相互隔离</td>
</tr>
</tbody></table>
<blockquote>
<p>总结：<br>在刚刚的案例中，虽然使用ThreadLocal和synchronized都能解决问题,但是使用ThreadLocal更为合适,因为这样可以使程序拥有更高的并发性。</p>
</blockquote>
<h2 id="2-运用场景-事务案例"><a href="#2-运用场景-事务案例" class="headerlink" title="2. 运用场景_事务案例"></a>2. 运用场景_事务案例</h2><p> 通过以上的介绍，我们已经基本了解ThreadLocal的特点。但是它具体是运用在什么场景中呢？ 接下来让我们看一个案例： 事务操作。</p>
<h3 id="2-1-转账案例"><a href="#2-1-转账案例" class="headerlink" title="2.1 转账案例"></a>2.1 转账案例</h3><h4 id="2-1-1-场景构建"><a href="#2-1-1-场景构建" class="headerlink" title="2.1.1 场景构建"></a>2.1.1 场景构建</h4><p> 这里我们先构建一个简单的转账场景： 有一个数据表account，里面有两个用户Jack和Rose，用户Jack 给用户Rose 转账。</p>
<p> 案例的实现主要用mysql数据库，JDBC 和 C3P0 框架。以下是详细代码 ：</p>
<p> （1） 项目结构<br><img src="https://img-blog.csdnimg.cn/20210123211111323.png" alt="在这里插入图片描述"><br>​ （2） 数据准备<br><img src="https://img-blog.csdnimg.cn/20210123211717292.png" alt="在这里插入图片描述"><br>（3） dao层代码 ： AccountDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">(String outUser, <span class="type">int</span> money)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update account set money = money - ? where name = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">pstm</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    pstm.setInt(<span class="number">1</span>,money);</span><br><span class="line">    pstm.setString(<span class="number">2</span>,outUser);</span><br><span class="line">    pstm.executeUpdate();</span><br><span class="line"></span><br><span class="line">    JdbcUtils.release(pstm,conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">(String inUser, <span class="type">int</span> money)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update account set money = money + ? where name = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">pstm</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    pstm.setInt(<span class="number">1</span>,money);</span><br><span class="line">    pstm.setString(<span class="number">2</span>,inUser);</span><br><span class="line">    pstm.executeUpdate();</span><br><span class="line"></span><br><span class="line">    JdbcUtils.release(pstm,conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（4） service层代码 ： AccountService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transfer</span><span class="params">(String outUser, String inUser, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="type">AccountDao</span> <span class="variable">ad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountDao</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 转出</span></span><br><span class="line">            ad.out(outUser, money);</span><br><span class="line">            <span class="comment">// 转入</span></span><br><span class="line">            ad.in(inUser, money);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（5） 工具类 ： JdbcUtils</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcUtils</span> &#123; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">commitAndClose</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            conn.commit();</span><br><span class="line">            <span class="comment">//释放连接</span></span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rollbackAndClose</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//回滚事务</span></span><br><span class="line">            conn.rollback();</span><br><span class="line">            <span class="comment">//释放连接</span></span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-引入事务"><a href="#2-1-2-引入事务" class="headerlink" title="2.1.2 引入事务"></a><a href="https://blog.csdn.net/weixin_44050144/article/details/113061884"></a>2.1.2 引入事务</h4><p> 案例中的转账涉及两个DML操作： 一个转出，一个转入。这些操作是需要具备原子性的，不可分割。不然就有可能出现数据修改异常情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transfer</span><span class="params">(String outUser, String inUser, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="type">AccountDao</span> <span class="variable">ad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountDao</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 转出</span></span><br><span class="line">            ad.out(outUser, money);</span><br><span class="line">            <span class="comment">// 模拟转账过程中的异常</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 转入</span></span><br><span class="line">            ad.in(inUser, money);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 所以这里就需要操作事务，来保证转出和转入操作具备原子性，要么同时成功，要么同时失败。</p>
<p>（1） JDBC中关于事务的操作的api</p>
<table>
<thead>
<tr>
<th>Connection接口的方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>void setAutoCommit(false)</td>
<td>禁用事务自动提交（改为手动）</td>
</tr>
<tr>
<td>void commit();</td>
<td>提交事务</td>
</tr>
<tr>
<td>void rollback();</td>
<td>回滚事务</td>
</tr>
</tbody></table>
<p><strong>（2） 开启事务的注意点:</strong></p>
<ul>
<li><p>为了保证所有的操作在一个事务中,案例中使用的连接必须是同一个: service层开启事务的connection需要跟dao层访问数据库的connection保持一致</p>
</li>
<li><p>线程并发情况下, 每个线程只能操作各自的 connection</p>
</li>
</ul>
<h3 id="2-2-常规解决方案"><a href="#2-2-常规解决方案" class="headerlink" title="2.2 常规解决方案"></a>2.2 常规解决方案</h3><h4 id="2-2-1-常规方案的实现"><a href="#2-2-1-常规方案的实现" class="headerlink" title="2.2.1 常规方案的实现"></a>2.2.1 常规方案的实现</h4><p>基于上面给出的前提， 大家通常想到的解决方案是 ：</p>
<ul>
<li>传参: 从service层将connection对象向dao层传递</li>
<li>加锁</li>
</ul>
<p>以下是代码实现修改的部分：</p>
<p> （1 ) AccountService 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transfer</span><span class="params">(String outUser, String inUser, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="type">AccountDao</span> <span class="variable">ad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountDao</span>();</span><br><span class="line">        <span class="comment">//线程并发情况下,为了保证每个线程使用各自的connection,故加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (AccountService.class) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn = JdbcUtils.getConnection();</span><br><span class="line">                <span class="comment">//开启事务</span></span><br><span class="line">                conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">                <span class="comment">// 转出</span></span><br><span class="line">                ad.out(conn, outUser, money);</span><br><span class="line">                <span class="comment">// 模拟转账过程中的异常</span></span><br><span class="line"><span class="comment">//            int i = 1/0;</span></span><br><span class="line">                <span class="comment">// 转入</span></span><br><span class="line">                ad.in(conn, inUser, money);</span><br><span class="line">                <span class="comment">//事务提交</span></span><br><span class="line">                JdbcUtils.commitAndClose(conn);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">//事务回滚</span></span><br><span class="line">                JdbcUtils.rollbackAndClose(conn);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> （2) AccountDao 类 （这里需要注意的是： connection不能在dao层释放，要在service层，不然在dao层释放，service层就无法使用了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">(Connection conn, String outUser, <span class="type">int</span> money)</span> <span class="keyword">throws</span> SQLException&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update account set money = money - ? where name = ?&quot;</span>;</span><br><span class="line">        <span class="comment">//注释从连接池获取连接的代码,使用从service中传递过来的connection</span></span><br><span class="line"><span class="comment">//        Connection conn = JdbcUtils.getConnection();</span></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pstm</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">        pstm.setInt(<span class="number">1</span>,money);</span><br><span class="line">        pstm.setString(<span class="number">2</span>,outUser);</span><br><span class="line">        pstm.executeUpdate();</span><br><span class="line">        <span class="comment">//连接不能在这里释放,service层中还需要使用</span></span><br><span class="line"><span class="comment">//        JdbcUtils.release(pstm,conn);</span></span><br><span class="line">        JdbcUtils.release(pstm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">(Connection conn, String inUser, <span class="type">int</span> money)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update account set money = money + ? where name = ?&quot;</span>;</span><br><span class="line"><span class="comment">//        Connection conn = JdbcUtils.getConnection();</span></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">pstm</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">        pstm.setInt(<span class="number">1</span>,money);</span><br><span class="line">        pstm.setString(<span class="number">2</span>,inUser);</span><br><span class="line">        pstm.executeUpdate();</span><br><span class="line"><span class="comment">//        JdbcUtils.release(pstm,conn);</span></span><br><span class="line">        JdbcUtils.release(pstm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-常规方案的弊端"><a href="#2-2-2-常规方案的弊端" class="headerlink" title="2.2.2 常规方案的弊端"></a>2.2.2 常规方案的弊端</h4><p>上述方式我们看到的确按要求解决了问题，但是仔细观察，会发现这样实现的弊端：</p>
<ol>
<li><p>直接从service层传递connection到dao层, 造成代码耦合度提高</p>
</li>
<li><p>加锁会造成线程失去并发性，程序性能降低</p>
</li>
</ol>
<h3 id="2-3-ThreadLocal解决方案"><a href="#2-3-ThreadLocal解决方案" class="headerlink" title="2.3 ThreadLocal解决方案"></a>2.3 ThreadLocal解决方案</h3><h4 id="2-3-1-ThreadLocal方案的实现"><a href="#2-3-1-ThreadLocal方案的实现" class="headerlink" title="2.3.1 ThreadLocal方案的实现"></a>2.3.1 ThreadLocal方案的实现</h4><p>像这种需要在项目中进行<strong>数据传递</strong>和<strong>线程隔离</strong>的场景，我们不妨用ThreadLocal来解决：</p>
<p> （1） 工具类的修改： 加入ThreadLocal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcUtils</span> &#123;</span><br><span class="line">    <span class="comment">//ThreadLocal对象 : 将connection绑定在当前线程中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c3p0 数据库连接池对象属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ComboPooledDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//取出当前线程绑定的connection对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> tl.get();</span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果没有，则从连接池中取出</span></span><br><span class="line">            conn = ds.getConnection();</span><br><span class="line">            <span class="comment">//再将connection对象绑定到当前线程中</span></span><br><span class="line">            tl.set(conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(AutoCloseable... ios)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (AutoCloseable io : ios) &#123;</span><br><span class="line">            <span class="keyword">if</span> (io != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    io.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">commitAndClose</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> getConnection();</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            conn.commit();</span><br><span class="line">            <span class="comment">//解除绑定</span></span><br><span class="line">            tl.remove();</span><br><span class="line">            <span class="comment">//释放连接</span></span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rollbackAndClose</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> getConnection();</span><br><span class="line">            <span class="comment">//回滚事务</span></span><br><span class="line">            conn.rollback();</span><br><span class="line">            <span class="comment">//解除绑定</span></span><br><span class="line">            tl.remove();</span><br><span class="line">            <span class="comment">//释放连接</span></span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> （2） AccountService类的修改：不需要传递connection对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transfer</span><span class="params">(String outUser, String inUser, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="type">AccountDao</span> <span class="variable">ad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountDao</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">            <span class="comment">//开启事务</span></span><br><span class="line">            conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 转出 ： 这里不需要传参了 ！</span></span><br><span class="line">            ad.out(outUser, money);</span><br><span class="line">            <span class="comment">// 模拟转账过程中的异常</span></span><br><span class="line"><span class="comment">//            int i = 1 / 0;</span></span><br><span class="line">            <span class="comment">// 转入</span></span><br><span class="line">            ad.in(inUser, money);</span><br><span class="line">            <span class="comment">//事务提交</span></span><br><span class="line">            JdbcUtils.commitAndClose();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">//事务回滚</span></span><br><span class="line">           JdbcUtils.rollbackAndClose();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> （3） AccountDao类的修改：照常使用</p>
<h4 id="2-3-2-ThreadLocal方案的好处"><a href="#2-3-2-ThreadLocal方案的好处" class="headerlink" title="2.3.2 ThreadLocal方案的好处"></a>2.3.2 ThreadLocal方案的好处</h4><p>从上述的案例中我们可以看到， 在一些特定场景下，ThreadLocal方案有两个突出的优势：</p>
<ol>
<li><p>传递数据 ： 保存每个线程绑定的数据，在需要的地方可以直接获取, 避免参数直接传递带来的代码耦合问题</p>
</li>
<li><p>线程隔离 ： 各线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失</p>
</li>
</ol>
<h2 id="3-ThreadLocal的内部结构"><a href="#3-ThreadLocal的内部结构" class="headerlink" title="3. ThreadLocal的内部结构"></a>3. ThreadLocal的内部结构</h2><p> 通过以上的学习，我们对ThreadLocal的作用有了一定的认识。现在我们一起来看一下ThreadLocal的内部结构，探究它能够实现线程数据隔离的原理。</p>
<h3 id="3-1-常见的误解"><a href="#3-1-常见的误解" class="headerlink" title="3.1 常见的误解"></a>3.1 常见的误解</h3><p> 如果我们不去看源代码的话，可能会猜测<code>ThreadLocal</code>是这样子设计的：每个<code>ThreadLocal</code>都创建一个<code>Map</code>，然后用线程作为<code>Map</code>的<code>key</code>，要存储的局部变量作为<code>Map</code>的<code>value</code>，这样就能达到各个线程的局部变量隔离的效果。这是最简单的设计方法，JDK最早期的<code>ThreadLocal</code> 确实是这样设计的，但现在早已不是了。<br><img src="https://img-blog.csdnimg.cn/20210124115504330.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>这也是早期的<code>ThreadLocal</code>设计方式，这种方式导致每个线程的ThreadLocal都要存储所有线程的信息，造成查询效率或者空间上的浪费</p>
</blockquote>
<h3 id="3-2-现在的设计"><a href="#3-2-现在的设计" class="headerlink" title="3.2 现在的设计"></a>3.2 现在的设计</h3><p> 但是，JDK后面优化了设计方案，在JDK8中 <code>ThreadLocal</code>的设计是：每个<code>Thread</code>维护一个<code>ThreadLocalMap</code>，这个Map的<code>key</code>是<code>ThreadLocal</code>实例本身，<code>value</code>才是真正要存储的值<code>Object</code>。</p>
<p>具体的过程是这样的：</p>
<ul>
<li><p>每个Thread线程内部都有一个Map (ThreadLocalMap)</p>
</li>
<li><p>Map里面存储ThreadLocal对象（key）和线程的变量副本（value）</p>
</li>
<li><p>Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。</p>
</li>
<li><p>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。<br><img src="https://img-blog.csdnimg.cn/20210124120125266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA1MDE0NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="3-3-这样设计的好处"><a href="#3-3-这样设计的好处" class="headerlink" title="3.3 这样设计的好处"></a>3.3 这样设计的好处</h3><p> 这个设计与我们一开始说的设计刚好相反，这样设计有如下两个优势：</p>
<ul>
<li>这样设计之后每个<code>Map</code>存储的<code>Entry</code>数量就会变少。因为之前的存储数量由<code>Thread</code>的数量决定，现在是由<code>ThreadLocal</code>的数量决定。在实际运用当中，往往ThreadLocal的数量要少于Thread的数量。</li>
<li>当<code>Thread</code>销毁之后，对应的<code>ThreadLocalMap</code>也会随之销毁，能<strong>减少内存的使用。</strong></li>
</ul>
<h2 id="4-ThreadLocal的核心方法源码"><a href="#4-ThreadLocal的核心方法源码" class="headerlink" title="4. ThreadLocal的核心方法源码"></a>4. ThreadLocal的核心方法源码</h2><p> 基于ThreadLocal的内部结构，我们继续分析它的核心方法源码，更深入的了解其操作原理。</p>
<p>除了构造方法之外， ThreadLocal对外暴露的方法有以下4个：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>protected T initialValue()</td>
<td>返回当前线程局部变量的初始值</td>
</tr>
<tr>
<td>public void set( T value)</td>
<td>设置当前线程绑定的局部变量</td>
</tr>
<tr>
<td>public T get()</td>
<td>获取当前线程绑定的局部变量</td>
</tr>
<tr>
<td>public void remove()</td>
<td>移除当前线程绑定的局部变量</td>
</tr>
</tbody></table>
<p> 以下是这4个方法的详细源码分析(为了保证思路清晰, ThreadLocalMap部分暂时不展开,下一个知识点详解)</p>
<h3 id="4-1-set方法"><a href="#4-1-set方法" class="headerlink" title="4.1 set方法"></a>4.1 set方法</h3><p><strong>（1 ) 源码和对应的中文注释</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value 将要保存在当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">       <span class="comment">// 获取当前线程对象</span></span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">       <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">       <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">       <span class="comment">// 判断map是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">           <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">           map.set(<span class="built_in">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">           <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">           <span class="comment">// 3）并将 t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取当前线程Thread对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>  t the current thread 当前线程</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the map 对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *创建当前线程Thread对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> t 当前线程</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> firstValue 存放到map中第一个entry的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">       <span class="comment">//这里的this是调用此方法的threadLocal</span></span><br><span class="line">       t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（2 ) 代码执行流程</strong></p>
<p> A. 首先获取当前线程，并根据当前线程获取一个Map</p>
<p> B. 如果获取的Map不为空，则将参数设置到Map中（当前ThreadLocal的引用作为key）</p>
<p> C. 如果Map为空，则给该线程创建 Map，并设置初始值</p>
<h3 id="4-2-get方法"><a href="#4-2-get方法" class="headerlink" title="4.2 get方法"></a>4.2 get方法</h3><p><strong>（1 ) 源码和对应的中文注释</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程中保存ThreadLocal的值</span></span><br><span class="line"><span class="comment"> * 如果当前线程没有此ThreadLocal变量，</span></span><br><span class="line"><span class="comment"> * 则它会通过调用&#123;<span class="doctag">@link</span> #initialValue&#125; 方法进行初始化值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回当前线程对应此ThreadLocal的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前·线程对象·</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 如果此map存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 以当前的ThreadLocal 为 key，调用getEntry获取对应的存储实体e</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 对e进行判空 </span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 获取存储实体 e 对应的 value值</span></span><br><span class="line">            <span class="comment">// 即为我们想要的当前线程对应此ThreadLocal的值</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	初始化 : 有两种情况有执行当前代码</span></span><br><span class="line"><span class="comment">    	第一种情况: map不存在，表示此线程没有维护的ThreadLocalMap对象</span></span><br><span class="line"><span class="comment">    	第二种情况: map存在, 但是没有与当前ThreadLocal关联的entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value 初始化后的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用initialValue获取初始化的值</span></span><br><span class="line">    <span class="comment">// 此方法可以被子类重写, 如果不重写默认返回null</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 判断map是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">        <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">        <span class="comment">// 3）并将 t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="comment">// 返回设置的值value</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（2 ) 代码执行流程</strong></p>
<p> A. 首先获取当前线程, 根据当前线程获取一个Map</p>
<p> B. 如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的Entry e，否则转到D</p>
<p> C. 如果e不为null，则返回e.value，否则转到D</p>
<p> D. Map为空或者e为空，则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为firstKey和firstValue创建一个新的Map</p>
<p>总结: <strong>先获取当前线程的 ThreadLocalMap 变量，如果存在则返回值，不存在则创建并返回初始值。</strong></p>
<h3 id="4-3-remove方法"><a href="#4-3-remove方法" class="headerlink" title="4.3 remove方法"></a>4.3 remove方法</h3><p><strong>（1 ) 源码和对应的中文注释</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除当前线程中保存的ThreadLocal对应的实体entry</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 获取当前线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">       <span class="comment">// 如果此map存在</span></span><br><span class="line">        <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">           <span class="comment">// 存在则调用map.remove</span></span><br><span class="line">           <span class="comment">// 以当前ThreadLocal为key删除对应的实体entry</span></span><br><span class="line">            m.remove(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（2 ) 代码执行流程</strong></p>
<p> A. 首先获取当前线程，并根据当前线程获取一个Map</p>
<p> B. 如果获取的Map不为空，则移除当前ThreadLocal对象对应的entry</p>
<h3 id="4-4-initialValue方法"><a href="#4-4-initialValue方法" class="headerlink" title="4.4 initialValue方法"></a><strong>4.4 initialValue方法</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 返回当前线程对应的ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  * 此方法的第一次调用发生在，当线程通过get方法访问此线程的ThreadLocal值时</span></span><br><span class="line"><span class="comment">  * 除非线程先调用了set方法，在这种情况下，initialValue 才不会被这个线程调用。</span></span><br><span class="line"><span class="comment">  * 通常情况下，每个线程最多调用一次这个方法。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;这个方法仅仅简单的返回null &#123;<span class="doctag">@code</span> null&#125;;</span></span><br><span class="line"><span class="comment">  * 如果程序员想ThreadLocal线程局部变量有一个除null以外的初始值，</span></span><br><span class="line"><span class="comment">  * 必须通过子类继承&#123;<span class="doctag">@code</span> ThreadLocal&#125; 的方式去重写此方法</span></span><br><span class="line"><span class="comment">  * 通常, 可以通过匿名内部类的方式实现</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 当前ThreadLocal的初始值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 此方法的作用是 返回该线程局部变量的初始值。</p>
<p>（1） 这个方法是一个延迟调用方法，从上面的代码我们得知，在set方法还未调用而先调用了get方法时才执行，并且仅执行1次。</p>
<p>（2）这个方法缺省实现直接返回一个<code>null</code>。</p>
<p>（3）如果想要一个除null之外的初始值，可以重写此方法。（备注： 该方法是一个<code>protected</code>的方法，显然是为了让子类覆盖而设计的）</p>
<h2 id="5-ThreadLocalMap源码分析"><a href="#5-ThreadLocalMap源码分析" class="headerlink" title="5. ThreadLocalMap源码分析"></a>5. ThreadLocalMap源码分析</h2><p> 在分析ThreadLocal方法的时候，我们了解到ThreadLocal的操作实际上是围绕ThreadLocalMap展开的。ThreadLocalMap的源码相对比较复杂, 我们从以下三个方面进行讨论。</p>
<h3 id="5-1-基本结构"><a href="#5-1-基本结构" class="headerlink" title="5.1 基本结构"></a>5.1 基本结构</h3><p> ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也是独立实现。<br><img src="https://img-blog.csdnimg.cn/20210124143602480.png" alt="在这里插入图片描述"><br><strong>（1） 成员变量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始容量 —— 必须是2的整次幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放数据的table，Entry类的定义在下面分析</span></span><br><span class="line"><span class="comment"> * 同样，数组长度必须是2的整次幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组里面entrys的个数，可以用于判断table当前使用量是否超过阈值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行扩容的阈值，表使用量大于它的时候进行扩容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 跟HashMap类似，INITIAL_CAPACITY代表这个Map的初始容量；table 是一个Entry 类型的数组，用于存储数据；size 代表表中的存储数目； threshold 代表需要扩容时对应 size 的阈值。</p>
<p><strong>（2） 存储结构 - Entry</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Entry继承WeakReference，并且用ThreadLocal作为key.</span></span><br><span class="line"><span class="comment"> * 如果key为null(entry.get() == null)，意味着key不再被引用，</span></span><br><span class="line"><span class="comment"> * 因此这时候entry也可以从table中清除。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。不过Entry中的key只能是ThreadLocal对象，这点在构造方法中已经限定死了。</p>
<p> 另外，Entry继承WeakReference，也就是key（ThreadLocal）是弱引用，其目的是将ThreadLocal对象的生命周期和线程生命周期解绑。</p>
<h3 id="5-2-弱引用和内存泄漏"><a href="#5-2-弱引用和内存泄漏" class="headerlink" title="5.2 弱引用和内存泄漏"></a>5.2 弱引用和内存泄漏</h3><p> 有些程序员在使用ThreadLocal的过程中会发现有内存泄漏的情况发生，就猜测这个内存泄漏跟Entry中使用了弱引用的key有关系。这个理解其实是不对的。</p>
<p> 我们先来回顾这个问题中涉及的几个名词概念，再来分析问题。</p>
<p><strong>（1） 内存泄漏相关概念</strong></p>
<ul>
<li>Memory overflow:内存溢出，没有足够的内存提供申请者使用。</li>
<li>Memory leak: 内存泄漏是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。内存泄漏的堆积终将导致内存溢出。</li>
</ul>
<p><strong>（2） 弱引用相关概念</strong></p>
<p> Java中的引用有4种类型： 强、软、弱、虚。当前这个问题主要涉及到强引用和弱引用：</p>
<p> <strong>强引用（“Strong” Reference）</strong>，就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾回收器就不会回收这种对象。</p>
<p> <strong>弱引用（WeakReference）</strong>，垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p>
<p><strong>（3） 如果key使用强引用</strong></p>
<p> 假设ThreadLocalMap中的key使用了强引用，那么会出现内存泄漏吗？</p>
<p> 此时ThreadLocal的内存图（实线表示强引用）如下：<br><img src="https://img-blog.csdnimg.cn/20210124144330949.png" alt="在这里插入图片描述"><br>​ 假设在业务代码中使用完ThreadLocal ，threadLocal Ref被回收了。</p>
<p> 但是因为threadLocalMap的Entry强引用了threadLocal，造成threadLocal无法被回收。</p>
<p> 在没有手动删除这个Entry以及CurrentThread依然运行的前提下，始终有强引用链 threadRef-&gt;currentThread-&gt;threadLocalMap-&gt;entry，Entry就不会被回收（Entry中包括了ThreadLocal实例和value），导致Entry内存泄漏。</p>
<p> 也就是说，ThreadLocalMap中的key使用了强引用， 是无法完全避免内存泄漏的。</p>
<p><strong>（5）如果key使用弱引用</strong></p>
<p> 那么ThreadLocalMap中的key使用了弱引用，会出现内存泄漏吗？</p>
<p> 此时ThreadLocal的内存图（实线表示强引用，虚线表示弱引用）如下：<br><img src="https://img-blog.csdnimg.cn/20210124144945153.png" alt="在这里插入图片描述"><br>​ 同样假设在业务代码中使用完ThreadLocal ，threadLocal Ref被回收了。</p>
<p> 由于ThreadLocalMap只持有ThreadLocal的弱引用，没有任何强引用指向threadlocal实例, <strong>所以threadlocal就可以顺利被gc回收</strong>，此时Entry中的key&#x3D;null。</p>
<p> 但是在没有手动删除这个Entry以及CurrentThread依然运行的前提下，也存在有强引用链 threadRef-&gt;currentThread-&gt;threadLocalMap-&gt;entry -&gt; value ，value不会被回收， 而这块value永远不会被访问到了，导致value内存泄漏。</p>
<p> 也就是说，ThreadLocalMap中的key使用了弱引用， 也有可能内存泄漏。</p>
<p><strong>（6）出现内存泄漏的真实原因</strong></p>
<p> 比较以上两种情况，我们就会发现，内存泄漏的发生跟ThreadLocalMap中的key是否使用弱引用是没有关系的。那么内存泄漏的的真正原因是什么呢？</p>
<p> 细心的同学会发现，在以上两种内存泄漏的情况中，都有两个前提：</p>
<blockquote>
<ol>
<li>没有手动删除这个Entry</li>
<li>CurrentThread依然运行</li>
</ol>
</blockquote>
<p> 第一点很好理解，只要在使用完ThreadLocal，调用其remove方法删除对应的Entry，就能避免内存泄漏。</p>
<p> 第二点稍微复杂一点， <strong>由于ThreadLocalMap是Thread的一个属性，被当前线程所引用，所以它的生命周期跟Thread一样长</strong>。那么在使用完ThreadLocal之后，如果当前Thread也随之执行结束，ThreadLocalMap自然也会被gc回收，从根源上避免了内存泄漏。</p>
<p> 综上，<strong>ThreadLocal内存泄漏的根源是</strong>：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏。</p>
<p><strong>（7） 为什么使用弱引用</strong></p>
<p> 根据刚才的分析, 我们知道了： 无论ThreadLocalMap中的key使用哪种类型引用都无法完全避免内存泄漏，跟使用弱引用没有关系。</p>
<p> 要避免内存泄漏有两种方式：</p>
<ol>
<li><p>使用完ThreadLocal，调用其remove方法删除对应的Entry</p>
</li>
<li><p>使用完ThreadLocal，当前Thread也随之运行结束</p>
</li>
</ol>
<blockquote>
<p>相对第一种方式，第二种方式显然更不好控制，特别是使用线程池的时候，线程结束是不会销毁的。</p>
</blockquote>
<p> 也就是说，只要记得在使用完ThreadLocal及时的调用remove，无论key是强引用还是弱引用都不会有问题。那么为什么key要用弱引用呢？</p>
<p> 事实上，在ThreadLocalMap中的set&#x2F;getEntry方法中，会对key为null（也即是ThreadLocal为null）进行判断，如果为null的话，那么是会对value置为null的。</p>
<p> 这就意味着使用完ThreadLocal，CurrentThread依然运行的前提下，就算忘记调用remove方法，<strong>弱引用比强引用可以多一层保障</strong>：弱引用的ThreadLocal会被回收，对应的value在下一次ThreadLocalMap调用set,get,remove中的任一方法的时候会被清除，从而避免内存泄漏。</p>
<h3 id="5-3-hash冲突的解决"><a href="#5-3-hash冲突的解决" class="headerlink" title="5.3 hash冲突的解决"></a>5.3 hash冲突的解决</h3><p> hash冲突的解决是Map中的一个重要内容。我们以hash冲突的解决为线索，来研究一下ThreadLocalMap的核心源码。</p>
<p><strong>（1） 首先从ThreadLocal的set() 方法入手</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">      ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">      <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">          <span class="comment">//调用了ThreadLocalMap的set方法</span></span><br><span class="line">          map.set(<span class="built_in">this</span>, value);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ThreadLocal.ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">      	<span class="comment">//调用了ThreadLocalMap的构造方法</span></span><br><span class="line">      t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap(<span class="built_in">this</span>, firstValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个方法我们刚才分析过, 其作用是设置当前线程绑定的局部变量 :</p>
<p> A. 首先获取当前线程，并根据当前线程获取一个Map</p>
<p> B. 如果获取的Map不为空，则将参数设置到Map中（当前ThreadLocal的引用作为key）</p>
<p> <strong>(这里调用了ThreadLocalMap的set方法)</strong></p>
<p> C. 如果Map为空，<strong>则给该线程创建 Map，并设置初始值(也就是要set的值，因为是懒惰加载)</strong></p>
<p> <strong>(这里调用了ThreadLocalMap的构造方法)</strong></p>
<p>这段代码有两个地方分别涉及到ThreadLocalMap的两个方法, 我们接着分析这两个方法。</p>
<p><strong>（2）构造方法<code>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue)</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * firstKey : 本ThreadLocal实例(this)</span></span><br><span class="line"><span class="comment">  * firstValue ： 要保存的线程本地变量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        <span class="comment">//初始化table</span></span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="comment">//计算索引(重点代码）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//设置值</span></span><br><span class="line">        table[i] = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//设置阈值</span></span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 构造函数首先创建一个<strong>长度为16的Entry数组</strong>，然后计算出<strong>firstKey对应的索引</strong>，然后存储到table中，并设置size和threshold。</p>
<p> <strong>重点分析</strong>： <code>int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1)</code>。</p>
<p>a. 关于<code>firstKey.threadLocalHashCode</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//AtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式操作加减,适合高并发情况下的使用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">     <span class="comment">//特殊的hash值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br></pre></td></tr></table></figure>

<p> 这里定义了一个AtomicInteger类型，每次获取当前值并加上HASH_INCREMENT，<code>HASH_INCREMENT = 0x61c88647</code>,这个值跟斐波那契数列（黄金分割数）有关，其主要目的就是为了让哈希码能均匀的分布在2的n次方的数组里, 也就是Entry[] table中，这样做可以尽量避免hash冲突。</p>
<p>b. 关于<code>&amp; (INITIAL_CAPACITY - 1)</code> </p>
<p> 计算hash的时候里面采用了hashCode &amp; (size - 1)<code>(0 1 2 3 4 -&gt; 0 1 )</code>的算法，这相当于取模运算hashCode % size的一个更高效的实现。正是因为这种算法，我们要求size必须是2的整次幂，这也能保证在索引不越界的前提下，使得hash发生冲突的次数减小。</p>
<p><strong>（3） ThreadLocalMap中的set方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">        <span class="comment">//计算索引(重点代码，刚才分析过了）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用线性探测法查找元素（重点代码）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">             e != <span class="literal">null</span>;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;<span class="comment">//i = nextIndex(i, len) i会不断下移</span></span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="comment">//ThreadLocal 对应的 key 存在，直接覆盖之前的值</span></span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// key为 null，但是值不为 null，说明之前的 ThreadLocal 对象已经被回收了，</span></span><br><span class="line">           <span class="comment">// 当前数组中的 Entry 是一个陈旧（stale）的元素</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//用新元素替换陈旧的元素，这个方法进行了不少的垃圾清理动作，防止内存泄漏</span></span><br><span class="line">                replaceStaleEntry(key, value, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//ThreadLocal对应的key不存在并且没有找到陈旧的元素，则在空元素的位置创建一个新的Entry。</span></span><br><span class="line">            tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * cleanSomeSlots用于清除那些e.get()==null的元素，</span></span><br><span class="line"><span class="comment">             * 这种数据key关联的对象已经被回收，所以这个Entry(table[index])可以被置null。</span></span><br><span class="line"><span class="comment">             * 如果没有清除任何entry,并且当前使用量达到了负载因子所定义(长度的2/3)，那么进行				 * rehash（执行一次全表的扫描清理工作）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取环形数组的下一个索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 代码执行流程：</p>
<p>A. 首先还是根据key计算出索引 i，然后查找i位置上的Entry，</p>
<p>B. <strong>若是Entry已经存在</strong>并且key等于传入的key，那么这时候直接给这个Entry赋新的value值,</p>
<p>C. <strong>若是Entry存在</strong>，但是key为null，则调用replaceStaleEntry来更换这个key为空的Entry,</p>
<p>D. <strong>不断循环检测（没有找到Entry已经存在）</strong>，直到遇到为null的地方，这时候要是还没在循环过程中return，那么就在这个null的位置新建一个Entry，并且插入，同时size增加1。</p>
<p> 最后调用cleanSomeSlots，清理key为null的Entry，最后返回是否清理了Entry，接下来再判断sz 是否&gt;&#x3D; thresgold达到了rehash的条件，达到的话就会调用rehash函数执行一次全表的扫描清理。</p>
<p><strong>重点分析</strong> ： ThreadLocalMap使用<code>线性探测法</code>来解决哈希冲突的。</p>
<p> 该方法一次探测下一个地址，直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。</p>
<p> 举个例子，假设当前table长度为16，也就是说如果计算出来key的hash值为14，如果table[14]上已经有值，并且其key与当前key不一致，那么就发生了hash冲突，这个时候将14加1得到15，取table[15]进行判断，这个时候如果还是冲突会回到0，取table[0],以此类推，直到可以插入。</p>
<p> 按照上面的描述，<strong>可以把Entry[] table看成一个环形数组</strong>。</p>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
  </entry>
  <entry>
    <title>first</title>
    <url>/2021/06/16/%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/</url>
    <content><![CDATA[<h1 id="查这么多数据会不会把内存打爆"><a href="#查这么多数据会不会把内存打爆" class="headerlink" title="查这么多数据会不会把内存打爆"></a>查这么多数据会不会把内存打爆</h1><blockquote>
<p>不会，Mysql是边写边发的，**<code>结果集并不是完整了才会发送</code>**</p>
</blockquote>
<p><img src="/Mysql45/image-20220320231944346.png" alt="image-20220320231944346"></p>
<p><img src="/Mysql45/image-20220320232002204.png" alt="image-20220320232002204"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>first</title>
    <url>/2021/06/16/%E5%B9%BB%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h1><blockquote>
<p>幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。专指insert新增导致的看到没有的行</p>
</blockquote>
<ul>
<li>在可重复读隔离级别下，<strong>普通的查询是<code>快照读</code>，</strong>是**<code>不会</code>**看到别的事务插入的数据的。因此，<br><strong>幻读在“<code>当前读</code>”下才会出现</strong>。</li>
<li>下面session B的修改结果，被session A之后的select语句用“当前读”看到，不能称为幻读。<br>幻读仅专指“新插入的行”。**<code>update不算，只有insert才算幻读</code>**</li>
</ul>
<p><img src="/Mysql45/image-20220320175307605.png" alt="image-20220320175307605"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode Input Output</title>
    <url>/2022/03/23/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<blockquote>
<p>有段时间没有接触ACM方式输入输出，突然做一道ACM模式的题处理输入输出花了大把时间。。。</p>
</blockquote>
<h2 id="LinkedList链表"><a href="#LinkedList链表" class="headerlink" title="LinkedList链表"></a>LinkedList链表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">     * public class ListNode &#123;</span></span><br><span class="line"><span class="comment">     *     int val;</span></span><br><span class="line"><span class="comment">     *     ListNode next;</span></span><br><span class="line"><span class="comment">     *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] stringToIntegerArray(String input) &#123;</span><br><span class="line">        input = input.trim();</span><br><span class="line">        input = input.substring(<span class="number">1</span>, input.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (input.length() == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        String[] parts = input.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[] output = <span class="keyword">new</span> <span class="title class_">int</span>[parts.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; parts.length; index++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">part</span> <span class="operator">=</span> parts[index].trim();</span><br><span class="line">            output[index] = Integer.parseInt(part);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//构建链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">stringToListNode</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="comment">// Generate array from the input</span></span><br><span class="line">        <span class="type">int</span>[] nodeValues = stringToIntegerArray(input);</span><br><span class="line">        <span class="comment">// Now convert that list into linked list</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ptr</span> <span class="operator">=</span> dummyRoot;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> item : nodeValues) &#123;</span><br><span class="line">            ptr.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(item);</span><br><span class="line">            ptr = ptr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyRoot.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prettyPrintLinkedList</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (node != <span class="literal">null</span> &amp;&amp; node.next != <span class="literal">null</span>) &#123;</span><br><span class="line">          System.out.print(node.val + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">          node = node.next;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(node.val);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Empty LinkedList&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> Wrapper.stringToListNode(line);</span><br><span class="line">            Wrapper.prettyPrintLinkedList(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Binary-Tree二叉树"><a href="#Binary-Tree二叉树" class="headerlink" title="Binary Tree二叉树"></a>Binary Tree二叉树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">     * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">     *     int val;</span></span><br><span class="line"><span class="comment">     *     TreeNode left;</span></span><br><span class="line"><span class="comment">     *     TreeNode right;</span></span><br><span class="line"><span class="comment">     *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">treeNodeToString</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        nodeQueue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> nodeQueue.remove();</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">              output += <span class="string">&quot;null, &quot;</span>;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            output += String.valueOf(node.val) + <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            nodeQueue.add(node.left);</span><br><span class="line">            nodeQueue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + output.substring(<span class="number">0</span>, output.length() - <span class="number">2</span>) + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建数组-&gt;层次遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">stringToTreeNode</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        input = input.trim();</span><br><span class="line">        input = input.substring(<span class="number">1</span>, input.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (input.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] parts = input.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> parts[<span class="number">0</span>];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(item));</span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        nodeQueue.add(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> nodeQueue.remove();<span class="comment">//移除头</span></span><br><span class="line">            <span class="keyword">if</span> (index == parts.length) &#123;<span class="comment">//如果已经到达数组的长度了-&gt;没有节点了退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            item = parts[index++];</span><br><span class="line">            item = item.trim();</span><br><span class="line">            <span class="keyword">if</span> (!item.equals(<span class="string">&quot;null&quot;</span>)) &#123;<span class="comment">//如果不是空节点</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">leftNumber</span> <span class="operator">=</span> Integer.parseInt(item);</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(leftNumber);</span><br><span class="line">                nodeQueue.add(node.left);<span class="comment">//下一组处理节点中加入这个左节点(要处理这个节点的左右)</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index == parts.length) &#123;<span class="comment">//如果已经到达数组的长度了-&gt;没有节点了退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">            item = parts[index++];<span class="comment">//移动到下一个节点</span></span><br><span class="line">            item = item.trim();</span><br><span class="line">            <span class="keyword">if</span> (!item.equals(<span class="string">&quot;null&quot;</span>)) &#123;<span class="comment">//如果不为空</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rightNumber</span> <span class="operator">=</span> Integer.parseInt(item);</span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rightNumber);</span><br><span class="line">                nodeQueue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prettyPrintTree</span><span class="params">(TreeNode node, String prefix, <span class="type">boolean</span> isLeft)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Empty tree&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            prettyPrintTree(node.right, prefix + (isLeft ? <span class="string">&quot;│   &quot;</span> : <span class="string">&quot;    &quot;</span>), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(prefix + (isLeft ? <span class="string">&quot;└── &quot;</span> : <span class="string">&quot;┌── &quot;</span>) + node.val);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            prettyPrintTree(node.left, prefix + (isLeft ? <span class="string">&quot;    &quot;</span> : <span class="string">&quot;│   &quot;</span>), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prettyPrintTree</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        prettyPrintTree(node,  <span class="string">&quot;&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> Wrapper.stringToTreeNode(line);</span><br><span class="line">            Wrapper.prettyPrintTree(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span>[] generateFibonaccis(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">long</span>[] fib = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">        fib[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            fib[i] = fib[i - <span class="number">2</span>] + fib[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">long</span>[] fib = generateFibonaccis(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.print(Long.toUnsignedString(fib[i]) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>集合框架源码再学习</title>
    <url>/2022/01/16/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h3 id="HashMap-1-8"><a href="#HashMap-1-8" class="headerlink" title="HashMap 1.8"></a>HashMap 1.8</h3><ul>
<li><p><strong>putVal</strong>桶中插入元素扩容</p>
<ul>
<li><p>如果还没有数组，会先进行<strong>resize</strong>初始化</p>
</li>
<li><p>如果已经有了数组</p>
<ul>
<li><p>插入数组<strong>下标<code>(数组长度 - 1) &amp; hash</code></strong></p>
<ul>
<li><p>这个hash是经过哈希扰乱**<code>key.hashCode^(h &gt;&gt;&gt; 16)</code>**异或：相同为0不同为1</p>
<ul>
<li>目的：右位移16位，正好是32bit的一半，为了能够<strong>有效利用前16位</strong>，<strong>混合原始哈希码的高位和低位，以此来加大低位的随机性</strong>。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。如果只利用后面几位，就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成<a href="https://www.zhihu.com/search?q=%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:111577937%7D">等差数列</a>的漏洞，恰好使最后几个低位呈现<strong>规律性重复</strong></li>
<li><a href="https://www.zhihu.com/question/20733617/answer/111577937">hash方法原理</a></li>
</ul>
</li>
<li><p>插入，首先<strong>找到桶的头元素</strong></p>
<ul>
<li>如果头元素跟自己hash值相同<ul>
<li><strong><code>判断key相同 || key.equals(k)</code></strong></li>
</ul>
</li>
<li>如果是树，进入树的<strong>putTreeVal</strong></li>
<li>如果是链表，则进入链表的插入节点或者节点存在退出<ul>
<li>如果链表长度超过了树化阈值8，<strong>尝试</strong>树化<ul>
<li>如果当前总元素少于<strong>64</strong>-&gt;<code>resize</code></li>
<li>否则成为红黑树<code>treeify</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如果是修改元素，直接退出</p>
</li>
<li><p>如果是新增了元素</p>
<ul>
<li><p>判断**++size(总键值对个数)<strong>是否大于扩容阈值<code>threshold</code>，大于进入</strong>resize()**扩容</p>
<blockquote>
<p>如何判断是修改还是新增，设计的很巧妙，用一个记录节点记录，如果找得到旧值，这个节点就会非空，如果找不到旧值，就会成为null，然后最后根据判断null还是有值决定是否判断要不要扩容</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>resize扩容策略</strong> -&gt; <strong>当超过阈值的时候进行数组扩容</strong></p>
<ul>
<li><p>如果HashMap中<strong>还没有</strong>数组</p>
<ul>
<li>将数组初始化为**<code>16</code><strong>长度，扩容阈值为</strong><code>0.75 * 16 = 12</code>**</li>
</ul>
</li>
<li><p>如果HashMao中<strong>已经有</strong>数组了</p>
<ul>
<li>新数组长度为旧数组长度的一倍，**<code>oldTab.length &lt;&lt; 1 </code>**</li>
</ul>
</li>
<li><p>然后开始<strong>迁移</strong>旧数组到新数组</p>
<ul>
<li><p>找到数组中有元素的位置，开始迁移</p>
<ul>
<li><p>当这个桶中<strong>只有这一个元素</strong>的时候，直接赋值到新数组上**<code>newTab[e.hash &amp; (newCap - 1)] = e</code>**</p>
</li>
<li><p>如果是<strong>红黑树</strong>节点，走红黑树迁移流程<code>split</code></p>
</li>
<li><p>如果是有一个<strong>链表</strong></p>
<ul>
<li><p><strong><code>e.hash &amp; oldCap</code></strong></p>
</li>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;记录低位<br>Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;<br>&#x2F;&#x2F;记录高位<br>Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;<br>&#x2F;&#x2F;解析-&gt;扩容之后，相当于比原来多保留了一位<br>&#x2F;&#x2F;这一位可以是1，可以是0<br>&#x2F;&#x2F;相当于新下标要么是原来的，要么是原来的加上2幂<br>OldCap&#x3D;16<br>1 1011-&gt;11<br>0 1011-&gt;27 (11+16)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  ---------		---------</span><br><span class="line">  |loTail |   -&gt; 	|hiTail |</span><br><span class="line">  ---------		---------</span><br><span class="line">      或者</span><br><span class="line">  ---------		---------</span><br><span class="line">  |hiTail |   -&gt; 	|loTail |</span><br><span class="line">  ---------		---------</span><br><span class="line">      //为了防止这种情况，断开这个联系-&gt; .next=null</span><br><span class="line">  if (loTail != null) &#123;</span><br><span class="line">      loTail.next = null;			</span><br><span class="line">      newTab[j] = loHead;			//最后将地位链表迁移到新数组</span><br><span class="line">  &#125;</span><br><span class="line">  if (hiTail != null) &#123;</span><br><span class="line">      hiTail.next = null;</span><br><span class="line">      newTab[j + oldCap] = hiHead; //最后将高位链表迁移到新数组</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>演变-&gt;**<code>2-3</code><strong>树(左倾)-&gt;</strong><code>2-3-4</code>**树变体</p>
<blockquote>
<p>1，每个节点要么是红色，要么是黑色。</p>
<p>2，根节点必须是黑色。叶子节点必须是黑色NULL节点。</p>
<p>3，红色节点不能连续。</p>
<p>4，对于每个节点，从该点至叶子节点的任何路径，都含有相同个数的黑色节点。</p>
<p>5，能够以O(log2(N))的时间复杂度进行搜索、插入、删除操作。此外,任何不平衡都会在3次旋转之内解决。</p>
</blockquote>
<p><a href="https://blog.csdn.net/chen_zhang_yu/article/details/52415077?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2">红黑树的演变(2-3树)</a></p>
<p><img src="/%E6%8E%92%E5%BA%8F/image-20220313104023423.png" alt="image-20220313104023423"></p>
<h3 id="ArraysList"><a href="#ArraysList" class="headerlink" title="ArraysList"></a>ArraysList</h3><p>没有添加任何元素的时候-&gt;容量为<code>0</code>-&gt;懒加载</p>
<p>添加了一个元素之后-&gt;容量变成<code>10</code>-&gt;Default Capacity</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//用于判断或者给容量为0的空数组赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//用于无参构造赋值</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扩容-gt-add"><a href="#扩容-gt-add" class="headerlink" title="扩容-&gt;add"></a>扩容-&gt;add</h4><p><strong><code>原长度+原长度/2</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如何进入扩容？</span><br><span class="line">    当需要的容量比原来的容量大的时候就会进入扩容</span><br><span class="line">    特例：当第一add的时候不是需要<span class="number">1</span>，而是需要<span class="number">10</span>-&gt;因为会进入一步特殊的calculateCapacity	</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">//原长度+原长度/2</span></span><br><span class="line">    <span class="comment">//如果扩容之后比最小容量还是要小-&gt;采用最小容量</span></span><br><span class="line">    <span class="comment">//最小容量是原size+1，也就是至少需要的容量-&gt;ArrayList的做法是给原容量扩大一点</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)					</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//if (newCapacity - MAX_ARRAY_SIZE &gt; 0)	一般走不到这一步</span></span><br><span class="line">    <span class="comment">//    newCapacity = hugeCapacity(minCapacity);</span></span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity); <span class="comment">// 利用copyOf进行扩容</span></span><br><span class="line">&#125;</span><br><span class="line">扩容完之后到add方法-&gt;	elementData[size++] = e; -&gt;size只有在真正填入数组的时候会++</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;<span class="comment">//计算出删除数组之后的元素有多少</span></span><br><span class="line"><span class="comment">//将原数组的index+1到末尾复制到原数组的index到末尾</span></span><br><span class="line">System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,numMoved);</span><br><span class="line"><span class="comment">//收尾工作-&gt;将最后的一个元素-&gt;arraycopy没能删除掉的元素进行删除</span></span><br><span class="line"><span class="comment">// clear to let GC do its work-&gt;让GC明确做它的工作</span></span><br><span class="line">elementData[--size] = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure>

<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;	<span class="comment">//头节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;		<span class="comment">//尾节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;<span class="comment">//初始化的时候啥也不干</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;	<span class="comment">//记录之前的最后一个元素</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);	<span class="comment">//新建一个node节点</span></span><br><span class="line">        last = newNode;	<span class="comment">//让新元素成为左右一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)	<span class="comment">//如果之前没有元素还会让他成为首个元素</span></span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span>			<span class="comment">//否则让之前的元素尾部指向新元素</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;			<span class="comment">//让size++</span></span><br><span class="line">        modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkElementIndex(index);<span class="comment">//先进行检查，看看是否存在</span></span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));<span class="comment">//找到当前节点删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存在-&gt;进行删除</span></span><br><span class="line"><span class="comment">//主要思路-&gt;让前驱的next指向后继-&gt;并且把删除元素最后置为null方便GC-&gt;size--</span></span><br><span class="line"><span class="comment">//如果是首元素或者尾元素还会处理LinkedList的首尾元素</span></span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123; <span class="comment">// 删除这个节点</span></span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item; </span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next; <span class="comment">//记录x节点的后继</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="comment">//记录x节点的前驱</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123; </span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>就是一个HashMap</p>
<p>将<strong>插入元素</strong>作为<strong>key</strong></p>
<p><strong>HashSet</strong>有一个全局唯一的<strong>PRESENT</strong>指向的<strong>Object对象</strong>，add的时候使用其作为map的<strong>value</strong>。</p>
<p>remove(Object o)的时候<code>return m.remove(o)==PRESENT;</code>判断返回value是否为<strong>PRESENT</strong></p>
<blockquote>
<p><strong><code>HashMap</code><strong>的put-&gt;<strong>putVal</strong>-&gt;方法的返回值为</strong>null</strong>或者<strong>value</strong>。如果put<strong>成功的话返回null</strong>，如果put失败的话，说明put的key已经存在了，就会<strong>返回已经存在该key的value值</strong>。</p>
<p>如果这个PRESENT用null的话，无论是移除成功还是移除不成功都会返回null</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//用作value</span></span><br></pre></td></tr></table></figure>

<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>就是用TreeMap实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">|---SortSet 接口</span><br><span class="line">    |-----NavigableMap 接口 -&gt; 到最后还不是用的TreeMap</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><blockquote>
<p>用红黑树实现的</p>
</blockquote>
<p>属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;<span class="comment">//用于在此树形图中维护顺序的比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; left;</span><br><span class="line">        Entry&lt;K,V&gt; right;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK; <span class="comment">//红黑树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><blockquote>
<p>线程安全</p>
</blockquote>
<p><strong>rehash</strong>扩容-&gt;移除的时候采取的策略是<strong>大于扩容阈值</strong>直接扩容**<code>count &gt;= threshold</code><strong>-&gt;</strong><code>(oldCapacity &lt;&lt; 1) + 1</code>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> count;</span><br><span class="line">	<span class="comment">//当表的大小超过此阈值时，表会重新散列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> threshold; </span><br><span class="line">	<span class="comment">//哈希表的负载因子</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">float</span> loadFactor;	<span class="comment">//负载因子不是final static了-&gt;但是默认还是0.75-&gt;用参数形式变成默认0.75了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//空参构造方法</span></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">调用-&gt;<span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line"><span class="comment">//        if (initialCapacity &lt; 0)</span></span><br><span class="line"><span class="comment">//            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span></span><br><span class="line"><span class="comment">//                                               initialCapacity);</span></span><br><span class="line"><span class="comment">//        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span></span><br><span class="line"><span class="comment">//            throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);</span></span><br><span class="line">		<span class="comment">//如果没有初始容量-&gt;让容量为1-&gt;不会进行懒加载</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">            initialCapacity = <span class="number">1</span>;</span><br><span class="line">    	<span class="comment">//赋值负载因子(0.75)</span></span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    	<span class="comment">//下一次扩容阈值-&gt; 当前容量*负载因子(0.75)</span></span><br><span class="line">        threshold = (<span class="type">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap-1-8"><a href="#ConcurrentHashMap-1-8" class="headerlink" title="ConcurrentHashMap 1.8"></a>ConcurrentHashMap 1.8</h3><ul>
<li>初始化，使用 cas 来保证并发安全，懒惰初始化 table</li>
<li>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将链表树化，树化过程<br>会用 synchronized 锁住链表头</li>
<li>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素<br>添加至 bin 的尾部</li>
<li>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新<br>table 进行搜索。</li>
<li>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可<br>做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1&#x2F;6 的节点会把复制到新 table 中</li>
<li>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加<br>即可</li>
</ul>
<blockquote>
<p><strong>不允许有空的Key</strong></p>
<p><strong>哈希扰乱不同spread(key.hashCode())<code>(h ^ (h &gt;&gt;&gt; 16)) &amp; 0x7fffffff</code>会保证hash是个正整数，负数有另外用途</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>sizeCtl</strong></th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>默认</td>
<td>0</td>
</tr>
<tr>
<td>初始化或扩容完成后</td>
<td>下一次的扩容的阈值大小</td>
</tr>
<tr>
<td>初始化时</td>
<td>- 1</td>
</tr>
<tr>
<td>扩容时</td>
<td>- (1 + 扩容线程数)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>不同的节点类型</th>
<th>哈希值</th>
</tr>
</thead>
<tbody><tr>
<td>ForwardingNode 扩容当中已经全部迁移走的桶头元素</td>
<td>MOVED -1</td>
</tr>
<tr>
<td>TREEBIN 红黑树</td>
<td>TREEBIN  -1</td>
</tr>
</tbody></table>
<p><strong>get（Object key）</strong></p>
<blockquote>
<p><strong>全程无锁</strong></p>
</blockquote>
<p>根据**<code>spread(key.hashCode())</code>**找桶头元素</p>
<ul>
<li>如果找到为null返回null</li>
<li>找到了桶头节点<ul>
<li>到之后哈希值相等、equals…替换value</li>
<li>桶头节点hash值为负数<ul>
<li>调用**<code>find</code>**<ul>
<li>如果是<strong>ForwardingNode</strong>节点跑到新数组中找</li>
<li>如果是树节点进入树找</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>putVal</strong></p>
<blockquote>
<p>利用CAS和synchronized(只锁头节点)</p>
</blockquote>
<p>如果连数组都还没有，进入**<code>initTable</code>**</p>
<p>**<code>initTable</code>**：</p>
<ul>
<li>如果发现<strong>sizeCtl</strong>为-1，说明正在初始化，<code>Thread.yield();</code>放开CPU使用权</li>
<li>否则尝试用CAS将<strong>sizeCtl</strong>变成-1<code>unsafe.compareAndSwapInt(this, sizeCtl_offset, sc, -1)</code><ul>
<li>CAS成功，创建初始16大小数组，扩容阈值变成**<code>16*0.75</code><strong>，但是是用另外一种形式</strong><code>sc = n - (n &gt;&gt;&gt; 2)</code>-&gt;n-n&#x2F;4**</li>
<li>失败，自旋尝试，尝试中发现已经创建出数组了退出</li>
</ul>
</li>
</ul>
<p>根据**<code>spread(key.hashCode())</code>**找桶头元素</p>
<ul>
<li><p>如果该位置数组头就为空，直接CAS赋值**<code>casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null))</code>**</p>
</li>
<li><p>如果该位置**<code>头.hash=MOVED</code><strong>,帮忙搬迁</strong>helpTransfer**</p>
</li>
<li><p>否则就是正常状态了，<strong>锁住链表头synchronized (f){} 不是锁住整个表</strong></p>
<ul>
<li>是链表，链表插入或者update</li>
<li>是树，树插入或update</li>
</ul>
</li>
<li><p>如果是插入链表(binConut记录，初始为0)，则判定是否超过<strong>树化阈值TREEIFY_THRESHOLD</strong></p>
<ul>
<li>超过，对数组中那个位置尝试树化<code>treeifyBin</code><ul>
<li>如果数组长度小于64，尝试预先调整表格大小来容纳相应数量的元素</li>
<li>否则树化,锁住数组头，转换成树</li>
</ul>
</li>
</ul>
</li>
<li><p>最后<strong>addCount</strong>，原理跟LongAdder类似，用累加单元数组，累加单元(不同Thread分别在不同地方累加)增大并发度</p>
</li>
</ul>
<h3 id="ConcurrentHashMap-1-7"><a href="#ConcurrentHashMap-1-7" class="headerlink" title="ConcurrentHashMap 1.7"></a>ConcurrentHashMap 1.7</h3><ul>
<li>它维护了一个 <strong>segment 数组</strong>，每个 segment 对应一把锁 -&gt; 继承**<code>ReentrantLock</code>**<ul>
<li>优点：如果多个线程访问不同的 segment，实际是没有冲突的，这与 jdk8 中是类似的</li>
<li>缺点：Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化</li>
</ul>
</li>
<li>this.<strong>segmentShift</strong> 和 this.<strong>segmentMask</strong> 的作用是<strong>决定将 key 的 hash 结果匹配到哪个 segment</strong></li>
</ul>
<p><strong>put</strong></p>
<ul>
<li>计算出segment下标<ul>
<li>判断segment是否创建，没有则CAS创建</li>
<li>进入segment的put流程，**<code>ReentrantLock</code>**尝试加锁<ul>
<li>在这中间可能发生扩容rehash，不用加锁，因为在put中，put已经枷加锁了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p><strong>ReentrantLock</strong></p>
<img src="排序/image-20220316201027678.png" alt="image-20220316201027678" style="zoom: 80%;" />

<p><strong><code>==高明之处==</code></strong></p>
<p><strong>ReentrantLock</strong></p>
<p>在于<strong>用了两把锁和 dummy 节点</strong></p>
<ul>
<li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</li>
<li>用两把锁，同一时刻，<strong>可以允许两个线程同时（一个生产者与一个消费者）执</strong>行<ul>
<li><strong>消费者与消费者线程仍然串行</strong></li>
<li><strong>生产者与生产者线程仍然串行</strong></li>
</ul>
</li>
</ul>
<p>线程安全分析</p>
<ul>
<li>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是<br>head 节点的线程安全。两把锁保证了入队和出队没有竞争</li>
<li>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</li>
<li>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于 put(阻塞) offer(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 用户 take(阻塞) poll(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>

<p><strong>put</strong></p>
<ul>
<li>count 用来维护元素计数</li>
<li>满了等待</li>
<li>有空位, 入队且计数加一<ul>
<li>除了自己 put 以外, 队列还有空位, 由自己叫醒其他 put 线程,<strong>没有使用signalall是为了减少竞争</strong></li>
</ul>
</li>
<li>如果队列中有一个元素, 叫醒 take 线程</li>
</ul>
<p><strong>take</strong></p>
<ul>
<li><p>如果队列中不只一个元素，就由take线程自己唤醒take阻塞线程</p>
</li>
<li><p>如果队列中只有一个空位时, 叫醒 put 线程</p>
</li>
</ul>
<h4 id="LinkedBlockingQueue-与-ArrayBlockingQueue"><a href="#LinkedBlockingQueue-与-ArrayBlockingQueue" class="headerlink" title="LinkedBlockingQueue 与 ArrayBlockingQueue"></a>LinkedBlockingQueue 与 ArrayBlockingQueue</h4><p><strong>性能比较</strong></p>
<ul>
<li>Linked 支持有界，Array 强制有界</li>
<li>Linked 实现是链表，Array 实现是数组</li>
<li>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</li>
<li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</li>
<li>Linked 两把锁，Array 一把锁</li>
</ul>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p><strong><code>CAS调节头尾节点</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(e, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取尾节点</span></span><br><span class="line">        AtomicReference&lt;Node&lt;E&gt;&gt; next = last.next;</span><br><span class="line">        <span class="comment">// S1: 真正尾节点的 next 是 null, cas 从 null 到新节点</span></span><br><span class="line">        <span class="keyword">if</span>(next.compareAndSet(<span class="literal">null</span>, n)) &#123;</span><br><span class="line">            <span class="comment">// 这时的 last 已经是倒数第二, next 不为空了, 其它线程的 cas 肯定失败</span></span><br><span class="line">            <span class="comment">// S2: 更新 last 为倒数第一的节点</span></span><br><span class="line">            last = n;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Comparable-amp-Comparator"><a href="#Comparable-amp-Comparator" class="headerlink" title="Comparable &amp; Comparator"></a>Comparable &amp; Comparator</h3><blockquote>
<p>都是接口</p>
<p><strong>Comparable</strong>相当于<strong>内部比较器</strong>,而<strong>Comparator</strong>相当于<strong>外部比较器</strong>。</p>
</blockquote>
<ul>
<li>Comparable </li>
<li>Comparator</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">k1.compareTo(k2)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">comparator.compare(k1, k2)</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JAVA源码</category>
      </categories>
  </entry>
</search>
